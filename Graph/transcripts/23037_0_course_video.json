[{"lecture": "23037_0_course_video", "Timestamps": [{"text": "  Hallo und herzlich willkommen zur letzten Tafeluebung im Modul-System-Programmierung.  Mein Name ist Alexander Bau und ich bespreche heute mit euch das sechste Aufgabenblatt.  Nun wollen wir uns mit Dateisystemen beschaeftigen, genauer gesagt mit blockbasierten Dateisystemen  und dabei auf Verwaltungsstrukturen und den Begriff Fragmentierung eingehen.", "start": 0.0, "end": 28.0}, {"text": "  Optimal waere es, wenn wir beim Erstellen einer Datei bereits wissen wuerden, wie gross sie wird.  Dann koennten wir Datei hinter Datei auf einem Datentraeger abspeichern und haetten keine weitere Fragmentierung.  In der Realitaet gibt es jedoch Schreib- und Loeschvorgaenge, sodass Dateien typischerweise dynamisch wachsen.", "start": 28.0, "end": 48.0}, {"text": "  Wieder ist die verkettete Liste eine Loesung, um diese dynamisch wachsende Struktur abzuspeichern.  Dabei wuerden wir auf dem Datentraeger zunaechst ein Verzeichnis hinterlegen, wo der Pfeilname mit Start und Endblock markiert ist.", "start": 48.0, "end": 69.0}, {"text": " Anschliessend koennen wir beim Startblock beginnen, diesen Laden evaluieren, indem zum Beispiel der erste Teil ein Pointer ist auf den naechsten Block,  dann diesen Block laden und immer so weiter durch die gesamte Liste gehen, bis wir die gesamte Datei im Speicher haben.", "start": 69.0, "end": 79.0}, {"text": " Das Problem daran ist, dass natuerlich die Lesevorgaenge an sich sehr lange dauern,  da wir immer erst jeden Block einzeln anfordern muessen, bevor wir den naechsten Block anfordern koennen.  Eine Verbesserung ist es, wenn wir erst die Blocknummern lesen koennten.  Dafuer verwalten wir die verkettete Liste einfach in einer Hilfstabelle am Anfang des Datentraegers.", "start": 79.0, "end": 95.0}, {"text": "  Anschliessend koennen wir alle Datenbloecke auf einmal anfordern und sind so entsprechend schneller.  Wie liest man nun zu einer Hilfstabelle?  Schauen wir uns die Zeichnung auf der linken Seite an.  Achtung, hier sind zwar zwei Spalten gezeigt, aber die linke Spalt ist nur der Lesbarkeit halber da,  um sehen zu koennen, welche Nummer welchem Block zugeordnet wird.", "start": 95.0, "end": 117.0}, {"text": "  Die Hilfstabelle besteht also aus mehreren Eintraegen und aus seinem Verzeichnis muessen wir wissen, wo Datei A beginnt.  Wenn wir wissen, dass Datei A im vierten Block beginnt, schauen wir also in den vierten Eintrag der Fahrtabelle.  Dort steht eine 1, damit wissen wir, der naechste zu ladende Block waere Blocknummer 1.", "start": 117.0, "end": 135.0}, {"text": "  So folgen wir dieser Tabelle. In der 1 steht die 5, in der 5 die 7 und in der 7 die Nall.  Mit Nall wissen wir, dass diese Datei fertig zu Ende eingelesen waere.  Wenn wir nur die Blocke 4, 1, 5 und 7 laden.  Aequivalent koennte man das auch fuer Datei B machen.  Diese beginnt im Blocknummer 0. Dort steht im 0. Eintrag der Fahrtabelle eine 2.", "start": 135.0, "end": 157.0}, {"text": "  Das heisst, nach dem Blocknummer 0 kommt die 2, dann die 3, dann die 6 und dann mit 0 ist wieder zu Ende.  In der echten Fahrtabelle waere da ein leichter Unterschied.  Dort wird im 0. Eintrag der Fahrtabelle eine Magic Number verwendet.  Diese ist noch aus Zeiten der Floppy-Disk vorhanden und im ersten Eintrag steht das Zeichen fuer End-of-File.", "start": 157.0, "end": 178.0}, {"text": "  Typischerweise ist das eine Minus 1, da ist also ein kleiner Unterschied zu unserem Modell.  Anschliessend allerdings ist auch wieder festgelegt, dass hier rot markierte der dritte Eintrag,  das ist das Route Directory, beziehungsweise dort, wo es beginnt.", "start": 178.0, "end": 207.0}, {"text": " Man wuesste also, wenn man hier im sozusagen zweiten Eintrag 0, den ersten zweiten Eintrag der Fahrtabelle beginnt zu lesen,  dass das Route Directory sich ueber die Blocknummer 2, 9, a, was Hexadizimal fuer 10 steht, b und 1, 1 erstreckt.  Der letzte rote Block, sozusagen sehen wir auch, ist mit hexadizimalem f gefuellt, damit wissen wir hier, ist die Datei zu Ende.", "start": 207.0, "end": 224.0}, {"text": "  Und aus dem Route Directory koennen wir jetzt weitere Entweder-Directories oder Files lesen und somit unseren kompletten Datentraeger aufbauen.  Eine vor allen Dingen Unix-Systemen verbreitete Art, Datei-Systeme zu verwalten, ist die der Index-Blocke oder kurz Ein-Nots genannt.  Dabei haben wir im Gegensatz zur FAT eine Tabelle fuer jede eigene Datei.", "start": 224.0, "end": 243.0}, {"text": "  Wenn dort also ein Fehler auftritt, dann ist nur eine Datei zerstoert, nicht das komplette Datei-System.  Des Weiteren werden also alle Bloecke hier hinterlegt, so dass sich die Datei komplett laden kann und zum Teil auch noch ein paar Meter Informationen hinterlegt.  Das Ganze kann man rechts unten gesehen noch etwas erweitern.", "start": 243.0, "end": 266.0}, {"text": "  Das waere das X4-Datei-System, das man Extents erstellt, die also jetzt sagen, wenn man Datenbloecke aneinander gereit hat, die zu dieser Datei gehoeren, wo diese sich befinden.  Zum Beispiel koennte man sagen, Block 0 bis 55 ist im Datei-System anstelle 1200 zu finden und Block 56 bis 1400 zum Beispiel anstelle 9.950.", "start": 266.0, "end": 292.0}, {"text": "  Als Letzte sei noch auf das Journaling hingewiesen, eine Moeglichkeit, entsprechende Schreib- und Leseroperationen zu locken und damit inkonsistente Daten zu veraendern.  Egal wie, aber wenn wir Dateien blockweise auf Datentraegern hinterlegen, wird es zwangslaeufig zu Fragmentierung kommen.", "start": 293.0, "end": 306.0}, {"text": "  Abhaengig vom verwendeten Datentraeger, wie zum Beispiel eine HDD, hat dies dann auch noch Einfluss auf die Ladezeiten.  Schauen wir uns mal so eine HDD an, rechts oben das Bild, dann sehen wir, dass dort ein Schreiblesekopf integriert ist.", "start": 306.0, "end": 322.0}, {"text": "  Abhaengig davon, wie unsere Datei also ueber die Festplatte verteilt ist, muss dieser unterschiedliche Sektoren oder sogar Zylinder lesen und braucht entsprechend Zeit, bis alle Bloecke geladen wurden.  Bei einer Defragmentierung wuerde man alle Bloecke einer Datei laden und abschliessend an eine freie Speicherstelle zusammenhaengend abspeichern.", "start": 323.0, "end": 335.0}, {"text": "  Dadurch wuerde beim naechsten Zugriff die Ladezeit sehr viel kleiner sein.  Wiederum beim flashbasierten Speichermedium, zum Beispiel an der SSD, wird von der Defragmentierung sogar abgeraten.  Hier haben wir zum einen keinen Vorteil, denn ob ich nun mal bildlich gesprochen die Zelle links oben oder rechts unten anspreche, die Zugriffszeit wird ungefaehr die gleiche sein, aber noch viel schlimmer.", "start": 336.0, "end": 358.0}, {"text": "  Eine Zelle kann nur endlich oft geschrieben werden, bevor sie Schaden nimmt.  Das heisst, ich wuerde hier sogar die Lebensdauer meiner SSD verkuerzen.  Die letzte Aufgabe ist Aufgabe 6.4. Hier wollen wir uns eine fehlerhafte Fahrtabelle anschauen.  Wie vorhin schon erwaehnt ist die Fahrtabelle also in diesem Falle zwei Spalttrick.  In Wahrheit ist es nur die rechte Spalte.", "start": 358.0, "end": 385.0}, {"text": "  In der linken Spalte, so solltet ihr das auch in der Hausaufgabe machen, koennen wir aber markieren, wo die einzelnen Dateien starten.  Im echten Leben wuerde das in einem Verzeichnis hinterlegt sein.  Schauen wir uns also die einzelnen Dateien einmal an.  Datei B startet im zweiten Block und in der Fahrtabelle steht dort der Eintrag 0.", "start": 386.0, "end": 402.0}, {"text": "  Das heisst, der naechste Block, der geladen werden muesste, waere Block 0.  Nach 0 kommt 4 und im vierten Eintrag steht Null.  Damit waere Datei B fertig eingelesen.  Zumindest laut FAT ist die Datei B damit bestehend aus Block 2, 0 und 4.  Schauen wir uns die naechste Datei an. Das waere Datei A.  Diese startet im Block Nr. 5.  Geht dann weiter, der naechste Block waere Block 10.", "start": 402.0, "end": 428.0}, {"text": "  Anschliessend Block 9, Block 6, Block 9.  Da merken wir, hier kommen wir in einen Zeikel.  Je nachdem, wie das Ganze implementiert ist, wird im schlimmsten Fall das Betriebssystem abschmieren  oder aber der eigene Prozess gekillt und somit verhindert, dass hier ein Endlos-Seikel entsteht.  Schauen wir uns der Vollstaendigkeit teilweise nochmal Datei C an.", "start": 429.0, "end": 454.0}, {"text": "  Diese beginnt im Block Nr. 7, geht dann weiter nach 3, zur 8 und in 8 ist Null.  Sieht also so aus, als ob alles richtig ist.  Vergleichen wir noch einmal, was auffallen duerfte, ist, dass der Block Nr. 1, der auf Block Nr. 3 verzeigt,  keine Datei hier zugeordnet werden kann.", "start": 455.0, "end": 477.0}, {"text": " Allerdings wissen wir jetzt nicht, ob die FAT natuerlich noch weitergeht  und selbst wenn waere das erstmal kein grosser Fehler, dass Block Nr. 1 auf Block Nr. 3 verzeigt,  aber keine Datei auf Block Nr. 1 verzweigt.", "start": 478.0, "end": 480.0}]}]