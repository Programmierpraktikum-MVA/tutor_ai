[{"lecture": "31624_2_course_video", "Timestamps": [{"text": "  Schauen wir uns nun abschliessen, die beiden Hausaufgaben des Aufgamblottes an, in der das  ebengelernte angewendet werden soll.  Beginn werden wir mit Aufgabe 3 zu Generics.  Schauen wir uns zu Beginn erst einmal an, was in der Aufgabe gemacht werden soll.  Hier sollte eine Klasse Pair implementieren, die zwei Elemente eines beliebigen, eines  generischen Types speichern kann.", "start": 0.0, "end": 31.5}, {"text": "  Diese beiden Elemente sollen dann den gleichen generischen Typen besitzen und als Private  Variable in der Klasse gespeichert werden.  Der Zugriff geschieht ueber sogenannte Getter und Setter-Methoden.  Wiederholen wir doch einmal kurz die Begrifflichkeiten, die hier in der Aufgabe genannt wurden.  Zuerst kommen wir zu dem Begriff der Klasse.", "start": 31.5, "end": 51.92}, {"text": "  In der Realitaet ist alles irgendwie in Klassen unterteilbar.  Von einer Klasse kann es mehrere Objekte geben.  Generell laesst sich sagen, dass Klassen die Eigenschaften und Funktionen von mehreren  Objekten zusammenfassen bzw. ein generellen Bauplan fuer diese Objekte liefern.  In Java sind die Klassen folgendermassen aufgebaut.  Eine Klasse besteht unter anderem aus Attributen.", "start": 51.92, "end": 80.12}, {"text": "  Die Attribute sind die Variable in einer Klasse, koennen aber auch als Eigenschaften  einer Klasse angesehen werden.  Der Konstruktor ist eine Methode, der diese Attribute initialisiert.  Neben dem Konstruktor kann eine Klasse noch viele weitere Methoden haben.  In der Hausaufgabe soll die Klasse zwei Attribute besitzen.  Sie werden in einer Klasse deklariert.", "start": 80.12, "end": 103.52}, {"text": "  Sie repraesentieren die Eigenschaften eines Objekts.  Diese Attribute werden dann beim Erstellen des Objekts durch den Konstruktor initialisiert.  Wichtig ist auch, dass alle Objekte einer Klasse immer die gleichen Attribute haben.  Diese koennen allerdings unterschiedliche Werte haben, je nachdem wie sie initialisiert wurden  oder wie sich die Werte waehrend der Laufzeit veraendert haben.", "start": 103.52, "end": 128.96}, {"text": "  Die Suendachs zum Erstellen der Attribute sieht folgendermassen aus.  Wir haben zuerst das Zugriffsattribut, das kann zum Beispiel Private oder Public sein,  anschliessend den Datentypen der Variable bzw. unseres Attributs und schlussendlich den Namen des Attributs.  Statt eines festen Datentyps sollen in der Hausaufgabe allerdings Generics verwendet werden.", "start": 128.96, "end": 155.04}, {"text": "  Als kurze Wiederholung, Generics koennen wir dann verwenden, wenn noch unbekannt ist,  welchen Datentyp ein Objekt hat.  Wir verwenden Generics also als Platzhalter fuer einen Datentypen.  Das sieht dann folgendermassen aus.  Wenn wir die Klasse generisch definieren, dann setzen wir hinter den Klassennamen in Spitzenklammern,  in diesem Fall beispielsweise ein T.", "start": 155.04, "end": 176.76000000000002}, {"text": "  Dieses T ist nun Platzhalter fuer den Datentyp.  Innerhalb meiner Klasse kann ich dann, wenn ich zum Beispiel ein Attribut erstelle,  diesen Datentyp T als Platzhalter einsetzen.  In diesem Fall habe ich also ein Attribut vom Datentyp T mit einem bestimmten Namen.", "start": 176.76000000000002, "end": 202.76000000000002}, {"text": " Beim Erstellen eines Objektes der Klasse gibt man dann den Datentypen an  und das T wird entsprechend in der Klasse durch diesen Datentypen ersetzt.  Fuer die Hausaufgabe sollen zwei Attribute vom Datentyp T erstellt werden,  die beide das Zugrussattribut Private haben.  Moechte man trotzdem von ausserhalb auf diese Attribute zugreifen,  dann sind Getter und Setter Methoden notwendig.", "start": 202.76000000000002, "end": 225.96}, {"text": "  Diese werden verwendet, um den Lese- und Schreibzugriff auf ein privates Attribut zu kontrollieren.  Eine Getter-Methode sieht folgendermassen aus.  Ist das Attribut Private und ich moechte es von aussen lesen koennen,  so muss meine Getter-Methode public sein.  Anschliessend folgt der Datentyp meines Attributs.", "start": 225.96, "end": 245.96}, {"text": "  In diesem Fall ist mein Attribut ein Integer, deswegen gibt meine Getter-Methode auch ein Integer zurueck.  Hat mein Attribut einen generischen Datentyp, so kann ich auch den Rueckgabetyp der Getter-Methode entsprechend anpassen,  indem ich dort den Platzhalter einsetze.  Anschliessend folgt der Name der Getter-Methode.", "start": 245.96, "end": 265.56}, {"text": "  Alles was diese Getter-Methode nun macht, ist den Wert dieses Attributs zurueckgeben.  Die Setter-Methode sieht sehr aehnlich aus.  Auch hier haben wir wieder ein privates Attribut  und moechten nun allerdings nicht den Wert des Attributs lesen,  sondern den Wert des Attributs schreiben.  Dazu brauchen wir wieder eine von aussen zugaengliche Methode, deswegen Public.", "start": 265.56, "end": 286.16}, {"text": "  Diese muss allerdings nichts zurueckgeben, deswegen ist der Rueckgabetyp void.  Ich kann wieder irgendeinen Namen waehlen.  Allerdings baue ich diesmal einen Parameter, der den gleichen Datentyp hat wie mein Attribut.  Das ist der Wert, auf den ich mein Attribut setzen moechte.  In diesem Fall ist der Datentyp Integer.", "start": 286.16, "end": 305.76000000000005}, {"text": "  In einer generischen Klasse kann ich allerdings natuerlich auch wieder den generischen Datentypen verwenden.  Alles was in der Setter-Methode passiert, ist das Attribut auf diesen Wert zu setzen.  Im zweiten Teil der Aufgabe sollen die geerbten Methoden Equals und Two-String ueberschrieben werden.  Die Methoden Equals und Two-String sind fuer jedes Jahr war Objekt definiert.", "start": 305.76000000000005, "end": 333.96}, {"text": "  Moechte man diese allerdings modifizieren, ist das moeglich, indem man die Methode in der Klasse selbst noch einmal implementiert.  Hierzu erstmal eine kleine Wiederholung zu Strings.  Strings sind Zeichenketten aus mehreren Charaktern.  Diese koennen auch mit anderen Strings konkateniert werden.  Hier ein kleines Beispiel.", "start": 333.96, "end": 354.56}, {"text": " In der ersten Zeile deklariere ich einen String mit dem Namen S  und initialisiere ihn mit der Zeichenkette Hallo.  In der zweiten Zeile kann ich dann mit dem Plus-Symbol einen Leerzeichen an den String anfuegen.  Das Ganze kann ich sogar noch abkuerzen wie in der dritten Zeile und mittels des Plus-Gleich-Symbols etwas an diesen String anfuegen in diesem Fallwelt.", "start": 354.56, "end": 374.36}, {"text": "  Der Resultieren des Stringes waere also Hallo-Welt.  Die Methode Two-String, die jedes Objekt besitzt, gibt die String-Repraesentation eines Objektes zurueck.  Sie hat die folgende Signatur.  Da man von aussen darauf zugreifen koennen muss, ist sie Public.  Sie gibt einen String zurueck und traegt den Namen Two-String.  Parameter bekommt sie keine.", "start": 374.36, "end": 402.56}, {"text": "  Moechte man nun selbst definieren, wie die String-Repraesentation eines Objektes aussehen soll, so kann man die Methode einfach ueberschreiben.  Dazu kann man in seiner Klasse entweder selbst eine Methode definieren, die den folgenden Methoden kopfert,  oder man verwendet, wie in den Anmerkungen des Aufgabenplatzerwaehnt, die Generate-Methode der IDE.", "start": 402.56, "end": 420.36}, {"text": "  Die zweite Methode, die ueberschrieben werden soll, ist die Equalize-Methode.  Diese gibt True zurueck, wenn zwei Objekte gleich sind, und gibt False zurueck, wenn die Objekte nicht gleich sind.  Da man wieder von aussen auf diese Methode zugreifen koennen muss, ist diese Methode Public.  Sie gibt einen Boolean zurueck, der entweder True oder False ist, und heisst Equals.", "start": 420.36, "end": 447.56}, {"text": "  Da ich zwei Objekte miteinander vergleichen moechte, brauche ich ein Parameter, um das Vergleichsobjekt zu uebergeben.  Innerhalb dieser Methode wird immer das Objekt, in dem wir uns gerade befinden, mit dem Objekt, was als Parameter uebergeben wird, verglichen.  Wie genau die beiden Objekte miteinander verglichen werden sollen, findet ihr auch noch einmal in den Anmerkungen des Hausabgabenblattes.", "start": 447.56, "end": 464.36}]}]