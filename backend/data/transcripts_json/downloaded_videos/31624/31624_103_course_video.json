[{"lecture": "31624_103_course_video", "Timestamps": [{"text": "  In der ersten Aufgabe schauen wir uns die Berechnung der Laufzeit von den sechs Ihnen  gegebenen kleinen Programmabschnitten an.  Dazu gehen wir erst einmal ein paar grundlegende Regeln durch, die Ihnen bei der Berechnung  helfen koennen.  Dann sollten Sie einmal versuchen, ob Sie die Probleme alleine geloest bekommen und  das Video pausieren.  Danach gehe ich die Loesungen einmal durch.", "start": 0.0, "end": 25.44}, {"text": "  Nun ein paar Grundlagen.  Regel Nr. 1.  Die Laufzeiten von Schritten, die nacheinander ausgefuehrt werden, werden addiert.  Regel Nr. 2.  Die Laufzeiten von Schritten, die in einer Schleife ausgefuehrt werden, werden mit der  Komplexitaet der Schleife multipliziert.", "start": 25.44, "end": 48.08}, {"text": " Diese Regel leintet sich aus der ersten ab, weil die Schritte innerhalb der Schleife x-mal  hintereinander ausgefuehrt werden, solange wie die Schleife durchlacht.  Regel Nr. 3.  Wenn ein Problem in jedem Schritt doppelt so gross wird, ist die Laufzeit exponentiell.  In diesem Fall zu Basis 2.  Regel Nr. 4.", "start": 48.08, "end": 66.64}, {"text": " Wenn ein Problem sich exponentiell schnell seine Abbruchbedingungen naehert, ist die  Laufzeit logarithmisch.  Regel Nr. 5.  Konstanten werden bei der Angabe der Komplexitaet immer weggelassen.  Wir gehen jetzt die Loesung durch zu diesen sechs Problemen.  Pausieren Sie das Video und wenden Sie einmal die gerade durchgegangenen Regeln an.", "start": 66.64, "end": 84.92}, {"text": "  Beachten Sie dabei, dass wir annehmen, dass N eine natuerliche Zahl ist.  Wir besprechen jetzt die Loesung.  Die Funktion F1 besteht aus zwei ineinander geschachtelten Vorschleifen.  Jede laeuft von 0 bis N, hat also fuer sich eine Komplexitaet von N.  Da die eine Schleife in der anderen durchlaufen wird, muessen wir beide Werte multiplizieren,  genau wie es die Regel 2 vortritt.", "start": 84.96000000000001, "end": 111.8}, {"text": "  Anders gesagt, weil fuer jedes i in der aeusseren Schleife die innere Schleife einmal vollstaendig  durchlaufen wird, muessen wir beide Werte multiplizieren.  Damit erhalten wir eine Laufzeit von o von N\u00b2.  Die Funktion F2 sieht erst einmal recht aehnlich aus, hat aber zwei Unterschiede.  Die erste Schleife laeuft nur bis N halbe und die zweite Schleife laeuft nur bis i.", "start": 111.8, "end": 134.36}, {"text": "  Was das jetzt genau heisst, wenn wir die Durchlaeufe der inneren Schleife anschauen,  in Abhaengigkeit von i, ist folgendes.  Fuer i gleich 0 laeuft die innere Schleife kein einziges Mal durch.  Fuer i gleich 1 gibt es einen Durchlauf der inneren Schleife, fuer i gleich 2, 2 Durchlaeufe,  fuer i gleich 3, 3 Durchlaeufe und so weiter und so fort.  Diese Schritte werden alle nacheinander ausgefuehrt.", "start": 134.36, "end": 159.88000000000002}, {"text": "  Es werden also fuer die Laufzeit die natuerlichen Zahlen addiert bis N halbe, was wir fuer den Moment mal x nennen.  Fuer die Addition aller natuerlichen Zahlen bis x kennen wir die Formel von Gauss,  das ergibt x minus 1 mal x durch 2.  Das waere eine Art an dieses Problem heranzugehen.  Eine zweite waere zu versuchen, Durchlaeufe direkt aus den Vorschleifen abzulesen.", "start": 161.12, "end": 181.84}, {"text": "  Nennen wir hierfuer N halbe wieder x, damit wir weniger schreiben muessen.  Die aeussere Schleife laeuft x mal durch.  Die innere Schleife wird nie x mal durchlaufen, weil j immer kleiner ist als i.  Daher nehmen wir hier als Maximum x minus 1.  Dann laeuft sie aber auch nur im letzten Durchlauf alle x minus 1 mal durch,  waehrend sie im ersten kein Mal durchlaeuft.", "start": 182.84, "end": 206.84}, {"text": "  Im zweiten Durchlauf laeuft sie einmal durch und im vorletzten x minus 2 mal und so weiter.  Daraus laesst sich ableiten, dass die innere Schleife im Schnitt x minus 1 durch 2 mal durchlaufen wird.  Beide Werte werden multipliziert nach unserer zweiten Regel und wir kommen auf das gleiche Ergebnis wie gerade eben.", "start": 206.84, "end": 226.84}, {"text": "  Man kann auch hier, wie im letzten Tutorial, das Bild der 3x Matrix nutzen, wenn es einem hilft.  Dabei wird zum Beispiel in den Spalten i hochgezaehlt und in den Zeilen der Matrix j.  In allen Schleifen-Durchlaeufen betrachten wir wieder nur eine Haelfte der x mal x minus 1 Moeglichkeiten,  die es gaebe, wenn beide Schleifen immer ganz durchlaufen wuerden.", "start": 226.84, "end": 248.84}, {"text": "  Nun muessen wir noch einen letzten Schritt gehen, naemlich Regel 5 befolgen und alle Konstanten weglassen.  Damit kommen wir am Ende auch wieder bei o von n\u00b2 raus.  Die Funktion f3 beschreibt eine Rekursion.  Hier gibt es zwei wichtige Kriterien.  Die Menge und die Art der Rekursionsaufrufe und die Abbruchbedingung.  Es kann auch Programme geben, in denen zum Beispiel eine Abbruchbedingung ist.", "start": 248.84, "end": 277.84}, {"text": "  In diesem Fall haben wir einen Rekursionsaufruf, in dem n immer um 1 verringert wird  und eine Abbruchbedingung, die die Rekursion beendet, wenn n gleich 0 ist.  Das passiert fuer natuerliche Zahlen nach n Rekursionsaufrufen  und damit ergibt sich eine Laufzeit von o von n.", "start": 277.84, "end": 301.84}, {"text": " Mit der hier vorgestellten Loesung zur Funktion f4 machen wir zur Vereinfachung eine obere Abschaetzung der Komplexitaet,  wie man auch die Tritterheraichi richtig bestimmt finden sie im Skript, im Beispiel f6.  Aufgaben dieser Art werden in der Klasur nicht vorkommen, deshalb wird hier nur die obere Abschaetzung betrachtet.", "start": 301.84, "end": 312.84}, {"text": "  Aber ich wollte die Moeglichkeit nutzen, um darauf zu verweisen, dass es nicht immer ganz so einfach ist  und diese Faelle im Skript beleuchtet werden.  Nun zur Funktion 4.  f4 ruft f3 in einer Schleife auf.  Die Besonderheit der Schleife ist, dass i immer verdorben wird.  i waechst also exponentiell und ehrt sich damit unsere Abbruchbedingungen i kleiner n exponentiell schnell an.", "start": 312.84, "end": 334.84}, {"text": "  Die Laufzeit der Schleife ist folglich logarithmisch.  In der Schleife wird die Funktion f3 aufgerufen, welche eine Laufzeit von o von n hat.  Beide werden wieder multipliziert nach der Regel 2 und wir erhalten o von n log n als Ergebnis.  Die Funktion f5 ist auch wieder eine Rekursion,  diesmal haben wir aber 2 Rekursionsaufrufen, in dem einen verringern wir n um 1 und in dem anderen um 2.", "start": 334.84, "end": 364.84}, {"text": "  Unsere Abbruchbedingungen greift, wenn n kleiner gleiche 1, das passiert in beiden Faellen.  In dieser Rekursion verdoppeln wir aber unser Problem in jedem Schritt.  Mit den 2 Rekursionsaufrufen, wir haben also eine exponentielle Laufzeit  und die letzte Rekursion, die abgerufen wird, ist die Schleife.  Wir haben also eine Laufzeit von 2 hoch n.", "start": 364.84, "end": 388.84}, {"text": "  Mit der Funktion f6 schauen wir uns nun das letzte Beispiel an und auch das ist wieder eine Rekursion.  Es gibt einen Rekursionsaufruf, in dem n immer halbiert wird.  Und die Abbruchbedingung gilt fuer n gleich 0.  Fuer diese Abbruchbedingung ist wichtig, dass es sich bei n um 1 int handelt,  denn fuer int gilt 1 durch 2 ist 0.", "start": 388.84, "end": 411.84}, {"text": " Waehrend sich ein Double zu zentrales Laufzeit der Schleife verringert,  waehrend sich ein Double z.B. immer weiter halbieren wuerde bis zur Computergenauigkeit.  Das betrachten wir hier nicht.  Stattdessen wird unser Problem in jedem Schritt halb so gross wie vorher,  weil n sich halbiert hat und damit haben wir wieder eine logarithmische Laufzeit von N.", "start": 411.84, "end": 421.84}]}]