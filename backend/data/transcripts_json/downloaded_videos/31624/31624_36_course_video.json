[{"lecture": "31624_36_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns mit dem Testen von Programmen beschaeftigen.  Dazu schauen wir uns erstmal an, wo zu testen ueberhaupt gut ist.  Mit ausfuehrlichen Software-Tests moechte man sicherstellen, dass die Software auch eben  genau das tut, was sie tun soll.  Tut ein Programm mal nicht das, was es tun soll, fuehrt das im Modul-Algodat oft nur zu  Punktabzug.", "start": 0.0, "end": 30.439999999999998}, {"text": "  Je nachdem, wo die Software angewendet wird, kann der Schaden allerdings deutlich groesser  sein.  Geschaetzt entsteht ein Schaden von ca. 84 Milliarden Dollar jaehrlich in Unternehmen  alleine wegen Software-Fehlern.  Doch es koennen nicht nur finanzielle Schaeden entstehen.  Immer wieder hoert man heutzutage von Faellen, wo es fremden moeglich war, auf Kundendaten  von grossen Firmen zuzugreifen.", "start": 30.439999999999998, "end": 57.839999999999996}, {"text": "  In den schlimmsten und zum Glueck auch seltensten Faellen kann eine Fehlerhafte Software allerdings  auch Menschenleben kosten.  Ich habe hier einmal zwei beruehmte Beispiele aufgelistet.  Zum einen haben wir das Beispiel einer Steuerungssoftware fuer Roentgengeraete.", "start": 57.839999999999996, "end": 78.44}, {"text": " Hier kam es in der Vergangenheit dazu, dass ein Fehler in dieser Steuerungssoftware dazu  gefuehrt hat, dass das Geraet die bis zu hundertfache Menge an Strahlung abgegeben hat.  Dies hat bei einigen Patienten zu schwerwiegenden Strahlenverletzungen gefuehrt.  Ein weiteres beruehmtes Beispiel ist die Ariana 5 Rakete.  Diese explodierte auch aufgrund eines Software-Fehlers bereits kurz nach dem Start.", "start": 79.44, "end": 98.92}, {"text": "  Natuerlich werdet ihr in diesem Modul keine lebenswichtige Software schreiben.  Doch vielleicht konnte ich euch mit diesen Beispielen zeigen, warum Testen von Software  so wichtig ist und einen kleinen Anreiz geben, euch naeher mit dem Thema zu befassen.  Software-Fehler lassen sich in verschiedene Unterarten von Fehlern aufteilen.  Zum einen haben wir die Suendachsfehler.", "start": 98.92, "end": 122.72}, {"text": "  Ein Suendachsfehler liegt vor, wenn der geschriebene Code nicht der Suendachs der Sprache entspricht.  Dies wird vom Compiler angezeigt.  Bekannte Beispiele sind, wenn man hier zum Beispiel geschweifte Klammern vergessen hat  oder irgendwo ein Simikolon.  Etwas schwieriger zu finden sind die sementischen Fehler.", "start": 122.72, "end": 142.6}, {"text": "  Hier verwendet man zwar die richtige Suendachs, allerdings kommt es trotzdem zu Fehlern,  weil man zum Beispiel falsche Parameter beim Aufrufen verwendet,  Klammern an der falschen Stelle setzt oder falsche Datentypen verwendet.  Das Programm laesst sich dann ausfuehren, weil die Suendachs korrekt ist.  Es kann aber passieren, dass es nicht das macht, was man moechte.", "start": 142.6, "end": 162.12}, {"text": "  Das bringt uns zu den logischen Fehlern.  Hierbei laesst sich das Programm zwar ausfuehren, aber das Verhalten entspricht eben nicht der Spezifikation.  Es wird also sowohl die richtige Suendachs verwendet, als auch die richtigen Parameter und Klammerungen.  Allerdings hat man irgendetwas nicht beachtet oder schlicht einen Denkfehler.", "start": 163.12, "end": 189.12}, {"text": "  Diese Fehler treten haeufig auf, wenn man die Spezifikation oder wie in eurem Fall die Aufgabe,  anders versteht, als sie gemeint ist und somit ein anderes Ergebnis erhaelt, als zum Beispiel die Musterloesung.  Das sind auch die Fehler, auf die eure Abgabe letztendlich getestet wird.", "start": 189.12, "end": 210.12}, {"text": "  Neben diesen drei Fehlern, durch die das Programm eben nicht genau das macht, was in der Spezifikation steht, gibt es noch die Designfehler.  Bei den Designfehlern ist schlichtweg die Spezifikation des Programms falsch.  Wuerden wir das Beispiel auf eure Hausaufgaben anwenden, wuerde das heissen, ihr habt genau das Programmiert, was in den Hausaufgaben steht, aber der Hausaufgabentext ist falsch.", "start": 211.12, "end": 227.12}, {"text": "  Das waere ein Designfehler.  Wir wollen uns allerdings vor allem auf die Suendachsfehler und die logischen Fehler konzentrieren.  Suendachsfehler werden vom Compiler angezeigt und sind daher oft einfach zu finden.  Logische Fehler findet man allerdings nicht so schnell und lassen sich nur identifizieren, wenn man das Programm entsprechend testet.", "start": 227.12, "end": 252.12}, {"text": "  Zum Testen von Java-Programm gibt es das Framework JUnit.  Dieses bietet uns vordefinierte Testfunktion, mit denen man Werte von Variablen und Rueckgabewerte von Funktionen ueberpruefen kann.  Dazu erstellt man sich meistens eine Testklasse und schreibt dann verschiedene Funktionen.  Vor diese Funktion kann man sogenannte Annotations anfuegen.", "start": 253.12, "end": 279.12}, {"text": "  Schreibt man vor einer Funktion add before each, dann wird die folgende Funktion vor jedem Test ausgefuehrt.  Das kann man zum Beispiel verwenden, wenn man fuer mehrere Tests immer wieder Variablen mit den gleichen Werten initialisieren muss.  Schreibe ich vor eine Funktion add before all, dann wird diese Funktion einmalig vor allen Tests ausgefuehrt.", "start": 281.12, "end": 302.12}, {"text": "  Die Testfunktion selbst markiere ich mit der Annotation add test.  Innerhalb dieser Testfunktion kann ich dann zum einen Code ausfuehren, zum anderen allerdings Variablen und Rueckgabewerte ueberpruefen.  Um diese Ueberpruefung durchzufuehren, gibt es die sogenannten Asserts.  Diese sind Methoden, die etwas Bestimmtes ueberpruefen.", "start": 305.12, "end": 329.12}, {"text": "  Wenn ein Assert fail schlaegt, kann man sich eine bestimmte Nachricht ausgeben lassen und der Test schlaegt fail.  Wenn allerdings kein Assert fail schlaegt, dann ist der Test erfolgreich.  Um zum Beispiel zu ueberpruefen, ob etwas den Wahrheitswert wahr hat, kann ich die Funktion Assert true verwenden.", "start": 330.12, "end": 349.12}, {"text": "  Als ersten Parameter gebe ich dann ein Wahrheitswert an und als zweiten Parameter optional eine Nachricht.  Diese wird ausgegeben, sollte der Wahrheitswert nicht wahr sein.  Das gleiche gibt es fuer den Wahrheitswert false.  Hier lautet die Funktion Assert false und als Parameter uebergebe ich wieder ein Wahrheitswert und optional eine Nachricht.", "start": 350.12, "end": 376.12}, {"text": "  Um zu ueberpruefen, ob etwas null ist, kann ich die Funktion Assert null verwenden und anschliessend eine Referenz angeben.  Optional wieder eine Nachricht.  Genauso kann ich mit Assert null ueberpruefen, ob eine Referenz nicht null ist und optional eine Nachricht angeben, falls diese doch null ist.  Das wird oft verwendet, wenn ich ueberpruefen moechte, ob ein Objekt initialisiert wurde.", "start": 377.12, "end": 402.12}, {"text": "  Darueber hinaus kann ich mit der Methode Assert equals zwei Werte miteinander vergleichen.  Wenn diese beiden nicht gleich sind, dann schlaegt der Test fail und eine Nachricht wird ausgegeben.  Entsprechend kann ich auch ueberpruefen, ob zwei Werte nicht gleich sind mit der Funktion Assert not equals.  Ihr merkt schon, diese Asserts haben eine gewisse Aehnlichkeit mit IF-Bedingungen.", "start": 403.12, "end": 426.12}, {"text": "  Wenn diese beiden Werte gleich sind, dann passiert nichts.  Wenn diese beiden Werte allerdings nicht gleich sind, dann gebe diese Nachricht aus und lasse den Test fail schlagen.  Das Ganze koennte man auch manuell schreiben, indem man die IF-Bedingung selber schreibt und den Test anschliessend mit dem Befehl fail schlagen laesst.  Laeuft eine Testfunktion bis zum Ende durch, ist der Test erfolgreich.", "start": 427.12, "end": 453.12}, {"text": "  Neben den Asserts, die ich hier aufgelistet habe, gibt es noch viele weitere.  Ich habe hier erstmal nur die wichtigsten gezeigt.  Das bringt uns allerdings nun zu der Frage, was man ueberhaupt testen sollte.  Dazu habe ich hier einmal ein kleines Zitat rausgesucht, was man so oder so aehnlich oft im Internet findet.", "start": 454.12, "end": 485.12}, {"text": "  Ein Software-Tester kommt in eine Bar und bestellt ein Bier, bestellt Nullbiere, bestellt 2 Milliarden, 147 Millionen, 483.647 Biere, bestellt minus ein Biere,  bestellt ein Hund und bestellt ein in Anfuehrungsstrichen Bier.  Was koennen wir aus diesem Beispiel, in dem der Software-Tester offensichtlich die Bar testen moechte, nun ableiten?  Zuerst bestellt der Software-Tester ein Bier.", "start": 486.12, "end": 506.12}, {"text": "  Ein Bier koennte man interpretieren als eine ganz normale Bestellung.  Er ueberprueft hier also das Verhalten, was bei einer ganz normalen Bestellung erwartet wird.  Anschliessend bestellt er Nullbiere, diese grosse Zahl an Bieren und minus ein Bier.  Wem diese grosse Zahl nicht bekannt vorkommt, das ist der maximale Wert, der in einem Integer gespeichert werden kann.", "start": 507.12, "end": 535.12}, {"text": "  Was er hier also macht, ist mit Null und dieser grossen Zahl Randfaelle ueberpruefen, mit der minus 1 etwas ueberpruefen, was eigentlich nicht vorkommen sollte.  Anschliessend ueberprueft er noch, was fuer voellig absurde Bestellung passiert, wo zum Beispiel ein Hund bestellt wird, oder in dem Falle das Wort Bier bestellt wird.  Das Ganze laesst sich also so zusammenfassen.", "start": 536.12, "end": 558.12}, {"text": "  Zum einen moechten wir ueberpruefen, ob Variablen und Objekte immer korrekt initialisiert wurden.  Wenn das der Fall ist, schauen wir uns verschiedene Faelle an.  Das allerdings unmoeglich ist, alle Faelle zu ueberpruefen, muss man sich auf bestimmte festlegen.  Hier bietet es sich meistens an, einige Beispielfaelle zu ueberpruefen und anschliessend die Randfaelle zu ueberpruefen.", "start": 559.12, "end": 579.12}, {"text": "  Was passiert, wenn ich eine leere Liste uebergebe?  Was passiert, wenn ich zu viele Objekte uebergebe?  Was passiert, wenn eine Liste nicht initialisiert wurde?  All das sind Randfaelle, die dafuer sorgen koennen, dass euer Programm nicht korrekt funktioniert.  Um nun fuer eine bestimmte Klasse eine Testklasse in Ideas zu erstellen, koennt ihr den folgenden Schritten folgen.", "start": 580.12, "end": 602.12}, {"text": "  Zuerst einmal muesst ihr in die Klasse gehen, die getestet werden soll.  Dort macht ihr dann einen Rechtsklick auf den Klassennamen und waehlt Show Context Actions aus.  In diesem Menue waehlt ihr dann Create Test, dann auf den Klassennamen und dann auf den Klassennamen.  Und bestaetigt, dass die Testklasse im gleichen Verzeichnis erstellt werden soll.", "start": 603.12, "end": 625.12}, {"text": "  In dem Fenster, was nun kommt, wird ihr JUnit5 als Testing Library.  Wenn die JUnit5 Library nicht gefunden wurde, koennt ihr auf Fix klicken und anschliessend mit OK bestaetigen.  Gegebenenfalls koennt ihr nun weitere Einstellungen vornehmen und dann mit OK bestaetigen.  Falls JUnit noch nicht bereits zum Projekt hinzugefuegt wurde, wird der Import in der ersten Zeile rot markiert.", "start": 626.12, "end": 656.12}, {"text": "  Um JUnit hinzuzufuegen, klickt ihr das JUnit, welches im Import rot markiert ist an und drueckt anschliessend Alt und Enter gleichzeitig auf der Tastatur.  Es oeffnet sich ein Menue, in dem ihr nun Add JUnit to Class Path auswaehlen koennt.  Nun koennen in dieser Klasse Testmethoden mit den entsprechenden Annotations geschrieben werden.", "start": 657.12, "end": 679.12}, {"text": "  Das Ganze koennen wir nun nutzen, um die Funktionalitaet unserer Klasse Shop zu ueberpruefen, die wir in den vorherigen Videos geschrieben haben.  Schreibt dazu erst einmal selbst eine Testklasse und die entsprechenden Tests und anschliessend zeige ich euch, welche Tests ich geschrieben habe.", "start": 680.12, "end": 697.12}, {"text": "  Nachdem wir uns in diesem Beispiel angeguckt haben, wie wir JUnit in Ideas importieren koennen und wie wir Testklassen erstellen koennen,  schauen wir uns danach auch noch einmal das Beispiel auf dem Aufgabenblatt an und ueberlegen uns, welche Aspekte dieser Klasse wir gerne testen wuerden.", "start": 698.12, "end": 714.12}, {"text": "  Nun zeige ich allerdings zuerst einmal das Importieren von JUnit in Ideas und wie wir eine Testklasse fuer unseren Shop schreiben koennen.  Das Ganze laesst sich dann natuerlich auch auf andere Beispiele anwenden.  Beginnen wir damit, eine neue Testklasse fuer unseren Shop zu erzeugen.", "start": 715.12, "end": 738.12}, {"text": "  Dazu machen wir zuerst Rechtsklick auf unseren Klassen namens Shop, waehlen anschliessend ShowContextActions und waehlen Create Test.  Nun moechten wir die Testklasse im gleichen SourceRoot erzeugen, also waehlen wir OK.  Wir waehlen als TestingLibrary JUnit5 und sehen die Nachricht JUnitLibraryNotFound in the Module.  Das heisst, wir klicken auf Fix.", "start": 739.12, "end": 763.12}, {"text": "  Nun wird die entsprechende JUnitLibrary gesucht, wir warten also kurz.  Und klicken anschliessend auf OK.  Anschliessend koennen wir hier noch optional die Methoden auswaehlen, welche getestet werden sollen.  Ich hake hier einmal alle an.  Dann bestaetige ich mit OK.  Nun sehen wir, dass hier eine neue Klasse erzeugt wurde, welche Shop Test heisst.", "start": 763.12, "end": 790.12}, {"text": "  Allerdings erhalten wir hier noch lauter Fehlermeldungen.  Um diese Fehler zu beheben, klicken wir auf einen der rot markierten Texte, druecken Alt-Enter auf der Tastatur und waehlen AddLibraryJUnit5.4 to ClassPart.  An diesen Stellen reicht es, nur Test zu schreiben.  Dazu muss allerdings die richtige Klasse importiert werden.", "start": 790.12, "end": 825.12}, {"text": "  Das mache ich, indem ich wieder auf diesen roten Text klicke, Alt-Enter druecke und dann wird die richtige Klasse importiert, wie wir hier oben sehen.  Die Methode Lieferung moechte ich nur einmal testen, das heisst diese nehme ich weg.  Anschliessend nehme ich diesen Teil weg, den wir nun nicht mehr benoetigen.  Und nun kann ich beginnen, die Test zu schreiben.  Das ist der erste Teil.", "start": 828.12, "end": 875.12}, {"text": "  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Das ist der erste Teil.  Nun zeige ich euch, wie eine solche Testklasse beispielsweise aussehen koennte.", "start": 876.12, "end": 918.12}, {"text": "  Hier oben sehen wir die Imports, die ich waehrend meiner Programmierung der Klasse hinzugefuegt habe.  Das habe ich gemacht, wann immer mir eine JUnit Funktion rot angezeigt wurde.  Das Ganze kann ich noch einmal an einem Beispiel zeigen.  Zum Beispiel habe ich hier eine neue Testfunktion.  Diese ist immer vom TypVoid.  Ich nehme die jetzt mal Test.", "start": 919.12, "end": 943.12}, {"text": "  Und hier drin moechte ich beispielsweise eine Funktion verwenden, die ich bisher noch nicht importiert habe.  Jetzt moechte ich zum Beispiel die JUnit Methode AssertTrue verwenden.  Jetzt wird mir ein Fehler angezeigt.  Ich klicke hierauf, druecke Alt-Enter und waehle Import Static Method und anschliessend das untere von beiden.", "start": 944.12, "end": 970.12}, {"text": "  Schauen wir uns nun allerdings an, wie ich die Testklasse geschrieben habe.  Zuerst habe ich mir die wichtigsten Dinge als Attribute angelegt.  Zum einen den Shop, zum anderen eine Liste mit Produkten  und letztendlich eine Liste mit verschiedenen Kunden.  Diese habe ich dann in drei verschiedenen Funktionen initialisiert.", "start": 972.12, "end": 997.12}, {"text": "  Diese Funktion habe ich mit der Annotation BeforeEach markiert, da diese vor jedem Test ausgefuehrt werden sollen.  Hier initialisiere ich zum einen den Shop mit dem Namen Marys Shop, Besitzer Marie und Regalgroesse 5.", "start": 998.12, "end": 1019.12}, {"text": " In der naechsten Funktion erstelle ich sechs Produkte mit unterschiedlichen Namen  und fuege alle in diesem Schritt meinem Attribut Produkte hinzu, welches eine Linkliste ist, in der Produkte gespeichert sind.  In meiner dritten BeforeEach-Methode initialisiere ich dann noch die Kunden.  Jeder Kunde erhaelt dabei eine Liste mit Strings an Produkten, die er kaufen moechte.", "start": 1020.12, "end": 1036.12}, {"text": "  Anschliessend fuege ich die drei Kunden meiner Liste Kunden hinzu.  Warum habe ich die Werte nun so gewaehlt?  Mein Regal habe ich auf Groesse 5 festgelegt.  Um nun den Randfall zu testen, dass zu viele Produkte hinzugefuegt werden, habe ich eine Liste mit sechs Produkten erzeugt.", "start": 1037.12, "end": 1060.12}, {"text": "  Den ersten Kunden habe ich verwendet, um den Randfall der Lernliste zu ueberpruefen, da diese eine leere Liste uebergeben bekommt.  Und bei den zweiten beiden Kunden habe ich die Liste so initialisiert, dass das Endergebnis nur richtig ist, wenn diese auch in der richtigen Reihenfolge abgearbeitet werden, da beide das Produkt beruht wollen.", "start": 1061.12, "end": 1078.12}, {"text": "  Nachdem alles initialisiert wurde, kommen wir nun zu meinen Testfunktionen.  Ich werde diese einmal Zeile fuer Zeile durchgehen.  Falls ihr euch das Ganze allerdings laenger anschauen wollt, koennt ihr das Video gerne pausieren.  In meiner ersten Funktion ueberpruefe ich, ob der Shop richtig initialisiert wurde.", "start": 1079.12, "end": 1102.12}, {"text": "  Dabei ueberpruefe ich, ob meine Shop-Variable nicht nall ist und ob meine Warteschlange innerhalb des Shops es auch nicht nall ist.  Den Namen des Shops und des Besitzers ueberpruefe ich, wenn ich spaeter die Getter-Methoden ueberpruefe.  Hierbei faellt allerdings schon etwas auf.  Ich kann in dieser Methode nicht das Attribut Regal des Shops ueberpruefen.", "start": 1103.12, "end": 1127.12}, {"text": "  Das liegt daran, dass das Attribut auf Private gesetzt ist, ich also von aussen nicht darauf zugreifen kann und ich auch keine Getter-Methode fuer dieses Attribut habe.  Deshalb kann ich jetzt auch in den Testfunktionen nicht direkt ueberpruefen.  Schauen wir uns als naechstes die beiden Testfunktionen fuer die Getter-Methoden an.", "start": 1128.12, "end": 1145.12}, {"text": "  Hierbei ueberpruefe ich einfach, ob der String, den ich wieder bekomme, wenn ich Get Name aufrufe, der gleiche ist wie der, den ich erwarte.  Ansonsten gebe ich eine Nachricht aus, dass der String so und so lautet und eben nicht Marys Shop.  Das Gleiche mache ich fuer das Attribut Besitzer.", "start": 1146.12, "end": 1164.12}, {"text": "  Ich ueberpruefe mit Assert Equals, ob das, was ich von meiner Getter-Methode wiederbekomme, das ist, was ich hier erwarte.  Und wenn nicht, gebe ich diese Fehlermeldung aus.  Schauen wir uns als naechstes meine Testfunktionen fuer das Liefern und Kaufen an.  Diese ist auf den ersten Blick etwas unuebersichtlich, macht aber in jedem Schritt das Gleiche.", "start": 1164.12, "end": 1184.12}, {"text": "  Zuerst einmal liefer ich alle meine Produkte an den Shop.  Das bedeutet, die ersten fuenf Produkte sollten erfolgreich im Regal gelandet sein, das sechste Produkt nicht.  Ich deklariere anschliessend eine Variable P, in der ich mir das Produkt speicher, was ich durch die Funktion kaufen erhalte.  Nun mache ich in jedem Schritt das Gleiche.  Ich kaufe ein Produkt, in dem Fall zum Beispiel das Brot.", "start": 1185.12, "end": 1218.12}, {"text": "  Ich erwarte, dass das Produkt im Regal ist, deswegen ueberpruefe ich als naechstes, ob P ungleichenall ist.  Ich erwarte ausserdem, dass das Produkt, was ich wiederbekommen habe, auch den gleichen Namen hat, wie das, was ich kaufen wollte.  Das ueberpruefe ich in diesem Schritt.  Und ich erwarte, dass das Produkt, nachdem ich es gekauft habe, nicht mehr im Regal ist.", "start": 1219.12, "end": 1239.12}, {"text": "  Das ueberpruefe ich in diesem Schritt.  Hier sollte naemlich der Returnwert der Kaufen-Methode Null sein.  Das Gleiche mache ich nun mit den naechsten fuenf Produkten.  Das Produkt kaufen, ueberpruefen, dass man tatsaechlich ein Produkt erhalten hat, ueberpruefen, dass der Name des Produkts stimmt und ueberpruefen, dass das Produkt danach nicht mehr im Regal liegt.", "start": 1240.12, "end": 1269.12}, {"text": "  Das mache ich wie gesagt fuer alle fuenf Produkte, bis ich hier unten ankomme.  Und dann ueberpruefe ich an dieser Stelle, ob die Kartoffeln, also mein sechstes Produkt, eben auch nicht im Regal liegen, weil sie nicht geliefert werden konnten.  Kommen wir nun zur letzten Testfunktion.  Hier liefer ich wieder zu Beginn alle Produkte an den Shop.", "start": 1270.12, "end": 1291.12}, {"text": "  Als naechstes fuege ich alle Kunden der Warteschlange hinzu.  Dann lasse ich mir alle Kunden mittels meiner Two-String-Methode, die wir im ersten Video diese Woche geschrieben haben, ausgeben.  Anschliessend bediene ich alle drei Kunden und gebe dann auf der Konsole noch einmal alle drei Kunden aus.  Nun etereiere ich ueber alle Kunden und ueberpruefe, ob deren Rucksack die Groesse Null hat.", "start": 1292.12, "end": 1328.12}, {"text": "  Um nun einzelne Tests auszufuehren, zum Beispiel hier Initialisierung, kann ich links neben dem Namen auf diesen gruenen Pfeil druecken und anschliessend Run Initialisierung in dem Falle auswaehlen.  Wird mir hier alles gruen angezeigt, war der Test erfolgreich.  Um alle Tests auszufuehren, kann ich auch rechtsklick auf meine Shop-Testklasse machen und Run Shop-Test auswaehlen.", "start": 1333.12, "end": 1353.12}, {"text": "  Wir sehen nun, vier Tests waren erfolgreich, einer ist viel geschlagen und zwar der Testbedienung.  Hier haben wir zuerst die Konsolinausgabe, die wir uns haben ausgeben lassen, ueber das System.out.printline.  Anschliessend die JUnit Ausgabe, welche den Test zum Fehlschlagen gebracht hat.  Wir sehen naemlich, Berta hat nicht die richtige Anzahl Dinge im Rucksack.", "start": 1355.12, "end": 1376.12}, {"text": "  Wir erwarten zwei, es sind aber eigentlich Null.  Bevor ihr nun in eure Shop-Klasse geht und in der Bedienungfunktion euren Fehler sucht, solltet ihr noch einmal euren Test ueberpruefen.  Wenn wir uns naemlich unseren Test noch einmal genauer anschauen, dann sehen wir, dass wir hier fuer jeden Kunden ueberpruefen, ob seine Rucksackgroesse nach dem Einkauf Null betraegt.", "start": 1378.12, "end": 1406.12}, {"text": "  Was wir allerdings erwarten, ist, dass nur der Rucksack des ersten Kunden die Groesse Null hat.  Die anderen beiden Kunden sollten Produkte gekauft haben.  Bedenkt also stets, dass nicht nur euer eigentlicher Court-Fehler enthalten kann, sondern dass auch Fehler beim Schreiben von Tests entstehen koennen.  Diesen Fehler werde ich nun einmal korrigieren.  Nun habe ich das Ganze einmal angepasst.", "start": 1407.12, "end": 1440.12}, {"text": "  Ich erwarte nun fuer den ersten Kunden, dass er Null-Elemente im Rucksack hat, fuer den zweiten Kunden, dass er zwei Elemente im Rucksack hat und fuer den dritten Kunden, dass er nur ein Elemente im Rucksack hat.  Wir fuehren noch einmal alle Tests aus und alle Tests waren erfolgreich.  Ich hoffe, ich konnte euch hiermit einen kleinen Einblick in verschiedene Testmethoden geben.", "start": 1440.12, "end": 1466.12}, {"text": "  Mithilf von JUnitTests ist es relativ einfach moeglich, auch euer Code fuer die Hausaufgaben zu pruefen.  Sicher werdet ihr hier nicht alle Faelle abdecken koennen.  Allerdings koennen die Tests einen guten Hinweis darauf geben, ob euer Code funktioniert oder nicht.  Bis auf in der Testmethoden ist es moeglich, dass die Tests in der Testmethoden nicht mehr verabschiedet werden.", "start": 1467.12, "end": 1494.12}, {"text": "  Bis auf in der Testhausaufgabe koennt ihr die Tests auch untereinander austauschen und beliebig erweitern.  Mit jedem Fall, den ihr testet, ist es dadurch wahrscheinlicher, dass auch die Tests fuer die Hausaufgabenabgabe erfolgreich sind.  Nun schauen wir uns noch einmal in Ruhe die Klasse auf dem Aufgabenblatt an.  Diese traegt den Titel String genommen.", "start": 1495.12, "end": 1523.12}, {"text": "  Als privates Attribut besitzt sie lediglich den String S. Dieser wird als Lehrer String initialisiert.  Nun besitzt sie die verschiedensten Methoden.  Zum einen haben wir Getter-Methoden fuer die Laenge des Strings und eine Methode, die mir den String zurueckgibt.  Mit der Methode Nucleotid Add kann ich mir die Position E aus meinem String S zurueckgeben lassen.", "start": 1524.12, "end": 1549.12}, {"text": "  Allerdings nur, sofern diese existiert. Ansonsten bekomme ich eine Run-Time-Exception.  Mit der Methode AddNucleotid kann ich ein Buchstaben zu meinem String hinzufuegen, allerdings nur die Grossbuchstaben A, C, G und T.  Diese entsprechen den Aminosaeuren in unserer DNA.  Uebergebe ich einen Charakter, der nicht A, C, G oder T ist, bekomme ich auch hier eine Run-Time-Exception.", "start": 1550.12, "end": 1579.12}, {"text": "  Am Ende werden noch die Methoden Equals und HashCode ueberschrieben.  Die Methode Equals vergleicht hier, ob die Strings zweier Stringen genommen Objekte gleich sind.  Die Methode HashCode gibt mir den HashCode unseres Strings zurueck.  Nun ueberlegt doch einmal, welche Aspekte der Klasse ihr testen wuerdet.  Nun werde ich euch einmal zeigen, welche Aspekte der Klasse ich testen wuerde.", "start": 1580.12, "end": 1626.12}, {"text": "  Hierbei gehe ich auch wieder nach dem Prinzip vor, die Initialisierung zu testen, Beispielwerte zu testen und Randfaelle zu testen.  Beginn werde ich mit der Initialisierung.  Hier wuerde ich zum Beispiel ein neues Stringen-Genome-Objekt erstellen und anschliessend mittels der beiden Getter-Methoden, die ich hier markiert habe, testen, ob der String S richtig initialisiert ist.", "start": 1627.12, "end": 1645.12}, {"text": "  Ich erwarte zum Beispiel, dass der String S nicht null ist.  Ich erwarte auch, dass die Laenge des Strings null ist.  Ist das der Fall, wurde mein Objekt bei der Erstellung richtig initialisiert.  Da unser String S ein privates Attribut ist, muessen wir auch darauf achten, dass wir bei den Tests immer nur ueber die Length und die Two-String-Methode darauf zugreifen koennen.", "start": 1646.12, "end": 1670.12}, {"text": "  Schauen wir uns nun die naechste Methode an.  Die Methode AddNucleotid erhaelt einen Character, ueberprueft dann, ob dieser gleich AC, G oder T ist.  Wenn Ja, wird dieser Character an S angefuegt, wenn nicht, wird eine Run-Time-Exception geborfen.  Ich wuerde hier die folgenden zwei Sachen testen.  Zum einen das Verhalten fuer die Parameter AC, G und T, zum anderen das Verhalten fuer andere Parameter.", "start": 1671.12, "end": 1704.12}, {"text": "  Dazu wuerde ich mir wieder ein String Genome Objekt erstellen und wuerde nacheinander Buchstaben ueber die AddNucleotid-Methode hinzufuegen.  Hierbei ist es moeglich, beispielsweise erwartete Parameter, also AC, G und T, und unerwartete Parameter im Wechsel hinzuzufuegen.", "start": 1705.12, "end": 1722.12}, {"text": "  Anschliessend kann ich mit der Two-String-Methode ueberpruefen, ob der String S, der daraus resultiert, genau der String ist, den ich erwarte.  Ich erwarte hier, dass nur die Buchstaben hinzugefuegt wurden, die entweder AC, G oder T sind, und ich erwarte, dass andere Buchstaben nicht hinzugefuegt wurden.  Hierbei muss ich beachten, dass ich Run-Time-Exceptions richtig abfange.", "start": 1722.12, "end": 1743.12}, {"text": "  Nun schauen wir uns die Nucleotid Add-Methode an.  Diese gibt mir fuer eine Position I den Character zurueck, der an der Stelle I in dem String S steht.  Falls I hier kleiner als die Laenge des Strings ist, dann wird der Character zurueckgegeben, wenn nicht, wird eine Run-Time-Exception geworfen.  Auch hier wuerde ich wieder verschiedene Parameter testen.", "start": 1744.12, "end": 1769.12}, {"text": "  Ein normales Verhalten erwarte ich fuer I, welches zwischen 0 und der Laenge des Strings liegt.  Fuer I groesser als die Laenge bzw. groesser gleich der Laenge und fuer I kleiner als 0 erwarte ich, dass eine Run-Time-Exception geworfen wird.  Wie wir hier schon sehen koennen, waere das in diesem Beispiel nicht der Fall.", "start": 1770.12, "end": 1793.12}, {"text": "  Uebergebe ich der Methode zum Beispiel I gleich minus 1, dann ist diese Iff-Bedingung hier trotzdem wahr und ich bekomme den Character an der Stelle minus 1.  Diese verschiedenen Werte fuer den Parameter I wuerde ich dann zum einen fuer ein String-Genomen-Objekt testen, welches noch ein Lern-String hat und fuer ein String-Genomen-Objekt testen, welches schon ein String gewisser Laenge hat.", "start": 1794.12, "end": 1820.12}, {"text": "  Nun schauen wir uns die Iquiz-Methode an. Die Iquiz-Methode bekommt ein Objekt uebergeben und soll dann ein Boolean zurueckgeben, ob dieses Objekt gleich ist mit dem Objekt, in dem wir uns gerade befinden.  Auch hier koennen wir wieder verschiedene Randfaelle testen.", "start": 1821.12, "end": 1832.12}, {"text": "Was passiert, wenn wir der Methode Null uebergeben?  Was passiert, wenn wir der Methode ein anderes Objekt als ein String-Genomen-Objekt uebergeben?  Diese Faelle sollten in jedem Fall Fals ausgeben und auch nicht unbedingt dazu fuehren, dass das Programm abstuerzt.  Anschliessend kann man noch ein paar Beispielfaelle testen.", "start": 1832.12, "end": 1852.12}, {"text": "  Funktioniert das Ganze fuer leere Strings, bekomme ich die richtige Ausgabe fuer gleiche Strings und bekomme ich auch die richtige Ausgabe fuer unterschiedliche Strings.  Als letztes koennen wir noch die Methode Hashcode ueberpruefen.  Da hier kein Parameter uebergeben wird, koennen wir das hoechstens fuer verschiedene Werte von S testen.", "start": 1854.12, "end": 1868.12}, {"text": "  Der eine Randfall, der hier besteht, ist, dass S ein leerer String ist.  Weiterhin koennen wir das Ganze noch fuer ein beliebigen String testen.  Der Hashcode, den wir hier erwarten, ist immer gleich zu dem Hashcode des jeweiligen Strings in dem Objekt.  Das waren alle wichtigen Testfaelle, die mir eingefallen sind.", "start": 1869.12, "end": 1889.12}, {"text": "  Faellt euch noch ein weiterer wichtiger Testfall ein? Dann schreibt diesen gerne in das Forum dieser Woche.", "start": null, "end": 1889.12}]}]