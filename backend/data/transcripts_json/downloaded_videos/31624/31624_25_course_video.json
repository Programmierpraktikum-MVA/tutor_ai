[{"lecture": "31624_25_course_video", "Timestamps": [{"text": "  In diesem Video beschaeftigen wir uns abschliessend mit der Hausaufgabe des Hausaufgamblattes.  In der ersten Aufgabe soll die Implementierung der Tiefensuche vervollstaendigt werden.  Hier erhaltet ihr als Eingabe einen Grafen und fuer die Rekursive Implementierung den  aktuellen Knoten, dem ihr euch gerade befindet.", "start": 0.0, "end": 26.52}, {"text": "  Die Funktionen geben zwar nichts zurueck, sollten aber die Preorder und die Postorder-Liste  fuer die gesamte Tiefensuche und die Kante zum Elternknoten und die Distanz zum Startknoten  fuer jeden Knoten setzen.  Die Distanz zum Startknoten entspricht hier der Anzahl der Knoten von dem aktuellen Knoten  zum Startknoten auf dem Fahrt, auf dem der Knoten von der Tiefensuche entdeckt wurde.", "start": 26.52, "end": 52.32}, {"text": "  Der Elternknoten eines Knoten entspricht dem Knoten, von dem ich diesen Knoten erreicht  habe.", "start": 52.32, "end": 70.92}, {"text": " Der Ansatz hierbei ist, sich erst einmal in einer Handsimulation klarzumachen, wann welcher  Schritt ausgefuehrt wird, also wann fuege ich ein Knoten in die Preorder-Liste hinzu, wann  fuege ich ein Knoten in die Postorder-Liste hinzu und zu welchem Zeitpunkt kann ich den  Elternknoten und die Distanz zum Startknoten setzen.", "start": 70.92, "end": 76.4}, {"text": "  Hat man sich diese vier Dinge klargemacht, kann man die bestehenden Funktionen ergaenzen.  In der zweiten Aufgabe sollt ihr innerhalb dieses Grafen Wege zu bestimmten Knoten finden.", "start": 76.4, "end": 98.0}, {"text": " Als Eingabe haltet ihr den Zielknoten, der erreicht werden soll und die Ausgabe der  Funktion soll eine Knotenliste sein, in welcher alle Knoten auf dem Fahrt vom Startknoten  des Grafen zum Zielknoten enthalten sind, allerdings in umgekehrter Reihenfolge.  Das erste Element der Liste ist also der Zielknoten und das letzte Element der Startknoten.", "start": 98.0, "end": 110.03999999999999}, {"text": "  Ueberlegt euch hierzu einmal, welche Informationen ihr aus der Tiefensuche verwenden koennt,  nachdem diese erfolgreich durchgelaufen ist.  Hier habt ihr naemlich bereits Informationen darueber, wie die Knoten miteinander verknuepft  sind.  In der dritten Aufgabe soll dann ein sogenanntes Mace-Grid erstellt werden.", "start": 110.04, "end": 128.64000000000001}, {"text": "  Ein Mace-Grid ist ein Graf, in dem alle Knoten in einem quadratischen Netz angeordnet sind.  Das heisst, ein Knoten, der nicht gerade ein Randknoten ist, ist mit dem Knoten ueber  sich, unter sich, links von sich und rechts von sich verbunden.  Ihr haltet fuer diese Funktion zwar keine Eingabeparameter, koennt hier aber die Attribute  der Klasse nutzen.", "start": 128.64000000000001, "end": 150.96}, {"text": "  Zum Erstaendnisgrafen bietet es sich an, ein solches Mace-Grid erst einmal aufzumalen  und dann zu ueberlegen, wie die Kanten fuer jeden Knoten gesetzt werden muessen.  Besonders zu beachten sind hier die Sonderfaelle am Rand.  In der vierten Aufgabe soll eine sogenannte randomisierte Tiefensuche implementiert werden.", "start": 150.96, "end": 175.56}, {"text": " Hier haltet ihr die gleiche Eingabe, wie auch schon fuer die Tiefensuche in Aufgabe  1 und soll auch wieder eine Pre-Order- und Post-Order-Liste setzen, sowie den Elternknoten  und die Distanz zum Startknoten fuer jeden Knoten.  Auch das Vorgehen ist hier das gleiche, wie in der Tiefensuche aus Aufgabe 1.", "start": 175.56, "end": 190.96}, {"text": " Der Unterschied hierbei ist, dass wir die Nachbarknoten jetzt nicht immer in der gleichen  Reihenfolge, sondern in zufaelliger Reihenfolge besuchen wollen.  Schaut euch dazu einmal an, welche vordiffinierten Funktionen Listen haben, um eine Randomisierung  auf ihn durchzufuehren.  Ueberlegt dann, an welcher Stelle ihr die Randomisierung durchfuehren muesst.", "start": 191.96, "end": 209.72}, {"text": "  Alle weiteren Schritte entsprechen wie gesagt der Tiefensuche aus Aufgabe 1.  In Aufgabe 5 sollen nun Veraenderungen am Grafen vorgenommen werden.  Hierzu sollte die Funktion Hes-Edge und Add-Edge implementieren.  Beide Funktionen erhalten hierzu als Eingabe zwei Knoten.", "start": 209.72, "end": 231.2}, {"text": " Hes-Edge gibt dann True zurueck, wenn die Kante bereits im Grafen ist und false zurueck,  wenn die Kante noch nicht im Grafen ist.  Add-Edge fuegt diese Kante dem Grafen hinzu.  Schaut dazu einmal, wie Kanten in diesem Grafen gespeichert werden.  In der letzten Aufgabe der Hausaufgabe soll ein Labelrint programmiert werden.  Dazu sollte die Funktion BuildMaze und FindWay programmieren.", "start": 231.2, "end": 257.16}, {"text": "  Die Funktion BuildMaze erhaelt keine direkte Eingabe und soll innerhalb eines Maze Grids  ein Labelrint erzeugen.  Um zufaellige Pfade in diesem Maze Grid zu erzeugen, sollte die Tiefensuche anwenden.  Damit das Labelrint nicht immer gleich aussieht, soll hier die randomisierte Tiefensuche verwendet werden.  Die Pfade, die bei der Tiefensuche erzeugt werden, sind dann die Kanten des Labelrins.", "start": 257.16, "end": 281.76}, {"text": "  Nachdem dieses Labelrint erzeugt wurde, soll mit der Funktion FindWay ein Weg zwischen  zwei Knoten gefunden werden.  Hierbei erhaltet ihr als Eingabe wieder zwei Knoten im Grafen und soll den Weg zwischen  diesen zwei Knoten als Knotenliste zurueckgeben.  Auch hier koennt ihr wieder bereits bekannte Informationen aus der Tiefensuche verwenden.", "start": 281.76, "end": 297.56}]}]