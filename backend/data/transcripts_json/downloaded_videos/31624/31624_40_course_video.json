[{"lecture": "31624_40_course_video", "Timestamps": [{"text": "  Hi, so in this video I'm going to talk about a more advanced way of dealing with collections  of objects which you will use repeatedly throughout this course and that would be iterators.  So let me open an idea.  I've already created the main function stub for this task.  Let's talk about for loops.  So let's say we have a very simple array of strings.  Let's just write that down.", "start": 0.0, "end": 52.120000000000005}, {"text": "  So items equals 1, 2, 3, 4.  Let me also have 5 and 6.  Alright, so how would you iterate through this and print its elements?  Well you know how to write a simple for loop.  It would look like this.  For int i equals 0, i less than equal to 3, i less than items.lamp, i plus equals 1.  And then we print that.  Let's build and run that function.  Yep, there you have it.  1, 2, 3, 4, 5, 6.", "start": 52.120000000000005, "end": 105.44}, {"text": "  Good, well but you already know how to write a for loop.  Now let's write something else instead of the array here.  So what if we had not an array but a more advanced collection like a set.  So that would look like the following.  So we have a set of screen.  Let's also call that items.  Let's get rid of the old array.  And this should be set.  New set.", "start": 105.44, "end": 158.48}, {"text": "  So this will not work just like that because set is actually an abstract class.  You need to use one of the more derived or subclass versions of set.  So hash set is one such example.  We'll choose that.  Now we add items to it.  So that would be literally items.add.  One.  All right.  So let's build this.", "start": 158.48, "end": 212.68}, {"text": " Of course that did not work because we changed the type of the thing that we are iterating  over.  So we had a normal array at first but now we have a set of swing.  So the first thing that doesn't work is items.add.  Cannot resolve that.  It's just rename reference.  Now that's not going to help us.  So how do we get the number of elements in a set?  Well let's look at what items.jashes this.", "start": 212.68, "end": 240.95999999999998}, {"text": "  Okay the first hit is size.  And that sounds like it should do what we want.  What else?  There is this being a problem.  So of course square brackets don't work when you're using something like a set.  Square brackets work with arrays, not sets.  So what can we use instead?  Maybe there is something like get item or item.  No.  Interesting.  Yeah.  Of course there isn't.", "start": 240.95999999999998, "end": 287.71999999999997}, {"text": " And you know why?  That's because a set is not an ordered collection.  An array is an ordered collection.  In a set there is no guarantee as to what order of items that you insert into it will  be.  So it's not like these strings are stored and then accessed in alphabetical order.  We are also not stored or accessed in the same order in which we added them.  In fact that order is undefined.", "start": 287.72, "end": 331.48}, {"text": "  So we cannot use these for loop semantics because there is no index i for any of those  items.  We need to use something else.  And that's where iterators come in.  So iterators would look something like this.  First we would create an iterator object for this items collection.  That would look like this.  Iterator.  Let's just call it iter equals items.iterator.  That's it.", "start": 331.48, "end": 375.36}, {"text": "  So a collection like this comes with a method called iterator which produces that collection  to iterator.  Now this is complaining about something.  What is that?  Raw use of parameterized class iterator.  Of course.  So we need to tell this line that actually we want an iterator that returns strings at  every step of the way.  Because what we are storing are strings.", "start": 375.36, "end": 400.36}, {"text": "  And now let's use this iterator.  So what would that look like?  Let's use a while loop for now.  So while.iter.  And of course the id helpfully suggests something.  iter.hasNext.  If the iterator says that there is something next get to be accessed then yes we will do  one more tick of the while loop.  And inside that as long as there is something to access we can write system.out.", "start": 400.36, "end": 454.56}, {"text": "rintline  iter.next.  And that should return the next item that's available.  So what is this next thing in iterators?  Well what you need to understand is that iterators work like cursors.  When I move this blinking cursor around with my keyboard that's kind of what an iterator  is doing.  So let's say you have a collection full of letters like this.", "start": 454.56, "end": 499.56}, {"text": "  When I create an iterator it starts off at the beginning of this collection.  So just before the a when I invoke iter.hasNext it will return true because there is an a to  the right side of it.  When I call iter.next that method will return the letter a and move the cursor one step  to the right.", "start": 499.56, "end": 530.6}, {"text": " Of course if I keep calling it again and again it's going to go all the way to the  right until it hits the end.  And at this point iter.hasNext will return pop and the looping will add.  And of course I should also say that this specific example makes a lot of sense for  an ordered collection like this string.", "start": 530.6, "end": 561.88}, {"text": " But the whole point of using iterators in most cases is that it also makes sense when  there is no order like for a set.  So let's actually try this.  Let's put the complaint here.  That's not a complaint.  That's bid and run.  Yeah and that's the output.  So as you see we got all the numbers printed out but not in the same order in which we  added them.", "start": 561.88, "end": 593.24}, {"text": "  And yeah that makes sense because the set is an unordered collection.  Okay so one really good thing about using iterators is that they are they provide this  general interface for dealing with collections.", "start": 593.24, "end": 628.0799999999999}, {"text": " So if I were to change this from a set to an array list and of course a real list as  you might know from experience are ordered we can expect there to be a different output  but the code will still build compile and work as we expect.  And there it is.  This is in the right order.  And that is how we use iterators.", "start": 628.08, "end": 648.2800000000001}, {"text": "  Now you can also use for loops or so-called enhanced for loops and let's use the ID suggestion  for that.  While loop with visible with enhanced for and that looks like this.  The enhanced for loop is something that uses the for loop semantics but without the internal  condition specifications.", "start": 648.2800000000001, "end": 691.52}, {"text": " So this construct behind the scenes creates an iterator for the collection items that  you pass and the type of return value you want to extract which is string.  This is a much easier way of dealing with collections.  And that's all about iterators.  Now we will move on to iterables.", "start": 691.52, "end": 721.5200000000001}, {"text": " So now let's talk about how we can write our own classes with their own iterators which  implement the iterable functionality.  So let's actually do a small exercise where we implement a specific data structure that  I'm going to call an entry list.  So entry list would look something like this.  It would be a linked list where every item that is linked contains one string and that's  it.", "start": 721.5200000000001, "end": 749.44}, {"text": "  It's a very simple data structure.  It's a container.  It's sequential and you can iterate over it.  So for example the very first item here is a string that says one and then the next item  is another string and then the next item is another and so forth.  And all these items they point in one direction.  This item points to the next item.  There's a next feature for every item.", "start": 749.44, "end": 784.12}, {"text": "  So let's just first write down how we would use it and then we will implement that.  So here's an example.  Entry list.  Let's call that EL equals new entry list.  And then we would add items to it like this.  And we would use the fancy for loop semantics for that.  So what we want to print at every step is a string name sourced from the collection  in EL which would be printed the standard base.", "start": 784.12, "end": 850.8000000000001}, {"text": "  Yep, that's it.  All right.  So now it's time to implement entry list.  So entry list class entry list implement iterable.  Off type string.  So even though the entry list will contain items of a special class entry which we will  define the iterable or the iterator that we will implement will return string.  Because that is the only thing we care about in the return output.", "start": 850.8000000000001, "end": 906.48}, {"text": "  So let's define the entry class.  That should be private because we only use it within an entry list.  Class entry.  And this would have something of a recursive definition.  But first we will write the type of the payload which is a string name.  And the payload is now done and now we point to the next entry.  So that should be entry next.  That's it.", "start": 906.48, "end": 944.1600000000001}, {"text": "  Very simple recursive definition of the class.  So we also need to specify a field for the entry list itself.  Because we will assemble the entry list item by item.  And because each item points to the next item, the only way to get anywhere in this list  by just traversing it is by starting from the first item.  So we need to have a field for the first item.  That should be private entry.", "start": 944.16, "end": 982.56}, {"text": "  Let's call that first.  And now the last thing we need to define for the class should be a public method add  which we already invoked in May.  That takes string name.  So the first thing to do is of course just create a new entry for that.  So entry newest equals new entry.  And newest.name should be the name.", "start": 986.0, "end": 1037.76}, {"text": " Now how do we actually insert this entry into the entry list?  Let's say we already have a list that looks like this.  1, 2.  What we need to do is loop over this list somehow.  So we have access to first which in this case will contain 1.  So we will access this entry first and then we will grab its next field which will provide  us with this.", "start": 1037.76, "end": 1075.12}, {"text": "  And then we will grab its next field which will provide us with this.  If this is null what we can do is we can just set this entry's next field as our newest entry  which could be 3 as a result of calling add.  And that's what we will do now.  So file first not equals null.  Of course we have to check that the list is not empty first.", "start": 1075.12, "end": 1115.6799999999998}, {"text": "  We create a temporary entry which is what we hold currently while looping through.  So entry temp equals first.  And while temp.next is not equals null.  Meaning we stop at the very last non-null entry.  Temp equals temp.next.  So this is just the part of the code that allows us to travel along this list.  And then this loop will terminate at some point which is the last entry.", "start": 1115.6799999999998, "end": 1162.0}, {"text": "  And there we will attach our newest entry as temp.next equals newest.  And that's it.  And this of course should have been if not a loop.  And if the list is actually empty then the solution is simple.  The first element is then the newest one.  And now we have an add function ready.  Let's get rid of this unnecessary line now.  So what is the compiler complaining about?  Yes.", "start": 1164.64, "end": 1222.56}, {"text": "  Invalid method declaration return type required public void add that fixes a lot.  And now we fix this.  So this says that either declare entry list as abstract or implement the abstract method  iterator in iterable.  And that is exactly what implementing iterable asks us to do that we must implement iterative.  And we will ask the IDE to create a skeleton for us just for the iterator.", "start": 1222.56, "end": 1251.6000000000001}, {"text": "  And there it is.  I will put this at the bottom of the class.  Okay.  Let's start writing our first iterator.  So we need to implement our own custom iteration logic.  Just return anything here.  We can't just return null here.  Null is like the default output that idea created for us, but it does not help us at all.  So what we will do is we will create our own custom iterator class.", "start": 1253.2, "end": 1306.24}, {"text": "  And we will return an instance of that when entry list dot iterator is called.  So return new let's call this entry list iterator.  So now let's actually write down that class.  That should be public.  Implement iterator of type string.  Now if you remember the cursor metaphor, so we had a string like this.", "start": 1306.24, "end": 1366.3999999999999}, {"text": "  And that string is not necessarily this string, but merely a collection with a lot of items inside.  And the cursor would start here.  And calling next would move the cursor one step forward.  We can implement the same thing here.  So let's just have the current entry which is going to act like the cursor.  So private entry current.", "start": 1367.2800000000002, "end": 1403.76}, {"text": "  And that should of course be initialized as the first one, which is this here.  That's similar to the cursor spawning to the very left side of that string.  Now here's a complaint and by collecting this line, the IDE will implement all the required  methods for us as skeleton functions.  So that's it.  We just have to fill in these two functions and we will have our own iterables.", "start": 1407.68, "end": 1448.72}, {"text": "  So the first and the simplest thing to implement is has next.  That is easy.  So what we need to write is current.next not equal null.  That should do it.  What's the complaint here?  Not a statement.  Return current.max null equals null.  Now we do the actual next thing.  So that's also easy.", "start": 1450.3999999999999, "end": 1502.64}, {"text": " What's the result of a next?  It moves the current cursor to the right and it returns the value that the cursor just jumped.  So string value equal current.name  and the current is now changed to be its next item, current.name.  And then we return the value that should do it.  Let us now check what this complaint is about.  In a class entry, maybe static.", "start": 1504.0, "end": 1542.72}, {"text": "  I don't think that's necessary to deal with.  Okay, let's build and run.  Expected semicolon.  All right, so it looks like our linked list might be working.  1, 2, 3, 4, 5.  Interesting.  So it did not print 6.  Why is that?  Is our follow up all right?  Yeah, our follow up looks all right.  Hmm.", "start": 1543.92, "end": 1608.64}, {"text": " When your iterator terminates prematurely  and your loop is all right,  then the next place to look for a problem should be your next or have next functions.  So I think that next looks fine.  Has next might lead to an off by one error.  And here's the problem.  What's happening here is that we're checking if current.next not equals null.", "start": 1609.44, "end": 1637.68}, {"text": "  That makes sense verbally because has next kind of sounds like is the next value null.  And current.next also sounds like it's checking for the next value.  But next has a unique interpretation here.  Next mean the current value that is stored at this cursor position  before you jump to the next position.  Meaning that we should not have been checking current.next.", "start": 1638.64, "end": 1673.76}, {"text": "  We should have been checking current because that is the current cursor position.  And now we can run again.  And now all of the values are printed correctly.  So short lesson just be a bit careful about how you implement has next.  It is a source of off by one errors.  And now you know how to write your own iterable classes with their own iterators.", "start": 1676.8, "end": 1710.32}]}]