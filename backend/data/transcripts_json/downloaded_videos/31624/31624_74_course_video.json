[{"lecture": "31624_74_course_video", "Timestamps": [{"text": "  Der A-Stern-Algorithmus ist ein heuristischer Algorithmus, bei dem die Heuristik als eine konkrete Funktion gegeben ist.  Diese Funktion gibt an, wie weit es von einer Teilloesung noch mindestens bis zu einer vollstaendigen Loesung ist.  Beim Knobelspiel sind dies die Spielzuege, die von einer Spielstellung noch mindestens zur Loesung benoetigt werden.", "start": 0.0, "end": 32.0}, {"text": "  In der Navigation ist es die Wegstrecke, die von einem Punkt zum Zielort noch mindestens zurueckgelegt werden muss.  Damit die Heuristik dem A-Stern-Algorithmus hilfreich ist, sollte die Schaetzung nicht zu grob sein, also den tatsaechlichen Wert nicht zu stark unterschaetzen.  In dem Navigationsbeispiel ist zum Beispiel die Luftlinien-Distanz meistens eine gute Schaetzung.", "start": 32.0, "end": 62.0}, {"text": "  Als Beispiel, um den A-Stern-Algorithmus zu erlaeutern, nehmen wir die Aufgabe, den kuerzesten Weg in einen gewichteten Grafen von einem Startknoten S zu einem konkreten Zielknoten T zu finden.  Hier lassen sich viele Aspekte besonders gut illustrieren.  Beginnen wir zunaechst mit einem Ansatz, den wir schon kennen, dem Dyxtralgorithmus.", "start": 62.0, "end": 76.0}, {"text": "  Er findet die kuerzesten Wege von einem Startknoten S zu allen anderen Knoten.  Also irgendwann auch zu unserem Zielknoten T. Allerdings ist die Suche nicht gerade zielgerichtet.  Schauen wir es uns an. Hier benutzen wir ein Beispiel, wo die Flaeche kacheln unterteilt ist und es geht darum, den kuerzesten Weg von der mit S bezeichneten Kachel zu der mit T bezeichneten Kachel zu finden.", "start": 76.0, "end": 104.0}, {"text": "  Den Grafen, den wir der Suche zugunden legen, ist hier gezeigt.  Dyxtral geht von dem Startknoten S aus und besucht die Knoten in der Reihenfolge ihrer Distanz von dem Startknoten.  Zunaechst werden also die Knoten mit dem Abstand 1 besucht.  Danach geben alle Knoten mit dem Abstand Wurzel 2 an die Reihe.", "start": 104.0, "end": 132.0}, {"text": "  Wenn wir hier die euklideische Distanz als Gewicht nehmen, danach die Knoten mit dem Abstand 2.  Dann die Knoten mit dem Abstand Wurzel 2 plus 1.  Dann die Knoten mit dem Abstand 2 mal Wurzel 2 und so weiter.  Das heisst, in diesem Beispiel wuerden alle anderen Knoten zuerst gefunden werden und erst ganz am Ende unser Zielknoten T.", "start": 132.0, "end": 158.0}, {"text": "  Wenn es uns aber nur um den kuerzesten Weg zu T geht, ist diese Suche unguenstig.  Wir haetten lieber eine gezielte Suche, die von dem Startknoten genau in die richtige Richtung startet und die Knoten nur auf diesem Weg erexploriert, bis der Algorithmus bei dem Zielknoten angelangt.  Hierfuer haetten wir gerne eine Horistik, die dem Algorithmus diesen Weg weist.", "start": 158.0, "end": 184.0}, {"text": "  Dazu schauen wir uns zuerst eine direkte Umsetzung dieses idealen Algorithmus an.  Das ist der greedy best first Algorithmus, der folgendermassen funktioniert.  Er beginnt beim Startknoten S und iteriert dann den folgenden Schritt.  Es wird immer von allen erreichbaren Knoten derjenige ausgewaehlt, dessen Abstand zum Ziel am kleinsten ist.", "start": 184.0, "end": 211.0}, {"text": "  Schauen wir uns das wieder in so einem Gitaugrafen an, damit wir hier keine Abstaende mit Kommazahlen haben.  Wird das Gewicht hier folgendermassen definiert, der Abstand zwischen zwei waagerecht benachbarten Kacheln ist zwei und zwischen zwei diagonal benachbarten Kacheln ist drei.  Hier ist wieder unsere Aufgabe.", "start": 211.0, "end": 238.0}, {"text": "  Und hier eingetragen ist die Horistik, also immer die Distanz als kuerzester Weg von jeder Kachel zu den Zielknoten.  Von dieser Kachel zum Beispiel ist der kuerzeste Weg ein Schritt diagonal und einer waagerecht, also drei plus zwei, gleich fuenf.  Und auf diese Weise sind alle Werte der Horistik fuer alle Kacheln berechnet und eingetragen.  Dann geht die Suche, also wie folgt.", "start": 238.0, "end": 266.0}, {"text": "  Von dem Startknoten wird der Knoten besucht mit dem kleinsten Horistikwert, also dem kleinsten Abstand zum Ziel.  Das ist hier die zwoelf, dann die neun, sechs, drei, null und so weiter.  In diesem Fall wird also der ideale, direkte Weg von Start zum Ziel realisiert.", "start": 266.0, "end": 291.0}, {"text": " Aber wie sieht es aus, wenn dieser direkte Weg blockiert ist?  Zunaechst geht die Suche auf geraden Weg Richtung Ziel bis zur Blockade.  Hier wird als naechster Knoten einer ausgewaehlt, der den kleinsten Horistikwert hat, also den kleinsten Abstand zum Ziel.  Das ist hier das Feld mit der fuenf und dann das Feld mit der vier.  Hier gibt es aber keinen Weg, der direkt zum Ziel fuehrt.", "start": 291.0, "end": 311.0}, {"text": "  Nun geht es weiter nach dem Verfahren.  Als naechstem kleinsten erreichbaren Horistikwert haben wir hier das Feld mit der sechs, was zuerst von diesem Knoten ausgefunden wurde.  Dann gibt es hier das Feld mit dem Wert sieben, was von der sechs aus gesehen wurde.  Und dann gibt es die Felder mit der acht.", "start": 311.0, "end": 338.0}, {"text": "  Als naechstes wird dann zur neun gesucht und hier wird jetzt endlich der Weg um die Blockade herumgefunden.  Das heisst, hier geht es dann nun weiter mit wieder mit Horistikwert sechs und dann vier, zwei, null zum Ziel.", "start": 338.0, "end": 363.0}, {"text": "  Den Weg, den dieser Algorithmus hier also findet, ist jetzt nicht der optimale Weg, weil hier ein Umweg gemacht wird, der durch die Blockade und die irrefuehrende Horistik verursacht wurde.  Das ist offensichtlich keine schoene Situation.  Man kann sich auch vorstellen, dass bei komplexeren Grafen dieser Umweg, der durch den Algorithmus gemacht wird, noch deutlich groesser ausfallen kann.", "start": 363.0, "end": 391.0}, {"text": "  Wir wuenschen also einen besseren Algorithmus, der nicht durch Blockaden so in die irre gefuehrt wird, dass der Weg, der am Ende als kuerzester Weg ausgegeben wird, gar nicht der kuerzester Weg ist.  Und genau dies leistet der Ersterne Algorithmus.  Und das erreicht er dadurch, dass er die beiden Aspekte von Dijkstra und dem Best First Algorithmus kombiniert.", "start": 391.0, "end": 423.0}, {"text": "  Er benutzt sowohl die Vorwaertskosten, also die Schaetzung der Distanz von einem Knoten zum Ziel mit der Horistik und die Rueckwaertskosten, die die Strecke vom Start zu dem speziellen Knoten sind.  Genauer gesagt funktioniert der Ersterne Algorithmus folgernmassen.  Er benutzt eine Funktion F. Die Funktion F ist fuer alle Knoten definiert und ist die Summe aus den Rueckwaertskosten und Vorwaertskosten.", "start": 424.0, "end": 454.0}, {"text": "  Die Rueckwaertskosten und die Distanz vom Startknoten zum Knoten V, also die bei Dijkstra und die Vorwaertskosten sind deutlich horistik gegeben, wie bei dem Best First Algorithmus.  Dann besucht dieser Algorithmus immer denjenigen der erreichbaren Knoten, der den kleinsten F Wert hat.", "start": 455.0, "end": 475.0}, {"text": "  Das bedeutet also, er waehlt immer den Knoten aus, fuer den die geschaetzte Laenge des Weges vom Start zum Ziel ueber diesen Knoten V am geringsten ist.  Sehen wir uns die Unterschiede in der Kanffenauswahl zwischen diesen drei Algorithmen, Dijkstra, Best First und A Stern in einem kleinen Beispiel an.", "start": 475.0, "end": 494.0}, {"text": "  Hier ist ein kleiner Graf, wo der Weg von oben von dem Knoten S nach unten zu dem Knoten T gesucht ist.  Und da gibt es drei Knoten, die dazwischen liegen.  Der Knoten W ist insofern attraktiv, weil er am naechsten an S dran ist.  Der Knoten U ist insofern attraktiv, weil er schon am naechsten an dem Ziel dran ist.  Und der Knoten V bildet bezueglich beide Aspekte des Mittel.", "start": 494.0, "end": 527.0}, {"text": "  Heuristik, die Distanz zum Zielknoten, schaetzt es hierfuer die drei Knoten angegeben.  Der Knoten U ist in der Luftlinie relativ nah an T, deswegen hatte er den Wert 1.  V ist etwas weiter weg, deswegen hat er den Wert 2 angegeben.  Und W ist noch weiter weg, hat er den Wert 4 bekommen.  Sehen wir zunaechst, was Dijkstra in diesem Fall machen wuerde.", "start": 527.0, "end": 554.0}, {"text": "  Dijkstra waehlt zuerst die Knoten, die auf kuerzester Weg von S erreichbar sind.  Wuerde also diese kurze Kante mit Laenge 1 nehmen und den Knoten W besuchen.  Der Best First Algorithmus besucht die Knoten zuerst, die die kuerzeste Distanz zum Ziel haben.  Also waere es in diesem Fall der Knoten U, der Knoten mit dem kleinsten H-Wert.", "start": 554.0, "end": 581.0}, {"text": "  Der A-Stern Algorithmus benutzt die Summe dieser beiden Kriterien, die F-Funktion, die definiert ist,  als die Distanz vom Start Knoten S, also es ist hier einfach das Kantengewicht, plus den Heuristikwert.  Das heisst, der Knoten U hat den F-Wert 4 plus 1 gleich 5, der Knoten V hat den F-Wert 2 plus 2 gleich 4  und der Knoten W hat den F-Wert 1 plus 4 gleich 5.", "start": 581.0, "end": 615.0}, {"text": "  Nun entscheidet A-Stern, basierend auf dem F-Wert wuerde also den Knoten V zuerst besuchen,  da dieser den kleinsten F-Wert besitzt.  Die Kante von S nach V, die hier von A-Stern ausgewaehlt wird, ist tatsaechlich diejenige, die zu dem kuerzesten Weg von S nach T fuehrt.", "start": 615.0, "end": 641.0}, {"text": " Hier sei noch anzumerken, dass Dijkstraal diesen Weg auch finden wuerde,  aber eben erst mit einem anderen Zwischenschritt, also erst spaeter als der A-Stern Algorithmus.  Schauen wir uns hier nun das Beispiel mit Blockade an, an dem der best first Algorithmus gescheitert ist  und sehen, wie die anderen Algorithmen sich in dieser Situation schlagen.", "start": 642.0, "end": 665.0}, {"text": "  Zunaechst fuer den Dijkstraal Algorithmus, da ist hier in jedem Feld der Distwert eingetragen, also die Laenge des kuerzesten Weges vom Start Knoten S aus.  Diese Werte werden erst beim Ablauf des Algorithmus stimmt, aber zu Illustrationszwecken sind sie hier schon von Anfang an eingetragen.", "start": 665.0, "end": 686.0}, {"text": "  Es geht also vom Start Knoten zuerst zu den naechsterreichbaren Knoten mit Distwert 2, dann 3, 4 und so weiter.  Es arbeitet sich Dijkstra langsam vor und findet zwar erst ganz am Ende ein Weg zu den Zielknoten,  allerdings ist der Weg, der dann gefunden wird, tatsaechlich ein kuerzester Weg.", "start": 686.0, "end": 713.0}, {"text": " Wie ist es nun mit dem A-Stern Algorithmus?  Er richtet sich nach den F-Werten, also der Summe von den Distwerten aus Dijkstra und dem Horistikwert.  Auch diese Werte werden erst waehrend des Ablauf des Algorithmus stimmt, weil sie ja die Distwerte benoetigen und sind hier zur Illustration schon von vornherein eingetragen fuer alle Felder.", "start": 714.0, "end": 741.0}, {"text": "  Die Suche beginnt bei S und besucht erst alle Felder mit dem kleinsten Effort, 15, danach werden der Reihe nach die Felder mit dem Distwert 16 besucht,  dann mit dem Distwert 17 und dann 18 und hier wird nun der Weg um die Blockade gefunden und auch mit Effort 18 wird dann der Weg zum Ziel gefunden.", "start": 741.0, "end": 767.0}, {"text": "  Es ist also auch ein kuerzester Weg, der hier von A-Stern gefunden wird und wir sehen, dass er hier etwas effizienter war als Dijkstra, da nicht alle anderen Felder vorher besucht wurden.  Und bei anderen Grafen ist diese Einsparung von A-Stern gegenueber Dijkstra deutlich groesser.", "start": 767.0, "end": 775.0}]}]