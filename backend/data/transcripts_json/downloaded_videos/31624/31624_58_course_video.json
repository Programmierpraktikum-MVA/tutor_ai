[{"lecture": "31624_58_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns das Konzept der Vererbungen anschauen.  Das beinhaltet auch die Themen Interfaces und abstrakte Klassen.  Beginn werden wir allerdings mit Vererbung.  Wozu benutzen wir Vererbung ueberhaupt?  Zum einen wollen wir Wiederholungen im Code vermeiden, das heisst bereits geschriebener Code soll nicht mehrfach kopiert werden.", "start": 0.0, "end": 24.0}, {"text": "  Dieses Prinzip kennen wir schon von den Methoden.  Hier wenden wir es allerdings auf ganze Klassen an.  Weiterhin wollen wir verallgemeinern, das heisst Attribute und Methoden, die wir schon in einer Klasse definiert haben, wollen wir auch in anderen Klassen nutzen koennen.  Die Suendtags der Vererbung sieht wie folgt aus.", "start": 24.0, "end": 50.0}, {"text": "  Wir definieren an dieser Stelle unsere Klasse wie gewohnt, anschliessend folgt das Schluesselwort Extents und dann von welcher Klasse wir erben moechten.  In dem Fall erbt die Subklasse von der Superklasse.  Das heisst die Subklasse ist eine Klasse, die von einer anderen Klasse erbt, die Superklasse ist eine Klasse, von der geerbt wird bzw. die an eine andere Klasse vererbt.", "start": 50.0, "end": 72.0}, {"text": "  In unserem Fall erbt die Klasse Subklasse von Superklasse.  Aber was genau bedeutet das, wenn eine Klasse von einer anderen erbt?  In der Klasse, die von einer Superklasse erbt, kann man nun auf alle Attribute der Superklasse zugreifen, auf den Konstruktor der Superklasse und auf alle Methoden der Superklasse.", "start": 72.0, "end": 94.0}, {"text": "  Hierbei gibt es eine kleine Einschraenkung, die wir uns allerdings gleich anschauen werden.  Durch das Prinzip der Vererbung kann eine solche Hierarchie entstehen.  Dabei kann eine Klasse an mehrere Klassen vererben, aber nur von einer Klasse erben.  Hier haben wir das Beispiel einiger Klassen, wie sie in Java vorkommen.  Und wir sehen die Klasse String beispielsweise erbt von der Klasse Object.", "start": 95.0, "end": 122.0}, {"text": "  Die Klasse Number erbt auch von der Klasse Object und die Klasse System erbt auch von der Klasse Object.  Es gibt also mehrere Klassen, die von Object erben.  Allerdings erbt jede jeweils nur von einer Klasse.  Das heisst String erbt nur von Object und von keiner anderen Klasse.  Eine Hierarchie entsteht nun, wenn ich weitere Klassen habe, die von der Subklasse erben.", "start": 122.0, "end": 149.0}, {"text": "  Ich habe beispielsweise hier die Klasse Integer, diese erbt von Number und Number wiederum erbt von Object.  Das bedeutet, wenn Number von Object erbt, kann man auf die Attribute und Methoden von Object auch in der Klasse Number zugreifen.  Wenn jetzt Integer von Number erbt, kann man in der Klasse Integer auf alle Methoden und Attribute von Number zugreifen.", "start": 149.0, "end": 172.0}, {"text": "  Das heisst auch indirekt in der Klasse Integer kann man nun auf alle Methoden und Attribute der Klasse Object zugreifen.  Das liegt daran, dass Attribute und Methoden von Object an Number vererbt werden und alle Attribute und Methoden von Number an Integer.  Schauen wir uns aber nun die Ausnahme fuer Vererbung an.", "start": 172.0, "end": 199.0}, {"text": " Ist naemlich ein Attribut oder eine Methode als Private deklariert?  So ist dieses Attribut oder diese Methode nur innerhalb der Klasse gueltig und nicht in Klassen, die davon erben.  Das Schluesselwort Public kennen wir schon.  Attribute und Methoden, die als Public deklariert wurden, sind in allen Klassen gueltig.  Das heisst unabhaengig von der Vererbung kann ich sowieso darauf zugreifen.", "start": 199.0, "end": 216.0}, {"text": "  Das neue Schluesselwort, was wir jetzt allerdings einfuehren, ist das Schluesselwort Protected.  Ist ein Attribut oder eine Methode als Protected deklariert?  So ist dieses Attribut oder die Methode innerhalb der Klasse gueltig, in der es deklariert wurde,  und in allen Klassen, die davon erben, aber nicht in anderen Klassen.  Schauen wir uns das Ganze noch einmal an diesem Beispiel an.", "start": 216.0, "end": 239.0}, {"text": "  Ist zum Beispiel ein Attribut in Object als Private deklariert?  So kann man nicht in den Klassen String, Number und System darauf zugreifen.  Ist beispielsweise in Number eine Methode auf Protected gesetzt?  So kann ich in Number darauf zugreifen und in allen Klassen, die davon erben, also in Integer und in Double.", "start": 239.0, "end": 265.0}, {"text": "  Ich kann nicht darauf zugreifen in der Klasse String, da die nicht von Number erbt, auch nicht in der Klasse System  und auch nicht in der Klasse Object, da die Vererbung nur in eine Richtung funktioniert.  Schauen wir uns im speziellen noch einmal die Vererbung des Konstruktors an.  Wir haben auf der linken Seite die Klasse A, welche zwei Attribute besitzt, die jeweils Protected sind.", "start": 265.0, "end": 285.0}, {"text": "  Hierbei habe ich den Datentyp einmal weggelassen.  Im Konstruktor mache ich da nichts anderes, als diese beiden auf die Werte setzen, die mit den Parametern uebergeben wurden.  Daneben habe ich nun eine Klasse B und diese erbt von Klasse A.  Das bedeutet, ich kann jetzt innerhalb von Klasse B auf die Attribute A, B und C zugreifen.", "start": 285.0, "end": 312.0}, {"text": "  Weiterhin kann ich allerdings auch auf den Konstruktor der Klasse A zugreifen.  Das mache ich mir zur Nutze, wenn ich den Konstruktor der Klasse B schreibe.  Hier moechte ich naemlich alle drei Attribute setzen.  Da der Konstruktor der Klasse A schon die Attribute A und B setzt, kann ich diesen mithilfe des Schluesselwort Super aufrufen.", "start": 312.0, "end": 333.0}, {"text": "  Das Schluesselwort Super wird generell dafuer verwendet, um auf Methoden der Superklasse zu greifen zu koennen.  Indem ich nur Super schreibe, greife ich auf den Konstruktor der Superklasse zu.  Ich muss auch hier wieder die Parameter A und B uebergeben und diese werden nun mittels dieses Konstruktors gesetzt.", "start": 333.0, "end": 356.0}, {"text": "  Was es zu beachten gilt, der Superbefehl muss immer am Anfang des jeweiligen Konstruktors aufgerufen werden.  Nachdem ich diesen Konstruktor aufgerufen habe, kann ich nun zusaetzlich noch mein Attribut C setzen.  Somit wurden alle Attribute initialisiert.", "start": 356.0, "end": 375.0}, {"text": "  Waehrend diese beiden Attribute auf Private gesetzt, so koennte ich in der Klasse B nicht darauf zugreifen, sondern haette nur das Attribut C zur Verfuegung.  Auch das Thema der Vererbung wollen wir uns in einer kleinen Programmieraufgabe einmal anschauen.  Dazu wuerde ich euch bitten, diese Aufgabe auch wieder zuerst selbst zu loesen und im Anschluss zeige ich euch, wie ich die Aufgabe geloest habe.", "start": 375.0, "end": 398.0}, {"text": "  Ihr sollt hier die Klasse-Module aus dem letzten Programmierbeispiel so anpassen, dass sich alle Attribute und Methoden vererben lassen.  Ueberleg dazu, welche Schluesselworte ihr verwenden muesst.  Definiert nun eine neue Klasse-Wahl-Module, welche von der Klasse-Module erbt und zusaetzlich das Public-Attribut benotet besitzt.", "start": 398.0, "end": 419.0}, {"text": "  Schreibt den Konstruktor so, dass man das neue Attribut zusaetzlich zu den anderen beim Erstellen eines Objektes setzen kann.  Testet die Funktionalitaet dann wieder in der Testklasse.  Um die Vererbung von Attributen moeglich zu machen, beginnen wir erstmal damit, diese nicht mehr auf Private zu setzen, sondern auf Protected.", "start": 419.0, "end": 456.0}, {"text": "  Auf Attribute, die auf Private gesetzt sind, kann man eben nur innerhalb der Klasse zugreifen.  Auf Attribute, die auf Protected gesetzt sind, kann man innerhalb dieser Klasse und von allen Klassen, die davon Erben zugreifen.  Wir moechten also nun eine neue Klasse erzeugen, die den Namen Wahl-Module traegt.  Neue Klasse und diese traegt den Namen Wahl-Module.", "start": 456.0, "end": 486.0}, {"text": "  Diese Klasse Wahl-Module soll nun von der Klasse-Module erben.  Dazu benutzen wir das Schluesselwort Extents und jetzt die Klasse, von der wir erben wollen, in dem Falle Modul.  Was wir nun als Allererstes machen, ist unseren Konstruktor anpassen.  Dazu schreiben wir wieder Public, den Namen unserer Klasse und nun alle Parameter, die wir benoetigen.", "start": 487.0, "end": 528.0}, {"text": "  Wir wollen zum einen die drei Attribute setzen, die wir auch schon im Konstruktor davor gesetzt haben, also im Konstruktor von Modul,  und weiterhin das Attribut benotet setzen.  Das heisst, wir benoetigen ein Integer fuer die Teilnehmerzahl,  einen Integer fuer unsere LP-Zahl, einen String fuer den Professor  und ein Parameter fuer benotet, das schauen wir uns aber gleich an.", "start": 528.0, "end": 560.0}, {"text": "  Um nun diese drei Attribute zu setzen, die auch schon durch den Konstruktor von Modul gesetzt worden sind,  rufen wir einfach den Konstruktor von Modul auf, indem wir das Schluesselwort Super verwenden.  Hier uebergeben wir nun die Teilnehmer, die LP und den Professor.  Was wir also bisher gemacht haben, ist im Konstruktor fuer Wahlmodul den Konstruktor von Modul aufrufen mit den gleichen Parameter.", "start": 560.0, "end": 591.0}, {"text": "  Nun wollen wir allerdings noch das Attribut benotet hinzufuegen.  Dieses soll auf Public gesetzt sein.  Als Datentyp wollen wir hier Boolean, da entweder das Modul benotet ist oder das Modul nicht benotet ist.  Es gibt also nur ein wahr und ein falsch, und das laesst sich am besten durch ein Boolean darstellen.  Und dann folgt der Name in dem Fall benotet.", "start": 597.0, "end": 625.0}, {"text": "  Eine Moeglichkeit, waere jetzt, benotet auch zu den Parametern unseres Konstruktors hinzuzufuegen.  Was wir allerdings auch machen koennen, ist zum Beispiel diesen Boolean in dem Fall benotet auf immer auf false zu setzen.  Nun koennt ihr euch kurz darueber Gedanken machen, wie wird ein Boolean standardmaessig initialisiert.  Jeder Boolean wird immer standardmaessig auf false gesetzt.", "start": 626.0, "end": 659.0}, {"text": "  Das heisst, in diesem Falle waere der Schritt gar nicht noetig, weil jeder Boolean von vornherein auf false gesetzt wird.  Moechten wir das aber, wie in der Aufgabe angegeben, auch als Parameter uebergeben, so muessen wir das hier oben hinzufuegen.  Datentyp Boolean, Name ist benotet und dann koennen wir hier unser Parameter unserem Attribut zuweisen.", "start": 659.0, "end": 688.0}, {"text": "  Das Ganze koennen wir jetzt auch einmal eine Testklasse ueberpruefen, indem wir jetzt hier nach unserem Modul-Algodat ein weiteres Modul erstellen.  Wir geben dazu wieder den Datentyp Modul an.  Das ist jetzt zum Beispiel Intro-Brog.  Und hier rufen wir nun den Konstruktor auf. Allerdings ist das nun ein Wahlmodul fuer uns.", "start": 688.0, "end": 718.0}, {"text": "  Er hat zum Beispiel auch 1500 Teilnehmer, bringt 6 LP, der Professor heisst Benjamin Blankertz.  Und da wir nun den Konstruktor von Wahlmodul aufrufen, benoetigen wir hier noch einen vierten Parameter, naemlich ob das Modul benotet ist oder nicht.  In dem Falle sage ich True, das heisst unser Modul ist benotet.", "start": 720.0, "end": 746.0}, {"text": "  Was wir nun noch abschliessend machen koennen, ist mit es einer IF-Bedingung ueberpruefen, ob unser Modul bewertet ist oder nicht und je nachdem etwas ausgeben.  Ich kann zum Beispiel schreiben IF.  Jetzt folgt eine Bedingung.  Ich moechte wissen, ob mein Modul benotet ist, das heisst ich moechte wissen, ob das Attribut benotet auf True gesetzt ist.", "start": 747.0, "end": 767.0}, {"text": "  Da das Attribut Public ist, kann ich einfach den Objektnamen verwenden, in dem Fall Intro-Brog.  Dann ein Punkt.  Und dann benotet und kann so darauf zugreifen.  Hier erhalte ich jetzt momentan eine Fehlermeldung, weil ich das Ganze in eine Variable gespeichert habe, die vom Typ Modul ist.", "start": 768.0, "end": 793.0}, {"text": "  Ich erhalte hier oben noch keine Fehlermeldung, weil sich ein Objekt auch in Variablen des Types der Superklasse speichern laesst.  Das Ganze werde ich gleich nochmal unter dem Namen Polymorphie erklaeren.  Moechte ich das Ganze allerdings als Wahlmodul speichern, damit ich auch auf das Attribut benote zugreifen kann, muss ich hier natuerlich auch den Datentyp Wahlmodul angeben.", "start": 794.0, "end": 823.0}, {"text": "  Jetzt habe ich hier ein Boolean stehen, das heisst wenn dieser Teil hier wahr ist, dann wird der folgende Teil des Codes ausgefuehrt.  Hier moechte ich jetzt wieder eine Ausgabe machen, auch hierfuer gibt es bei IDEA eine Abkuerzung.  Isolautet es out.  Und hier kann ich jetzt zum Beispiel den Text ausgeben, das Modul Intro-Brog ist benotet.", "start": 824.0, "end": 855.0}, {"text": "  Moechte ich jetzt noch eine Ausgabe machen, wenn es nicht benotet ist, kann ich hier noch ein RS-Blog anfuegen.  Und hier mache ich auch eine Ausgabe, allerdings sage ich hier, das Modul ist nicht benotet.  Wenn benotet jetzt wahr ist, ist diese Bedingung erfuellt, das heisst alles in diesem Blog wird ausgefuehrt, also genau diese Zeile.  Und der RS-Blog wird uebersprungen.", "start": 859.0, "end": 891.0}, {"text": "  Ist unsere Bedingung falsch, also benotet auf false, wird der IF-Blog uebersprungen und nur das im RS-Blog ausgefuehrt.  Das ganze testen wir einmal, indem wir hier wieder unsere Testfunktion ausfuehren.  Und wir bekommen die Ausgabe, das Modul Intro-Brog ist benotet.  Aendern wir in unserem Konstruktor benotet auf false.", "start": 892.0, "end": 921.0}, {"text": "  Erwarten wir, dass eben an dieser Stelle das Attribut false ist, somit ist die Bedingung nicht erfuellt und wir landen im RS-Blog.  Wir fuehren das ganze noch einmal aus und sehen unsere Ausgabe, das Modul ist nicht benotet, genau wie wir erwartet haben.  Nachdem wir uns die Grundlagen von Veraerbung anschauen, wollen wir uns noch ein paar spezielle Prinzipien angucken.", "start": 922.0, "end": 948.0}, {"text": "  Zum einen schauen wir uns das Konzept der Polymorphie an.  Polymorphie bedeutet, dass Objekte einer Klasse auch als Objekte der Superklasse behandelt werden koennen.  Das ist insofern nuetzlich, dass sich dann Objekte gleicher Superklasse z.B. in einem Arri oder in einer Liste zusammenspeichern kann.  Das Prinzip der Polymorphie schauen wir uns einmal an diesem Beispiel an.", "start": 949.0, "end": 976.0}, {"text": "  Wir haben zum einen die Klasse Schiff, ich habe hier mal die Klassendefinition weggelassen, weil die in diesem Beispiel nicht so wichtig ist.  Zum anderen haben wir die Klasse Segelschiff, welche von der Klasse Schiff erbt.  In meiner Main-Methode erstelle ich dann zuerst ein neues Array, welches Objekte vom Typ Schiff speichert und die Groesse 2 hat.", "start": 977.0, "end": 997.0}, {"text": "  Nun habe ich die Moeglichkeit an die erste Stelle des Arrays, also Position 0, ein neues Schiffobjekt zu speichern.  Ich habe allerdings auch die Moeglichkeit an Position 2, also Index 1, ein neues Segelschiff zu speichern,  weil eben die Klasse Segelschiff eine Unterklasse bzw. eine Subklasse der Klasseschiff ist.  Hierbei muessen wir allerdings eine Sache beachten.", "start": 998.0, "end": 1022.0}, {"text": "  Wenn wir nun auf eine Methode der Unterklasse zugreifen wollen, kann es noetig sein, dass wir vorher karsten muessen.  Schauen wir uns das Ganze an unserem Segelschiff-Beispiel an.  Wenn wir z.B.", "start": 1023.0, "end": 1044.0}, {"text": "in der Klasse Segelschiff eine Methode haben, die X heisst, die allerdings nicht in der Klasseschiff definiert ist,  dann ist es notwendig, vor dem Zugriff auf die Methode das Objekt, was in diesem Array enthalten ist, zu Segelschiff zu karsten.  Normalerweise wuerde es ausreichen, wenn ich schreibe Objektname, Punkt, Methodenname.", "start": 1045.0, "end": 1056.0}, {"text": "  Ich weiss auch, an Index Stelle 1 steht ein Objekt vom Typ Segelschiff.  Das Problem ist, dass Java sich nur den Typen des Arrays anguckt und der Typ des Arrays lautet Schiff und eben nicht Segelschiff.  Es wird also geguckt, ist in der Klasse Schiff eine Methode X verfuegbar, das ist sie nicht, das heisst hier wird ein Fehler ausgegeben.", "start": 1057.0, "end": 1092.0}, {"text": "  Mithilfe des TypeCasts, indem ich in Klammern den neuen Datentyp fuer unser Objekt schreibe, sage ich explizit, dieses Objekt ist ein Segelschiff bzw. ich wandle es um in ein Segelschiff und anschliessend rufe ich Methode X auf.  Das Ganze ist allerdings nur notwendig, wenn die Methode X ausschliesslich in Segelschiff definiert ist.", "start": 1094.0, "end": 1106.0}, {"text": "  Neben dem Prinzip des Veraergens gibt es auch das Prinzip der Interfaces.  Ein Interface enthaelt erstmal nur Methodenkoepfe, das heisst wir haben keine Attribute, wir haben keinen Konstruktor und wir haben auch keine vollstaendig definierten Methoden, sondern wir haben eben ausschliesslich nur diese Methodenkoepfe.", "start": 1107.0, "end": 1126.0}, {"text": "  Wird ein Interface von einer Klasse implementiert, muss diese auch die Methoden des Interfaces implementieren.  Somit macht man in Anfuehrungsstrichen eine Veraerbung von mehreren Klassen moeglich.  Ich sage hier extra in Anfuehrungsstrichen, weil es sich hierbei nicht wirklich um eine Veraerbung handelt.", "start": 1126.0, "end": 1145.0}, {"text": "  Interfaces finden gerne Anwendungen, wenn man zum Beispiel Schnittstellen oder Module programmiert.  Man hat nun beispielsweise ein Programm geschrieben und das hat eine bestimmte Schnittstelle.  Und an dieser Schnittstelle kann der Nutzer eine eigene Klasse anbinden, die er eben selber programmiert.", "start": 1146.0, "end": 1166.0}, {"text": "  Damit euer gesamtes Programm funktioniert, muss allerdings diese Klasse, die an die Schnittstelle angebunden ist, bestimmte Methoden haben.  Und um sicherzustellen, dass eben jede Klasse, die an diese Schnittstelle angesetzt wird, eben genau diese Methoden hat,  kann man ein Interface schreiben und jede Klasse, die eben an diese Schnittstelle angedockt wird, muss dieses Interface implementieren.", "start": 1167.0, "end": 1186.0}, {"text": "  Das heisst, sie muss auch diese Methoden implementiert haben.  Und diese Methoden implementiert haben heisst, der Methodenkopf muss identisch sein.  Das bedeutet der gleiche Rueckgabewert, der gleiche Name und die gleichen Parameter.  Was diese Methode letztendlich macht und ob diese Methode das richtig macht, ist bei Interfaces nicht garantiert.", "start": 1187.0, "end": 1209.0}, {"text": "  Schauen wir uns das Ganze aber mal an einem Beispiel an.  Wir haben hier zwei Interfaces, zum einen das Interface Add und zum anderen das Interface Muld.  Und jedes Interface enthaelt den Methodenkopf einer Methode, in dem Fall hier die Methode addiere und die Methode multipliziere.  Ich gebe hier wie gesagt den Rueckgabetypen an, den Namen der Methode und die Parameter.", "start": 1210.0, "end": 1239.0}, {"text": "  Nun habe ich eine Klasse Rechner und diese implementiert die beiden Interfaces add und Muld.  Das sieht syntaxtechnisch so aus, dass ich das Schluesselwort Implements benutze und dann durch Komma getrennt alle Interfaces, die ich implementieren moechte.  Bis meine Klasse ansonsten leer, erhalte ich die Fehlermeldung, dass ich noch weitere Methoden implementieren muss.", "start": 1241.0, "end": 1264.0}, {"text": "  Das sind eben genau die beiden Methoden, die in den Interfaces definiert sind, und zwar addiere und multipliziere.  Hier schreibe ich jetzt nicht nur den Methodenkopf, sondern schreibe auch, was diese Methode machen soll.  Neben den Interfaces gibt es auch abstrakte Klassen.", "start": 1265.0, "end": 1284.0}, {"text": "  Im Gegensatz zu Interfaces ist es hier moeglich, auch Attribute und Methoden zu vererben, dass sich hierbei nicht um Interfaces, sondern wirklich um Klassen handelt.  Der einzige Unterschied zu normalen Klassen ist, dass wir zu implementierende Funktionen offen lassen, indem wir wieder nur den Methodenkopf schreiben und diese mit dem Schluesselwort Abstract kennzeichnen.", "start": 1286.0, "end": 1308.0}, {"text": "  Wenn eine Klasse nun von einer abstrakten Klasse erbt, muss diese auch die abstrakten Funktion bzw. Methoden der Superklasse implementieren.  Wir haben hier als Beispiel die abstrakte Klasse Rechner und diese hat das Attribut Ergebnis, einen Konstruktor wie wir hier sehen und besitzt weiterhin eine Methode, die wir allerdings als Abstract kennzeichnen.", "start": 1310.0, "end": 1328.0}, {"text": "  Das bedeutet, wir schreiben nur den Methodenkopf.  Wenn wir jetzt von dieser Klasse erben, das machen wir mit dem Schluesselwort Extents, was wir bereits kennen, dann muessen wir eben genau diese Methode implementieren, die wir vorher als Abstract gekennzeichnet haben.", "start": 1330.0, "end": 1353.0}, {"text": "  Als letztes Beispiel schauen wir uns noch die Generics an. Generics verwenden wir immer dann, wenn noch unbekannt ist, welchen Datentyp ein Objekt hat.  Am besten laesst sich das Ganze durch ein Beispiel verdeutlichen. Stellt euch vor, ihr schreibt ein Algorithmus und der vergleicht zwei Areas miteinander.  Wie genau der Vergleich funktioniert, ist fuer uns erstmal uninteressant.", "start": 1355.0, "end": 1376.0}, {"text": "  Wir gehen naemlich der Einfachheit halber davon aus, dass der Algorithmus immer gleich funktioniert, egal welcher Datentyp in den Areas gespeichert ist.  Wir wollen jetzt allerdings nicht fuer jeden Datentyp eine eigene Klasse schreiben.  Das Ganze sieht dann von der Syntax her so aus.", "start": 1377.0, "end": 1394.0}, {"text": "  Wir haben hier eine Klasse Vergleich, z.B. ich habe es hier mal abgekuerzt, und dahinter folgt in Spitzenklammern dieses T.  Das T steht fuer den generischen Datentypen, den wir bisher noch nicht wissen.  Nun schauen wir uns die beiden Attribute an. Die beiden Attribute sind Areas von eben diesen Datentypen T, den wir noch nicht kennen.", "start": 1395.0, "end": 1416.0}, {"text": "  Im Konstruktor uebergebe ich dann zwei Areas, auch wieder von diesen Datentypen, den wir bisher noch nicht kennen, deswegen steht hier wieder ein T.  Und schreiben das in unsere Attribute.  Wenn wir nun z.B. in der Main-Methode ein neues Objekt von dieser Klasse erzeugen, koennen wir in Spitzenklammern nun den Datentypen angeben.", "start": 1417.0, "end": 1438.0}, {"text": "  Das heisst, in diesem Fall wollen wir einen Vergleich von String Areas durchfuehren, deswegen geben wir hier den Datentyp String an.  Wir uebergeben dem Konstruktor also auch zwei String Areas.  Was nun beim Erstellen des Objektes passiert, ist, dass dieses T ueberall in der Klasse durch das Wort String ersetzt wird.  Das heisst, wir haben hier jetzt zwei Attribute vom Typ String Areay.", "start": 1439.0, "end": 1461.0}, {"text": "  Und wir haben hier im Konstruktor auch zwei Parameter vom Typ String Areay.  Wuerden wir das gleiche mit einem Integer machen, dann wuerden wir hier zwei Integer Areas erzeugen und wuerden hier statt String in die Spitzenklammern Int schreiben.  Und koennten somit von der gleichen Klasse ein neues Objekt erzeugen, was eben keine String Areas mehr vergleicht, sondern Integer Areas.", "start": 1463.0, "end": 1493.0}, {"text": "  Das heisst, wir haben hier im Konstruktor auch zwei String Areas erzeugen, die String Areas erzeugen.  Und wir haben hier im Konstruktor auch zwei String Areas erzeugen, die String Areas erzeugen.  Und wir haben hier im Konstruktor auch zwei String Areas erzeugen, die String Areas erzeugen.", "start": 1494.0, "end": 1509.0}]}]