[{"lecture": "31624_44_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns verschiedene Datenstrukturen anschauen.  Dazu gehoeren Ares, Listen, Cues und Stacks.  Beginn werden wir mit den Ares.  Ares sollten schon aus Intro Proc bekannt sein.  Hierbei handelt es sich um zusammenhaengende Felder am Speicher, in denen Elemente von  einem Datentyp gespeichert sind.", "start": 0.0, "end": 28.36}, {"text": "  Der Vorteil von Ares ist, dass fuer Zugriffe keine komplexeren Funktionen benoetigt werden.  Der Nachteil hingegen ist, dass Ares immer eine feste Groesse haben und die Elemente  in dem Ares feste Positionen.  In Java sieht die Suendtags fuer Ares folgendermassen aus.  Ich moechte nun ein neues Ares erstellen mit dem Namen Ares.  Dieses soll Elemente speichern, welche vom Typ Element sind.", "start": 29.12, "end": 56.239999999999995}, {"text": "  Dazu deklariere ich erst meine Variable, indem ich schreibe Element, das ist mein Datentyp,  dann die eckigen Klammern und anschliessend den Namen meines Ares und ich initialisiere  diese Variable, indem ich das Schluesselwort New verwende, anschliessend wieder mein Datentyp  und den eckigen Klammern die Groesse meines Ares.", "start": 56.24, "end": 77.64}, {"text": "  Moechte ich nun ein Element diesem Ares hinzufuegen, verwende ich den Aresnamen und schreibe in  eckigen Klammern die Positionen an die das Element gespeichert werden soll.  Dann folgt ein Ist gleich und das Element was sie speichern moechte.", "start": 77.64, "end": 96.36}, {"text": " Auf dem gleichen Weg kann ich auch auf Elemente im Ares zugreifen, indem ich auch wieder  den Aresnamen schreibe, in eckigen Klammern die Position auf die ich zugreifen moechte  und diese dann in eine neue Variable speichere.  Zusaetzlich kann ich mit dem Attribut Length auf die Groesse des Ares zugreifen.", "start": 96.36, "end": 111.44}, {"text": " Das ist vor allem hilfreich, wenn ich mit einer Schleife ueber das gesamte Ares iterieren  moechte.  Das Prinzip von Ares wollen wir nun anwenden, indem wir das Shop Beispiel aus dem letzten  Video erweitern.  Versucht hier erst einmal wieder selbst das ganze zu programmieren und anschliessend  zeige ich meine Loesung.", "start": 111.44, "end": 130.68}, {"text": "  Fuegt dazu der klasse Shop, welche wir im letzten Video begonnen haben, zu programmieren,  das Attribut Regal hinzu.  Auch dieses Attribut soll wieder als Private definiert sein.  Bei Regal soll es sich um ein Array handeln, welches Objekte vom Typ Produkt speichert.  Produkt ist auch eine Klasse, die wir letztes Mal schon geschrieben haben.  Fuegt anschliessend die Methode Lieferung hinzu.", "start": 130.68, "end": 157.88}, {"text": "  Diese bekommt als Parameter ein Produkt uebergeben und diese soll dann im Array Regal gespeichert  werden, sofern dort noch Platz ist.  Ist im Regal allerdings kein Platz mehr, soll eine Fehlermeldung ausgegeben werden.", "start": 157.88, "end": 178.72}, {"text": " Schreibt weiterhin die Methode kaufen, welche als Parameter ein Produktnamen uebergeben  bekommt und ist dieses Produkt im Regal verfuegbar, soll es aus dem Regal geholt werden und zurueckgegeben  werden.  Ist es nicht vorhanden, soll abermals eine Fehlermeldung ausgegeben werden.  Beginnen wir also nun, unsere Klasse Shop zu erweitern.  Dazu fuege ich zuerst das private Attribut Regal hinzu.", "start": 178.72, "end": 197.92}, {"text": "  Dieses hat den Datentyp ProduktArray.  Ich schreibe also Private, dann mein Datentyp und zwar soll es ein Array sein, welches Produkte  enthaelt.  Also schreibe ich Produkt und dann die eckigen Klammern und anschliessend den Namen in dem  Falle Regal.  Dieses muss jetzt im Konstruktor initialisiert werden.  Dazu schreibe ich wieder this.regal, um auf mein Attribut zuzugreifen.", "start": 197.92, "end": 233.76}, {"text": "  Anschliessend schreibe ich, wie wir uns gerade in der Synthax angeguckt haben, New, Produkt  als Datentyp, Array Klammern und dann folgt die Groesse.  Die Groesse koennten wir nun beispielsweise als Parameter von unserem Konstruktor uebergeben.  Dazu muss ich ihn allerdings noch in der Parameterliste hinzufuegen.  Die Groesse ist eine ganze Zahl, deswegen Datentyp int und dann nennen wir das Ganze  size.", "start": 233.76, "end": 265.08000000000004}, {"text": "  Wenn ich also nun ein neues Objekt vom Typ Shop erzeuge, dann wird das Attribut Name auf  mein Parameter Name gesetzt, das Attribut Besitzer auf mein Parameter Besitzer und ein neues  Array erzeugt, welches die Groesse hat, die wir hier als Paramete uebergeben.  Nun fuegen wir die weiteren Methoden hinzu.  Beginn werden wir mit der Methode Lieferung.", "start": 265.08000000000004, "end": 292.52}, {"text": "  Auf diese soll man von aussen zugreifen koennen, deswegen ist sie Public.  Sie muss nichts zurueckgeben, deswegen waehle ich als Rueckgabetyp Void und sie heisst Lieferung.  Als Parameter soll nun ein Produkt uebergeben werden.  Das nenne ich hier P.", "start": 292.52, "end": 320.64000000000004}, {"text": " Was wir nun machen wollen ist zu ueberpruefen, ob es in unserem Array noch einen freien  Platz gibt und falls ja unser Produkt an diesen freien Platz speichern.  Da wir allerdings nicht wissen, wo in unserem Array noch ein freier Platz ist, muessen wir  Schritt fuer Schritt jede Position des Arrays durchgehen.", "start": 320.64000000000004, "end": 336.0}, {"text": " Wie ich bereits vorher erwaehnt habe, ist das mit einer Vorschleife relativ einfach  moeglich.  Hierbei initialisieren wir unseren Zaehler mit 0, da das die erste Position in unserem  Array ist.  Nun muessen wir uns noch ueberlegen, was die letzte Position in unserem Array ist.", "start": 337.0, "end": 357.4}, {"text": " Hat unser Array zum Beispiel Groesse 5, ist die letzte Position die 4, hat unser Array  die Groesse 10, ist die letzte Position die 9.  Wir muessen also dafuer sorgen, dass i immer kleiner ist als die Laenge von unserem Array.  Hier gebe ich nur den Namen des Arrays an, in dem Falle ist das Regal und anschliessend  Punkt und Length, um auf die Laenge zuzugreifen.", "start": 357.4, "end": 380.68}, {"text": "  Haben wir ein Array der Groesse 5, laeuft unsere Vorschleife somit von 0 bis 4.  Mit jedem Schritt wollen wir den Zaehler noch um 1 hochzaehlen.  Der Zaehler i drueckt jetzt in jedem Schleifen-Durchlauf aus, an welcher Position im Array wir uns  gerade befinden.  Wir muessen nun also innerhalb der Schleife ueberpruefen, ob an Position i eine Stelle  in dem Array frei ist.", "start": 380.68, "end": 406.56}, {"text": "  Um etwas zu ueberpruefen, koennen wir ein If-Statement verwenden.  Hier muessen wir nun ueberpruefen, ob die Stelle an dem Array frei ist.  Dazu ueberlegen wir erst einmal, mit was jede Stelle in dem Array initialisiert ist.  Da wir im Konstruktor keine speziellen Werte in das Array geschrieben haben, ist dieses  mit Standardwerten initialisiert.  Komplexe Datentypen werden immer mit Null initialisiert.", "start": 406.56, "end": 434.6}, {"text": "  Daher steht in einem leeren Feld von unserem Array Null.  Wir muessen also an dieser Stelle ueberpruefen, ist das Array an Position i gleich Null.  Das machen wir, indem wir wieder auf unser Array zugreifen.  Nun ueberpruefen wir die Position i, indem ich eckige Klammern verwende.  Und diese soll nun gleich sein mit Null.  Ist das der Fall, haben wir eine freie Stelle gefunden.", "start": 434.6, "end": 472.6}, {"text": "  Wenn wir nun eine freie Stelle gefunden haben, moechten wir an diese freie Stelle unser Produkt p schreiben.  Ich greife also auch wieder auf die Stelle in unserem Array zu, indem ich schreibe this.regal, an der Stelle i und dort weise ich jetzt den Wert p zu.  Nun muss ich noch eine Sache beachten.  Stellen wir uns beispielsweise mal vor, unser Array ist komplett leer.", "start": 472.6, "end": 506.6}, {"text": "  Dann wuerden wir im ersten Schleifendurchlauf eine leere Stelle finden, wuerden an diese leere Stelle p schreiben, dann gehen wir in den zweiten Schleifendurchlauf, finden wieder eine leere Stelle, wuerden dort wieder p hinschreiben und so weiter.  Das heisst so wie der Code momentan geschrieben ist, wuerden wir unser Array einfach mit dem Produkt auffuellen.", "start": 506.6, "end": 523.6}, {"text": "  Um das zu verhindern, muessen wir die Schleife abbrechen, sobald einmal eine freie Stelle gefunden wurde und wir an diese freie Stelle unser Produkt geschrieben haben.  Um die Schleife abzubrechen, gibt es das Schluesselwort Break.  Nun muessen wir uns noch um den Fall kuemmern, dass keine freie Stelle verfuegbar war.", "start": 523.6, "end": 547.6}, {"text": "  Sollte keine Stelle freigewesen sein, so laeuft die Schleife bis zum Ende durch und anschliessend kommen wir hier hinten am Ende der Schleife raus, ohne das Produkt in unser Array eingefuegt zu haben.  Sollten wir also diese Stelle erreicht haben, wissen wir, dass das Produkt nicht in unser Array eingefuegt werden konnte.  Hier koennen wir nun also eine Fehlermeldung ausgeben.", "start": 547.6, "end": 572.6}, {"text": "  Ich mache das an der Stelle mit einer einfachen Konsolenausgabe, indem ich schreibe System.out.printlm und anschliessend hier den Fehlertext ausgebe.  Zum Beispiel das Produkt.  Jetzt koennen wir den Namen des Produktes hier anfuegen.  Dazu schreibe ich Objektname.methodename, in dem Fall moechte ich die Getter-Methode vom Namen aufrufen, deswegen GetName.", "start": 572.6, "end": 603.6}, {"text": "  Und setze mein Satz fort, das Produkt, wie auch immer das Produkt teist, konnte nicht geliefert werden.  So wie der Code momentan geschrieben ist, werden wir immer an dieser Zeile ankommen.  Finden wir naemlich eine freie Stelle im Regal, schreiben wir an diese freie Stelle p, dann brechen wir die Vorschleife ab und kommen in dieser Zeile raus.", "start": 607.6, "end": 634.6}, {"text": "  Um zu verhindern, dass dann immer diese Printausgabe ausgegeben wird, koennen wir uns zum einen in einer Variable merken, ob wir ein Produkt in unser Regal geschrieben haben oder nicht.  Alternativ koennen wir auch sagen, statt hier ein Break anzuwenden, rufen wir Return auf, somit verlassen wir direkt die Funktion und diese Zeile wird nicht mehr aufgerufen.  Wittmet wir uns nun der Kaufen-Methode.", "start": 634.6, "end": 654.6}, {"text": "  Auch diese soll wieder von aussen verfuegbar sein, deswegen Public.  Diese muss nun ein Produkt wiedergeben, sofern dieses verfuegbar ist.  Und sie traegt den Namen Kaufen.  Als Parameter moechte ich den Namen des Produktes uebergeben, welches ich kaufen moechte.  Auch hier gehe ich wieder aehnlich vor wie in unserer Lieferung-Methode.", "start": 654.6, "end": 687.6}, {"text": "  Ich moechte Schritt fuer Schritt durch mein Airy durchgehen und an jeder Stelle ueberpruefen, ob das das Produkt ist, was ich eigentlich kaufen moechte.  Sollte ich das Produkt gefunden haben, moechte ich dieses zurueckgeben.  Wenn ich durch das komplette Airy durchgegangen bin, ohne das Produkt zu finden, moechte ich eine Fehlermeddung ausgeben.", "start": 687.6, "end": 703.6}, {"text": "  Um ueber das gesamte Airy zu iterieren, verwenden wir wieder die gleiche Vorschleife.  Diese startet bei 0, laeuft bis 1 kleiner als die Airy-Laenge  und der Zaehler wird in dem Schleifendurchlauf einhoh gezaehlt.  Nun moechten wir in jedem Schleifendurchlauf ueberpruefen, ob das Produkt an dieser Stelle im Regal den gleichen Namen hat, wie den Namen, den wir als Parameter der Methode uebergeben haben.", "start": 703.6, "end": 738.6}, {"text": "  Auch das mache ich wieder mit einer IF-Bedingung.  Jetzt greife ich auf die Stelle in dem Regal zu, wieder ueber die eckigen Klammern, i ist meine Position.  Und jetzt habe ich hier mein Airy.  An einer Position in dem Airy steht ein Produkt, das heisst ich kann jetzt Methoden aufrufen, die auf Produkten definiert sind.  Ich kann zum Beispiel hier jetzt aufrufen GetName.", "start": 738.6, "end": 775.6}, {"text": "  Das hier ist mein Airy von Produkten, das hier ist das Produkt an der Stelle i und das hier ist der Name des Produkts an Stelle i in meinem Airy.  Und dieser soll nun gleich sein mit dem Namen, den ich dort oben uebergeben haben.  Bei komplexen Datentypen muessen wir allerdings eine weitere Sache beachten.  Der doppelte Ist-Gleich-Operator vergleicht hierbei nur die Referenz auf diese Objekte.", "start": 775.6, "end": 803.6}, {"text": "  Da aber der String, der hier steht, ein anderes Objekt ist, als der String, der hier steht, wuerden wir hier immer Folls bekommen.  Um den Inhalt der Strings zu vergleichen, verwenden wir die Equals-Methode, welche auf Strings definiert ist.  Um das Ganze noch einmal zu wiederholen, wir haben hier unser Airy von Produkten, hier unser Produkt an der Stelle i, hier unseren String.", "start": 803.6, "end": 833.6}, {"text": "  Das heisst wir koennen an dieser Stelle nun die Equals-Methode aufrufen und den Klammern unseren Namen angeben.  Diese Methode ueberprueft nun, ob der String, den wir hier erhalten, der gleiche ist wie dieser hier vom Inhalt her.  Wenn das der Fall ist, haben wir unser Produkt gefunden.  Dieses Produkt koennen wir also nun zurueckgeben, indem wir schreiben return this.regal an der Stelle i.", "start": 833.6, "end": 865.6}, {"text": "  Wenn wir das so programmieren, erhalten wir zwar das richtige Produkt, das Produkt verweilt aber im Regal.  Um das Produkt aus dem Regal herauszunehmen, muessten wir die Stelle in dem Regal auf null setzen.  Das mache ich, indem ich wieder auf meinen Airy zugreife, an der Stelle i und diese mit null ueberschreibe.", "start": 865.6, "end": 894.6}, {"text": "  Ihr seht hier allerdings schon ein Problem, ich setze hier die Stelle i in unserem Airy auf null, gebe dann hier diese Stelle wieder zurueck, das heisst wir wuerden immer null zurueckgeben.  Damit das nicht der Fall ist, muessen wir uns den Wert einmal zwischen speichern.  Ich fuehre also eine Variable p ein und in der speichere ich den aktuellen Wert aus unserem Regal an der Stelle i.", "start": 894.6, "end": 923.6}, {"text": "  Dann setze ich die Stelle i im Regal auf null und gebe anschliessend das, was ich mir in meiner Variable p gespeichert habe, zurueck.  Nun muessen wir noch einen weiteren Fall beachten.  Wir gehen hier immer davon aus, dass an der Stelle i im Regal ein gueltiges Produkt steht, auf dem wir die GetName-Methode aufrufen koennen.", "start": 923.6, "end": 942.6}, {"text": "  Haben wir allerdings ein leeres Regal? So ist this.regal an der Stelle i null.  Und wenn wir die GetName-Methode auf null aufrufen, erhalten wir ein Fehler.  Deshalb muessen wir vorher ueberpruefen, dass diese Stelle eben genau nicht null ist.  Das wollen wir in einer If-Bedingung davor abfangen.  Wir ueberpruefen also ist diese Stelle in unserem Array gleich null.", "start": 942.6, "end": 978.6}, {"text": "  Und wenn dem der Fall ist, dann wollen wir diese Stelle gar nicht mehr untersuchen, denn da kann unser Produkt gar nicht sein.  Um den Schleifendurchlauf zu ueberspringen, gibt es das Schluesselwort continue.  Ist also die Stelle i in dem Regal leer?  Dann gehen wir in den naechsten Schleifendurchlauf.  Ist die Stelle nicht leer?  Ich koennte hier zum Beispiel auch ein else if schreiben.", "start": 979.6, "end": 1001.6}, {"text": "  Dann ueberpruefe ich den Namen des Produktes.  Ob dieser gleich ist mit dem Namen, den ich hier oben als Parameter bekommen habe.  Und falls ja, gebe ich eben dieses Produkt zurueck.  Und loesche das Produkt aus dem Regal.  Nun muessen wir als letztes noch entscheiden, was wir tun, wenn das Produkt nicht gefunden wurde.", "start": 1001.6, "end": 1023.6}, {"text": "  Wurde das Produkt nicht gefunden, kommen wir wie bei unserer Lieferung-Methode am Ende der Vorschleife raus.  Wir koennen hier also wieder eine Fehlermeldung ausgeben.  Diese koennte zum Beispiel lauten, das Produkt, jetzt folgt der Produktname, der steht hier in Name, konnte nicht gekauft werden.", "start": 1023.6, "end": 1061.6}, {"text": "  Da wir in dieser Methode allerdings immer etwas vom Typ Produkt zurueckgeben muessen, muessen wir auch an dieser Stelle noch einen Return schreiben.  Wir koennen allerdings nicht einfach einen Simikodon setzen, weil wir irgendetwas zurueckgeben muessen.  Also muessen wir einen Weg finden, ein fehlerhaftes Produkt zurueckzugeben.  Hierbei koennen wir ganz einfach den Initialwert null zurueckgeben.", "start": 1061.6, "end": 1082.6}, {"text": "  Um diese beiden Methoden nun einmal zu testen, werde ich die Main-Methode entsprechend anpassen.  Was habe ich hier nun gemacht?  Ich habe zuerst einen neuen Shop erzeugt.  Dieser hat Regal-Groesse 3.  Dann habe ich 4 Produkte erstellt mit unterschiedlichen Staedten.  Ich habe hier jetzt noch 4 Produkte erstellen koennen.  Ich habe hier jetzt noch 4 Produkte erstellen koennen.", "start": 1105.6, "end": 1126.6}, {"text": "  Was habe ich hier nun gemacht?  Ich habe zuerst einen neuen Shop erzeugt.  Dieser hat Regal-Groesse 3.  Dann habe ich 4 Produkte erstellt mit unterschiedlichen Namen.  Diese habe ich dann alle versucht, dem Regal hinzuzufuegen ueber die Lieferungfunktion.  Und anschliessend habe ich einmal versucht, das Brot zu kaufen und dann die Pizza zu kaufen.", "start": 1126.6, "end": 1155.6}, {"text": " Was erwarten wir also?  Unser Regal ist 3 gross, das heisst die ersten 3 Produkte werden erfolgreich geliefert.  Das vierte Produkt wird nicht erfolgreich geliefert.  Anschliessend kann ich das Brot, welches erfolgreich im Regal gelandet ist, kaufen.  Die Pizza kann ich nicht kaufen, weil diese nicht erfolgreich geliefert wurde.  Die Ausgabe testen wir, indem ich die Main einmal ausfuehre.", "start": 1155.6, "end": 1177.6}, {"text": "  Dazu mache ich rechtsklick auf Test und waehle Run Test.main.  Und wie wir sehen, die Pizza konnte nicht geliefert werden  und somit konnte die Pizza auch spaeter nicht gekauft werden.  Schauen wir uns nach den Aries noch einen weiteren Datentypen an, die Listen.  In Listen sind Objekte von einem bestimmten Datentypen ueber Funktionen miteinander verkettert.", "start": 1181.6, "end": 1212.6}, {"text": "  Der Vorteil hier ist, dass die Laenge der Liste und die Position der Objekte variabel sind.  Der Nachteil allerdings ist, dass fuer Zugriffe immer vordifinierte Funktionen benoetigt werden.  Ausserdem sind Listen fuer viele Anwendungen nicht so effizient wie andere Datentypen, wie zum Beispiel Aries.  In Java gibt es verschiedene Arten von Listen.  Ein paar habe ich hier mal aufgefuehrt.", "start": 1212.6, "end": 1237.6}, {"text": "  Die Linklist ist eine verketterte Liste von Objekten.  In einer Arieslist kann man auf diese Objekte zusaetzlich mit Aries Indizes zugreifen.  Die besonderen Listen Q und Stack schauen wir uns im spaeteren Verlauf noch einmal genauer an.  Am Beispiel der Listen finden sowohl Generics als auch Polymorphie ihre Anwendung.", "start": 1237.6, "end": 1266.6}, {"text": " Um eine neue Liste zu erstellen, verwende ich wieder das Schluesselwort New,  anschliessend den Typen der Liste, in dem Fall zum Beispiel eine Linklist,  und nun folgt in Spitzenklammern den Datentyp, welchen ich in dieser Liste speichern moechte.  Dieser Teil sollte euch von den Generics bekannt vorkommen.  Eine Linklist funktioniert naemlich fuer verschiedene Datentypen gleich.", "start": 1266.6, "end": 1287.6}, {"text": "  Ich moechte also beim Erstellen der Klasse Linklist ein generischen Datentypen fuer die Elemente der Liste verwenden.  Den Datentypen gebe ich dann beim Erstellen der Liste in diesen Spitzenklammern an.  Anschliessend folgen runde Klammern.  Das Ganze moechte ich nun in einer Variable speichern, die List heisst.  Diese Variable kann nun vom Datentyp Linklist sein.", "start": 1287.6, "end": 1309.6}, {"text": "  Nach dem Prinzip der Polymorphie kann sie allerdings auch von dem einfachen Typ List sein.  Auch hier muss ich allerdings wieder den Datentyp angeben, der an der Liste gespeichert ist.  Um nun ein Element der Liste hinzuzufuegen, verwende ich den Namen der Liste, Punkt, Add,  und kann anschliessend in Klammern das Element angeben.", "start": 1309.6, "end": 1329.6}, {"text": "  Moechte ich genauer spezifizieren, wo dieses Element hinzugefuegt wird,  kann ich allerdings auch die Funktion AddFirst oder AddLast verwenden.  Hierbei wird das Element entweder am Anfang der Liste oder am Ende der Liste eingefuegt.  Um ein Element aus der Liste zu loeschen, verwende ich die Methode List, Punkt, Remove.", "start": 1329.6, "end": 1352.6}, {"text": "  Hierbei kann ich die Klammern entweder leer lassen oder den Index des Elements angeben,  was ich loeschen moechte oder das Element selber angeben, was ich loeschen moechte.  Ausserdem habe ich die Moeglichkeit, die Methoden RemoveFirst und RemoveLast zu verwenden,  um das erste oder das letzte Element der Liste zu loeschen.  Die Groesse der Liste erhalte ich mit der Methode Size.", "start": 1352.6, "end": 1378.6}, {"text": "  Im folgenden sollten in unserem Beispiel die Methode-Lieferung so umgeschrieben werden,  dass sie nun nicht ein einzelnes Produkt uebergeben bekommt,  sondern eine ganze Liste von Produkten uebergeben bekommt, die geliefert werden sollen.  Probiert das auch erst einmal selbst und ich zeige euch anschliessend meine Loesung.", "start": 1378.6, "end": 1406.6}, {"text": " Wir wollen also nun die Methode-Lieferung umschreiben,  dass die Anstelle eines einzelnen Produktes eine Liste uebergeben bekommt.  Hier wenden wir nun einen weiteren Traegtier Java-Programmierung an.  Wir koennen naemlich eine weitere Methode definieren,  welche den gleichen Rueckgabetypen hat und den gleichen Namen traegt,  allerdings andere Parameter uebergeben bekommt.", "start": 1406.6, "end": 1429.6}, {"text": "  Hier bekommen wir jetzt eine Liste von Produkten uebergeben,  ich mache das ganze mal mit einer LinkedList  und diese speichert Objekte vom Typ Produkt.  Und das Ganze nennt wir List.  Wenn nun irgendwo die Methode-Lieferung aufgerufen wird,  dann wird ueberprueft, welche Parameter uebergeben wurden.", "start": 1429.6, "end": 1461.6}, {"text": " Wurde eine Liste von Produkten uebergeben, wird diese Methode aufgerufen,  wurde ein einzelnes Produkt uebergeben, wurde diese Methode aufgerufen.  Was wir nun in dieser Methode machen wollen,  ist jedes Produkt dieser Liste einzeln durchgehen und dem Regal hinzufuegen.  Um alle Elemente einer Liste durchzugehen, gibt es in Java die sogenannten ForEach-Schleifen.  Diese sehen folgendermassen aus.", "start": 1461.6, "end": 1481.6}, {"text": "  Sie beginnen auch mit dem Schluesselwort vor,  allerdings lege ich mir anschliessend eine temporaere Variable an,  die den Datentypen hat, welcher in unserer Liste gespeichert ist, in dem Falle Produkt.  Diesen nenne ich hier P.  Dann folgt ein Doppelpunkt und anschliessend der Name der Liste.", "start": 1481.6, "end": 1516.6}, {"text": " Diese Formulierung bedeutet so viel wie fuer jedes Produkt, welches in der Liste gespeichert ist,  fuehre das aus, was hier in der Schleife steht.  Und das, was wir hier machen wollen, ist das Produkt dem Areal hinzufuegen.  Jetzt koennen wir natuerlich noch einmal genau das gleiche schreiben, wie hier unten.  Was wir allerdings auch machen koennen, ist einfach diese Methode hier aufrufen.", "start": 1516.6, "end": 1538.6}, {"text": "  Wir schreiben also Lieferung und uebergeben unser Produkt P.  Da es sich hierbei um eine Methode der Klasse handelt, koennten wir auch this.lieferung schreiben.  Was wir in dieser Methode also tun, ist fuer jedes Produkt, was in dieser Liste steht, Lieferung aufzuhofen.  Wichtig ist, da wir hier ein Produkt uebergeben und keine Liste, ist diese Lieferung gleich der Methode.", "start": 1538.6, "end": 1567.6}, {"text": "  Um das Ganze auch einmal zu testen, werde ich die Main Methode wieder anpassen.  Was habe ich nun veraendert? Ich habe eine neue Liste erzeugt, mit dem Namen Produkte, welche Objekte vom Typ Produkt speichert.  Dann habe ich alle meine vier Produkte dieser Liste hinzugefuegt.  In dem Fall habe ich at last gewaehlt, um das Produkt immer am Ende der Liste einzufuegen.", "start": 1583.6, "end": 1615.6}, {"text": "  Anschliessend habe ich die Methode Lieferung mit dieser Liste aufgerufen.  Das Ergebnis, was wir hier erwarten, ist das gleiche wie vorher.  Testen wir das Ganze noch einmal erneut, rechtsklick auf Test, run test.main.  Und wir sehen, das Ergebnis ist wieder das gleiche.", "start": 1615.6, "end": 1647.6}, {"text": " Wuerden wir hier die Reihenfolge der Produkte aendern, zum Beispiel Produkt 1 als Letztes hinzufuegen,  dann wuerde unser Ergebnis ein anderes werden, weil Produkt 4 nun erfolgreich im Regal gespeichert werden kann.  Ich fuege das Ganze noch einmal aus.  Und wir sehen, diesmal kann Produkt 1, weil es als Letztes hinzugefuegt wird, nicht geliefert werden und anschliessend auch nicht gekauft werden.", "start": 1647.6, "end": 1672.6}, {"text": "  Schauen wir uns nun abschliessend zwei spezielle Listen an. Beginn werden wir mit der Queue.  Die Queue ist eine Liste, die nach dem FirstIn, FirstOut Prinzip arbeitet bzw. kurz FIFO.  Das bedeutet, Elemente, die wir zuerst in die Queue einfuegen, werden auch als Erstes wieder herausgenommen.", "start": 1673.6, "end": 1698.6}, {"text": " Um eine Queue zu benutzen, gibt es zwei wichtige Funktionen, zum einen die Offer-Funktion,  mit der werden Elemente der Queue hinzugefuegt und die Poil-Funktion, mit der werden Elemente wieder aus der Queue herausgenommen.  Eben genau nach diesem FirstIn, FirstOut Prinzip.  Das Ganze wollen wir uns einmal an diesem Beispiel anschauen.", "start": 1698.6, "end": 1711.6}, {"text": "  Hier werden die folgenden Operationen in genau dieser Reihenfolge ausgefuehrt.  Zuerst rufen wir Offer mit der 1 auf, das heisst, die 1 wird der Queue hinzugefuegt.  Anschliessend rufen wir Offer mit 2 auf, die 2 wird der Queue hinzugefuegt, dann wird die 3 der Queue hinzugefuegt  und dann rufen wir noch einmal Offer auf mit der 4, das heisst auch die 4 wird der Queue hinzugefuegt.", "start": 1711.6, "end": 1737.6}, {"text": "  Anschliessend rufen wir das erste Mal Poll auf, das heisst jetzt wird das Element aus der Queue genommen,  welches als Erstes hinzugefuegt wurde, das trifft in dem Fall auf die 1 zu, die 1 wird herausgenommen  und die 2, 3 und 4 verbleibt in der Queue.", "start": 1737.6, "end": 1757.6}, {"text": " Nun wird ein weiteres Mal Poll aufgerufen, das heisst hier wird die 2 aus der Queue genommen,  weil diese als Zweites hinzugefuegt wurde und die 3 und die 4 verbleibt in der Queue.  Nach Ausfuehrung aller Operationen verbleiben also die 3 und die 4 noch in der Queue,  wobei die 3 als naechstes mit der Pollfunktion herausgeholt werden wuerden.  Dann probiert das Ganze doch einmal selbst.", "start": 1758.6, "end": 1777.6}, {"text": "  Fuehrt auf einer leeren Queue bitte einmal folgende Operation in dieser Reihenfolge aus  und ueberlegt, wie die Queue aussieht, nachdem alle Operationen ausgefuehrt wurden.  Nachdem alle Operationen erfolgreich ausgefuehrt wurden, sollte die Queue so aussehen.", "start": 1777.6, "end": 1804.6}, {"text": " Wir haben zuerst die 7 hinzugefuegt, dann die 3, dann die 9,  anschliessend die 7 herausgeholt, die 3 herausgeholt und am Ende noch einmal die 1 hinzugefuegt.  Nachdem alle Operationen erfolgreich ausgefuehrt wurden, sollte die Queue so aussehen.  Wir haben zuerst die 7 hinzugefuegt, dann die 3, dann die 9,  anschliessend die 7 herausgeholt, die 7 herausgeholt und am Ende noch einmal die 7 herausgeholt.", "start": 1807.6, "end": 1824.6}, {"text": "  Die Java-Syntax der Queue sieht hierbei folgendermassen aus.", "start": 1824.6, "end": 1846.6}, {"text": " Um eine neue Queue zu erstellen, gebe ich den Datentypen Queue an,  in Spitzen klammern den Datentypen, den ich in dieser Queue speichern moechte  und gebe einen Namen und rufe hier den Konstruktor auf, indem ich das Schluesselwort New verwende  und jetzt den Linklist-Konstruktor verwende, wie wir ihn bereits kennen,  um Elemente hinzuzufuegen, kann ich nun allerdings die Offer-Funktion verwenden", "start": 1846.6, "end": 1850.6}, {"text": " und um Elemente zu loeschen, die Poll-Funktion.  Die Groesse der Queue laesst sich mit der Methode Sys zurueckgeben.  Der Stack ist auch ein Spezialfall einer Liste.  Er arbeitet allerdings nach dem Prinzip FirstIn LastOut oder kurz Filo.  Das bedeutet, Elemente, die zuerst eingefuegt werden, werden als Letztes wieder herausgenommen.", "start": 1850.6, "end": 1880.6}, {"text": " Um Elemente hinzuzufuegen, benutzen wir beim Stack die Funktion Push,  um Elemente wieder herauszunehmen, benutzen wir die Funktion Pop.  Ein Stack kann man sich, wie der Name schon sagt, also vorstellen wie ein Stapel,  auf dem man immer wieder Dinge draufpackt, allerdings auch Dinge von oben wieder herunter nimmt.", "start": 1880.6, "end": 1895.6}, {"text": "  Eine Queue kann man sich auch, wie der Name schon sagt, vorstellen wie eine Warteschlange,  wo man, wenn man sich als Erster anstellt, auch als Erster rankommt.  Die Funktionsweise des Stacks wollen wir uns einmal an diesem Beispiel angucken.  Zuerst pusche ich die 1 in den Stack, das heisst, die landet ganz unten im Stack.", "start": 1895.6, "end": 1918.6}, {"text": " Anschliessend pusche ich die 2 auf dem Stack, die landet darueber,  dann pusche ich die 3, diese landet auch darueber  und wenn ich die 4 pusche, landet die schliesslich ganz oben im Stack.  Rufe ich nun die Funktion Pop auf, wird das Element herausgeholt,  was es letztes hinzugefuegt wurde, beziehungsweise das, was oben im Stack liegt.  In dem Falle ist das die 4.", "start": 1918.6, "end": 1939.6}, {"text": "  Rufe ich nun nochmal die Pop Funktion auf, wird auch die 3 aus dem Stack herausgeholt.  Nach dem Ausfuehren aller dieser Operationen sieht der Stack also so aus.  Ich wuerde euch nun bitten, das Ganze selbst einmal an diesem Beispiel auszuprobieren.", "start": 1940.6, "end": 1961.6}, {"text": " Hier wird erst die 7 gepusht, dann die 3 gepusht, dann die 9 gepusht,  anschliessend wird zweimal die Pop Funktion aufgerufen  und dann noch einmal die Push Funktion mit der 1.  Wie sieht der Stack nach Ausfuehrung aller dieser Operationen aus?  Wurden alle Operationen erfolgreich ausgefuehrt, sieht der Stack folgendermassen aus.", "start": 1962.6, "end": 1996.6}, {"text": " Zuerst wurde die 7 gepusht, dann die 3 gepusht, dann die 9 gepusht,  die 9 liegt jetzt ganz oben im Stack, das heisst diese wird mit der Pop Funktion zuerst herausgeholt,  anschliessend wird mit der Pop Funktion die 3 herausgeholt  und am Ende noch einmal die 1 auf den Stack gelegt.  Es verbleibt also die 7 ganz unten im Stack und darueber liegt die 1.", "start": 1996.6, "end": 2014.6}, {"text": "  Die Java-Syntax fuer Stacks sieht folgendermassen aus.  Wie bei der Queue gebe ich hier den Datentyp Stack an,  anschliessend folgt in Spitzenklammern der Datentyp der Elemente, die ich speichern moechte  und dann der Name meiner Stack-Variable.", "start": 2015.6, "end": 2037.6}, {"text": " Dem Ganzen weise ich einen neuen Stack zu, indem ich das Schluesselwort New verwende,  hier den Konstruktor vom Stack aufrufe und in Spitzenklammern den Datentyp meiner Elemente.  Anschliessend wieder Runde klammern.  Um nun Elemente hinzuzufuegen, kann ich die Methode Push des Stacks verwenden.  Um Elemente zu loeschen bzw. aus dem Stack wieder herauszuholen, kann ich die Pop Methode verwenden.", "start": 2037.6, "end": 2055.6}, {"text": "  Die Groesse des Stacks erhalte ich wieder mit der Size Methode.  Wuerden wir nun annehmen, dass Regal in unserem Shop-Beispiel sei unendlich gross,  koennten wir statt eines Aries auch ein Stack verwenden, um dieses Regal zu realisieren.  Um zu ueben mit Stacks umzugehen, koennt ihr gerne unser Beispiel einmal aendern  und statt eines Aries ein Stack verwenden.", "start": 2057.6, "end": 2080.6}, {"text": "  Ihr muesstet dann allerdings die Methode so umschreiben, dass sie nicht mit einem Aries funktionieren,  sondern mit einem Stack.  Ueberleg vorher allerdings erstmal kurz, welche Probleme damit auftreten koennen.  Stellen wir uns dazu einmal vor, wir moechten nun tausend Produkte in unser Regal einfuegen.", "start": 2080.6, "end": 2110.6}, {"text": "  Ist unser Regal ein Stack, landet also Produkt 1 ganz unten, darueber Produkt 2, darueber Produkt 3 und so weiter und so fort,  bis wir ganz oben Produkt tausend liegen haben.  Moechten wir nun allerdings auf Produkt 1 zugreifen, muessten wir erst alle anderen Produkte vom Stack nehmen,  um eben auf dieses Produkt 1 zugreifen zu koennen.", "start": 2110.6, "end": 2130.6}, {"text": "  In diesem Fall ist ein Stack also nur unnoetig kompliziert und gaenzlich ineffizient.  Deswegen werde ich das Beispiel auch nicht noch einmal zeigen.  In Beispielen wie denen aus der Hausaufgabe ist ein Stack allerdings deutlich besser geeignet.", "start": 2130.6, "end": 2140.6}]}]