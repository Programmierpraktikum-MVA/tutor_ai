[{"lecture": "31624_24_course_video", "Timestamps": [{"text": "  In diesem Video schauen wir uns die Breitensuche und die Tiefensuche auf Grafen an.  Bevor wir mit der Breitensuche und der Tiefensuche beginnen, wollen wir noch einmal kurz die  Prinzipien von Q und Stack wiederholen.  Eine Q ist eine Liste, die nach dem FirstIn, FirstOut-Prinzip oder kurz FIFO funktioniert.", "start": 0.0, "end": 26.0}, {"text": "  Das bedeutet, Elemente, die zuerst eingefuegt werden, werden auch als erstes wieder herausgenommen.  Dazu gibt es die Funktion offer, mit der Elemente hinzugefuegt werden und die Funktion  poll, mit der Elemente wieder herausgenommen werden.  Ein Stack hingegen ist eine Art Liste, die nach dem FirstIn, LastOut-Prinzip funktioniert.", "start": 26.96, "end": 46.96}, {"text": "  Das heisst, Elemente, die zuerst eingefuegt werden, werden auch als letztes wieder herausgenommen.  Dazu gibt es die Funktion push, mit der ich Elemente zum Stack hinzufuege und die Funktion pop,  mit der ich das oberste Element aus dem Stack wieder herausnehme.  Nachdem wir diese beiden Datenstrukturen noch einmal wiederholt haben,  koennen wir uns jetzt die Breitensuche anschauen.", "start": 47.92, "end": 69.36}, {"text": "  Die Breitensuche ist eine Methode zum Durchsuchen bzw. durchlaufen eines Grafen.  Dabei werden die Knoten in einer bestimmten Reihenfolge besucht und zwar zuerst in der Breite,  das heisst zuerst alle direkten Nachbarn und anschliessend in der Tiefe.  Die Knoten werden also in der folgenden Reihenfolge besucht.", "start": 70.48, "end": 99.52000000000001}, {"text": " Wenn wir mit dem Knoten 1 starten, dann werden zuerst direkte Nachbarn 2, 3, 4 besucht,  anschliessend deren direkte Nachbarn, also 5, 6, 7, 8 und anschliessend deren direkte Nachbarn 9 und 10.  Knoten, die bereits besucht wurden, werden nicht noch einmal besucht.  Wie gehen wir dabei vor?  Zuerst einmal muessen wir einen Startknoten auswaehlen, von dem aus wir die Breitensuche ausfuehren wollen.", "start": 101.12, "end": 117.92}, {"text": "  Diesen Startknoten fuegen wir nun in eine leere Queue hinzu.  Anschliessend gehen wir in eine Schleife bis diese Queue leer ist.", "start": 117.92, "end": 139.36}, {"text": " Innerhalb dieser Schleife nehmen wir zuerst das erste Element aus der Queue,  markieren dieses Element als Besucht,  dann koennen wir noch gegebenenfalls weitere Aktionen ausfuehren  und am Schluss fuegen wir alle benachbarten Knoten dieses Elements,  die noch nicht besucht wurden, in die Queue hinzu.", "start": 141.68, "end": 147.60000000000002}, {"text": " Versucht nun bitte einmal selbst herauszufinden,  in welcher Reihenfolge die Knoten dieses Grafen besucht werden.  Der Startknoten ist der Knoten A.  Hierbei koennte entweder das Prinzip der Breitensuche anwenden  oder direkt schon den Algorithmus als Handsimulation durchfuehren.  Ich werde anschliessend die Handsimulation des Algorithmus einmal zeigen.", "start": 148.72, "end": 182.56}, {"text": "  Auf diesen Grafen wollen wir also nun die Breitensuche ausfuehren.  Dazu benoetigen wir eine Queue.  Ausserdem merke ich mir hier auch noch, welchen Knoten ich besucht habe.  Der Algorithmus beginnt damit, unseren Startknoten in dem Falle A in die Queue hinzuzufuegen.  An dieser Stelle habe ich noch keinen Knoten besucht.  Nun gehe ich in die Schleife, die so lange laeuft bis meine Queue leer ist.", "start": 182.56, "end": 212.32}, {"text": "  Im ersten Schritt nehme ich das erste Element aus der Queue in dem Falle A  und fuege alle Nachbarknoten von A hinzu, also B, C und D.  Ist hier keine bestimmte Reihenfolge angegeben,  koennen wir die Nachbarknoten B, C und D in beliebiger Reihenfolge in die Queue einfuegen.", "start": 213.28, "end": 235.2}, {"text": " Meistens ist die Aufgabe allerdings so formuliert,  dass die Knoten in lexikografischer Reihenfolge abgearbeitet werden sollen.  Das heisst, ich fuege die Nachbarknoten in alphabetischer Reihenfolge, also erst B,  dann C und dann D in die Queue hinzu.  Damit ist diese Iteration auch schon abgeschlossen.", "start": 235.76, "end": 255.28}, {"text": " Als naechstes hole ich also wieder mein erstes Element aus der Queue,  das ist in dem Falle B, da die Queue nach dem Prinzip FirstIn, FirstOut funktioniert.  In der Queue bleibt weiterhin C und D, weil ich diese Elemente noch nicht aus der Queue geholt habe.  Und jetzt fuege ich noch alle Nachbarn von B hinzu, die noch nicht besucht wurden.  Alle Nachbarn waeren A, E und F.", "start": 256.72, "end": 276.96}, {"text": "  Da ich allerdings A schon besucht habe, werden nur E und F der Queue hinzugefuegt.  Dann bin ich mit diesem Schleifendurchlauf fertig.  Ich kann also wieder das naechste Element aus der Queue holen, das ist in dem Falle C.  Alle anderen Elemente bleiben in der Queue, also D, E und F.  Und jetzt fuege ich noch alle Nachbarn von C hinzu, die noch nicht besucht wurden.", "start": 279.84, "end": 303.68}, {"text": "  Die Nachbarn von C sind A und G, A habe ich bereits besucht, das heisst ich fuege nur G der Queue hinzu.  Dann gehe ich in den naechsten Schleifendurchlauf.  Das erste Element in meiner Queue ist D, das heisst das wird herausgeholt.  E, F und G verweilen in der Queue.  Und ich fuege alle Nachbarn von D hinzu, die noch nicht besucht wurden.  Das sind in unserem Grafen H und I.", "start": 305.44, "end": 327.04}, {"text": "  Dann hole ich E aus der Queue.  F, G, H und I bleiben in der Queue.  Und jetzt fuege ich noch alle Nachbarn von E hinzu, die noch nicht besucht wurden.  E hat nur den Nachbarn B, B haben wir allerdings schon besucht.  Das heisst wir fuegen keinen neuen Knoten in die Queue hinzu.  Nun holen wir das F aus der Queue.  G, H und I bleiben in der Queue.", "start": 329.04, "end": 358.15999999999997}, {"text": "  Und wir fuegen alle Nachbarn von F hinzu, die noch nicht besucht wurden.  F hat die Nachbarn B und J, B wurde schon besucht, das heisst wir fuegen nur J hinzu.  Nun holen wir wieder das naechste Element aus der Queue.  Das ist das G, H, I und J bleibt in der Queue.  Jetzt fuegen wir noch alle Nachbarn von G hinzu, die noch nicht besucht wurden.", "start": 358.15999999999997, "end": 381.28}, {"text": "  Das ist in dem Falle kein Nachbar, da C schon besucht wurde.  Das heisst wir gehen in den naechsten Schleifendurchlauf.  Hier holen wir dann H aus der Queue.  I und J bleibt in der Queue.  H hat nur den Nachbarn D, D wurde schon besucht.  Das heisst ich fuege kein neues Element der Queue hinzu.  Nun hol ich noch I aus der Queue.  J bleibt in der Queue.  I hat nur den Nachbarn D, D ist nicht besucht.", "start": 381.28, "end": 407.36}, {"text": "  I hat nur den Nachbarn D, D habe ich schon besucht.  Das heisst ich fuege auch kein neuen Knoten der Queue hinzu.  Nun hol ich noch J aus der Queue.  Die Queue ist jetzt leer.  Ich ueberpruefe die Nachbarn von J, J hat nur den Nachbarn F.  F habe ich bereits besucht, das heisst ich fuege nichts Neues der Queue hinzu.  Nun ist die Queue leer.  Ich kann kein neues Element aus der Queue nehmen.", "start": 407.36, "end": 423.36}, {"text": "  Das heisst mein Algorithmus ist fertig.  Nun ist die Queue leer.  Ich kann kein neues Element aus der Queue nehmen.  Das heisst mein Algorithmus ist fertig.  Die Knoten wurden hier also nun nach der Reihenfolge A, B, C, D, E, F, G, H, I, J besucht.  Wenn wir uns das ganze hier oben im Grafen angucken, dann haben wir zuerst A besucht.  Dann alle direkten Nachbarn von A, also B, C, D.", "start": 423.68, "end": 459.6}, {"text": "  Dann deren direkte Nachbarn, also E, F, G, H, I und anschliessend die naechste Ebene, J.  Wir sind also erst in die Breite gegangen, B, C, D und anschliessend einen Schritt in die Tiefe.  Je nachdem in welcher Reihenfolge wir die Nachbarnknoten der Queue hinzufuegen,  kommen wir also auf die folgenden Reihenfolge, in der die Knoten besucht werden.", "start": 459.6, "end": 482.96}, {"text": "  Schauen wir uns dazu im Vergleich nun einmal die Tiefensuche an.  Die Tiefensuche ist auch eine Methode zum Durchsuchen bzw. durchlaufen eines Grafen.  Die Tiefensuche sucht, wie der Name schon sagt, allerdings zuerst in der Tiefe und anschliessend in der Breite.  Das wuerde in dem folgenden Beispiel folgendermassen aussehen.", "start": 482.96, "end": 504.0}, {"text": "  Unser Startknoten, hier unser Wurzelknoten, wird natuerlich wieder als erstes besucht  und anschliessend besuche ich nicht erst seine direkten Nachbarn, sondern gehe erst einen Pfad komplett bis zum letzten Knoten  und untersuche anschliessend den naechsten Nachbarnknoten.", "start": 504.0, "end": 526.0}, {"text": " Das heisst, hier werden die Knoten erst in die Tiefe untersucht, in dem Falle 1, 2, 3, 4  und anschliessend der naechste Nachbarnknoten 5 und dann wieder in die Tiefe 6, 7, 8  und dann der letzte Nachbarnknoten erst als 9.  Das Vorgehen der Tiefensuche ist nun fast identisch zu dem Vorgehen der Breitensuche.", "start": 526.0, "end": 542.0}, {"text": "  Wir muessen uns auch wieder zuerst ein Startknoten auswaehlen, von dem wir diese Suche starten wollen  und anschliessend, wenn wir exakt die gleichen Schritte machen wie bei der Breitensuche,  nur dass wir bei der Tiefensuche ein Stack statt einer Queue verwenden.  Wenn wir also dem Algorithmus der Breitensuche folgen und einfach die Queue durch ein Stack ersetzen, dann haben wir eine Tiefensuche.", "start": 542.0, "end": 565.0}, {"text": "  Um allerdings weitere Informationen, die spaeter in der Hausaufgabe abgefragt werden, einfacher generieren zu koennen,  sehen wir hier ein etwas abgewandelten Algorithmus, der allerdings das gleiche Ergebnis erzeugt.", "start": 565.0, "end": 585.0}, {"text": " Wir fuegen zu Beginn wieder den Startknoten in unseren Stack ein, dann gehen wir in eine Schleife, die so lange laeuft, bis der Stack leer ist  und innerhalb dieser Schleife schauen wir uns zuerst das oberste Element im Stack an, ohne es vom Stack zu nehmen.  Dann koennen wir gegebenenfalls weitere Aktionen durchfuehren.", "start": 585.0, "end": 594.0}, {"text": "  Nun schauen wir uns den naechsten benachbarten Knoten des Elements an, der noch nicht besucht wurde.  Markieren diesen als besucht, fuegen ihn in den Stack hinzu und wenden nun die Tiefensuche auf diesen neuen Stack an.  Anschliessend entferne ich das oberste Element aus dem Stack.  Das Ganze wird hoffentlich klarer, wenn wir uns das an diesem Beispiel noch einmal angucken.", "start": 594.0, "end": 615.0}, {"text": "  Auch hier koennt ihr gerne erst einmal selbst probieren, die Tiefensuche anzuwenden  und anschliessend werde ich eine Handsimulation des eben vorgestellten Algorithmus durchfuehren.  Auch hier werde ich mir die Knoten in der Reihenfolge, wie sie besucht werden, notieren.  Und da ich nun eine Tiefensuche durchfuehre, notiere ich mir den Stack.", "start": 615.0, "end": 656.0}, {"text": "  Nun beginne ich auch erst einmal wieder damit, unseren Startknoten in den Stack hinzuzufuegen, in dem Falle unseren Startknoten A.  Ich schaue mir das naechste Knoten A an.  A verweilt allerdings im Stack und ich fuege den naechsten Nachbarn von A hinzu, das ist in dem Falle B.  Im naechsten Schritt schaue ich mir dann wieder das oberste Element im Stack an, das ist nun B.", "start": 656.0, "end": 683.0}, {"text": "  Das heisst, ich besuche Knoten B, A und B verweilen im Stack und ich fuege den ersten Nachbarn von B hinzu, das ist in dem Falle E.  Nun schaue ich mir das naechste Knoten E an.  Knoten E hat keine Nachbarn mehr, die noch nicht besucht wurden, das heisst, nun kann ich E aus dem Stack loeschen.  Es bleiben also noch A und B im Stack.", "start": 683.0, "end": 703.0}, {"text": "  Im naechsten Schritt schaue ich mir dann den naechsten Nachbarn von Knoten B an, weil B wieder oben im Stack liegt.  Da ich aber B schon besucht habe, werde ich das hier einmal nicht notieren,  sondern nur, indem ich den naechsten Nachbarn von B in den Stack einfuege und das ist F.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist F.", "start": 703.0, "end": 731.0}, {"text": "  Das heisst, der Knoten F wird besucht, A, B und F verweilen im Stack und ich fuege den Nachbarn von F hinzu, das ist in dem Falle J.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist J.  J hat keine Nachbarn mehr, das heisst, ich kann J aus dem Stack loeschen.  Bleiben also noch A, B und F.", "start": 731.0, "end": 750.0}, {"text": "  Nun schaue ich mir F als naechstes an, da ich F aber schon besucht habe, notiere ich das hier wieder nicht.  F hat auch keine Nachbarn mehr, das heisst, es bleiben noch A und B im Stack.  Nun schaue ich mir wieder B an, da ich B allerdings auch schon besucht habe, notiere ich das hier nicht.  B hat nun auch keine Nachbarn mehr, das heisst, es verweilt nur noch A im Stack.", "start": 750.0, "end": 769.0}, {"text": "  Nun schaue ich mir wieder A an, deshalb notiere ich das nicht.  Und fuege den naechsten Nachbarn hinzu, das heisst, ich habe nun A und C im Stack.  Im naechsten Schritt schaue ich mir dann C an.  C hat noch den Nachbarn G, den ich noch nicht besucht habe, das heisst, ich habe nun A, C, G im Stack.  Ich schaue mir wieder das oberste Element im Stack an, das ist G.", "start": 769.0, "end": 797.0}, {"text": "  G hat keine Nachbarn mehr und ist somit vollstaendig abgearbeitet, das heisst, wir koennen es aus dem Stack entfernen  und haben noch A und C im Stack.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist hier C.  C habe ich aber schon abgearbeitet, das heisst, ich notiere das hier nicht noch einmal.", "start": 797.0, "end": 814.0}, {"text": "  Auch C ist nun fertig abgearbeitet, da ich keine Nachbarn mehr hinzufuegen kann, das verweilt also nur noch A im Stack.  Nun schaue ich mir wieder A an.  A hat noch den letzten Nachbarn D, das heisst, ich fuege D nun dem Stack hinzu.  Als naechstes untersuche ich D.  D hat den einen Nachbarn H, den fuege ich dem Stack hinzu.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist hier H.", "start": 814.0, "end": 848.0}, {"text": "  H hat keine weiteren Nachbarn mehr, die ich noch nicht untersucht habe, das heisst, ich kann H nun aus dem Stack loeschen, es bleiben also A und D.  Nun schauen wir uns wieder D an.  D hat noch den Nachbarn I, das heisst, ich fuege I noch dem Stack hinzu.  Nun schaue ich mir das oberste Element aus dem Stack an, das ist hier I.", "start": 848.0, "end": 870.0}, {"text": "  I hat keine weiteren Nachbarn mehr, die ich noch nicht besucht habe, das heisst, ich werde I aus dem Stack loeschen, bleiben noch A und D im Stack.  Nun untersuche ich als naechstes wieder Knoten D.  D hat allerdings jetzt auch keine Nachbarn mehr, die ich noch nicht besucht habe, das heisst, ich loesche D aus dem Stack.  Bleibt also noch Knoten A im Stack.", "start": 870.0, "end": 885.0}, {"text": "  Nun schaue ich mir noch ein letztes Mal Knoten A an.  Knoten A hat allerdings auch keine Nachbarn mehr, die ich noch nicht untersucht habe, das heisst, ich loesche A aus dem Stack und der Stack ist nun leer.  Die Knoten werden durch die Tiefensuche also in der Reihenfolge A, B, E, F, J, C, G, D, H, I besucht.", "start": 885.0, "end": 924.0}, {"text": "  Wenn wir uns das Ganze noch einmal in diesem Grafen anschauen, dann sehen wir, dass zuerst die Knoten in die Tiefe untersucht werden, in der Reihenfolge 1, 2, 3 und dann anschliessend 4, 5 und dann erst der naechste Nachbar von unserem Startknoten A, naemlich in dem Fall erst als sechstes Element.  Ich gehe also zuerst in die Tiefe, anschliessend in die Breite.", "start": 924.0, "end": 940.0}, {"text": "  Nachdem wir nun die Grundlagen der Tiefensuche besprochen haben, schauen wir uns noch zwei weitere Aspekte der Tiefensuche an, und zwar die Pre-Order und die Post-Order-Liste.  In der Pre-Order-Liste landen die Knoten in der Reihenfolge, in der sie das erste Mal entdeckt werden.  Das entspricht der Reihenfolge, in der wir bisher gesagt haben, dass sie besucht werden.", "start": 940.0, "end": 963.0}, {"text": "  In der Post-Order-Liste landen die Knoten allerdings in der Reihenfolge, in der der Knoten selbst und alle seine Nachbarn vollstaendig abgearbeitet wurden.  Das Ganze wollen wir uns dann noch einmal an diesem Beispiel angucken.  Hierauf wollen wir zum einen die Breiten-Suche anwenden und zum anderen die Tiefensuche, in der wir die Pre-Order und die Post-Order-Liste suchen.", "start": 963.0, "end": 996.0}, {"text": "  Versuch das gerne erst einmal wieder selbst und anschliessend zeige ich euch meine Loesung.  Beginn werden wir nun zuerst mit der Breiten-Suche.  Hierzu fuegen wir zuerst unseren Startknoten in dem Falle A der Q hinzu.  Nun hole ich A aus der Q und fuege alle Nachbarn von A hinzu in alphabetischer Reihenfolge, das heisst erst B, dann C und dann D.", "start": 996.0, "end": 1023.0}, {"text": "  Nun hole ich den naechsten Knoten aus der Q, das ist B.  Die Knoten C und D bleiben weiterhin in der Q und ich fuege alle Nachbarn von B hinzu, die ich noch nicht besucht habe und die auch noch nicht in der Q sind.  Das waeren in dem Falle die Knoten E und G.", "start": 1023.0, "end": 1054.0}, {"text": " Nun hole ich den naechsten Knoten aus der Q, das ist hier Knoten C, Knoten D, E und G bleiben in der Q  und jetzt fuege ich noch alle Nachbarn von C hinzu, die noch nicht besucht wurden und noch nicht in der Q sind.  A wurde schon besucht, B wurde schon besucht, D ist schon in der Q, E ist schon in der Q, fehlt also nur noch F.", "start": 1054.0, "end": 1074.0}, {"text": "  Nun hole ich den naechsten Knoten aus der Q, das ist hier D, E, G, F bleibt in der Q  und ich fuege alle Nachbarn von D hinzu, die noch nicht besucht und nicht in der Q sind, da die Nachbarn A, C und F alle schon besucht oder in der Q sind, fuege ich also nichts hinzu.", "start": 1074.0, "end": 1102.0}, {"text": " Nun hole ich als naechstes Knoten E aus der Q, G und F bleibt in der Q  und ich fuege alle Nachbarn von E hinzu, die noch nicht besucht und noch nicht in der Q sind, das trifft hier nur auf den Knoten H zu.  Nun hole ich Knoten G aus der Q, F und H bleibt in der Q  und ich fuege alle Knoten hinzu, die noch nicht besucht und noch nicht in der Q sind, das ist hier Knoten I.", "start": 1102.0, "end": 1126.0}, {"text": "  Nun hole ich Knoten F aus der Q, H und I bleibt in der Q, von F sind schon alle Nachbarn besucht oder in der Q, das heisst hier mache ich nichts weiter.", "start": 1126.0, "end": 1147.0}, {"text": " Stattdessen hole ich als naechstes Knoten H aus der Q, I bleibt in der Q, auch von H wurden schon alle Nachbarn besucht oder sind in der Q,  das heisst auch hier mache ich nichts weiter, hole also im naechsten Schritt Knoten I aus der Q  und da Ihnen keine Nachbarn mehr hat, die ich hinzufuegen kann, ist die Q nun leer.", "start": 1147.0, "end": 1159.0}, {"text": "  Somit ist die breiten Suche abgeschlossen und wir wissen, dass unsere Knoten in der Reihenfolge A, B, C, D, E, G, F, H, I besucht werden.  Schauen wir uns als naechstes die Tiefensuche an.  Jetzt mit einer etwas anderen Notation, da wir nun die Pre-Order und die Post-Order-Liste bestimmen wollen.", "start": 1159.0, "end": 1176.0}, {"text": "  Wir erinnern uns nochmal, die Pre-Order-Liste enthaelt die Knoten in der Reihenfolge, in der sie als erstes entdeckt wurden,  die Post-Order-Liste, die Knoten in der Reihenfolge, in der sie vollstaendig abgearbeitet wurden.  Beginn werden wir hier allerdings auch wieder, indem wir zuerst unseren Startknoten in dem Falle A dem Stack hinzufuegen.", "start": 1176.0, "end": 1196.0}, {"text": "  Nun schauen wir uns das erste Element im Stack an, das ist A, somit haben wir A das erste Mal entdeckt,  das heisst wir fuegen es der Pre-Order-Liste hinzu.  In alphabetischer Reihenfolge fuegen wir nun den ersten Nachbarn in den Stack ein, das ist in dem Falle B,  das heisst unser Stack sieht danach folgendermassen aus.", "start": 1196.0, "end": 1217.0}, {"text": "  Nun schaue ich mir wieder das oberste Element im Stack an, das ist hier B, das heisst ich habe B zum ersten Mal entdeckt und fuege es der Pre-Order-Liste hinzu.  Anschliessend fuege ich den ersten Nachbarn von B hinzu, den wir noch nicht untersucht haben, das ist alphabetisch hier das C.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist hier C.", "start": 1217.0, "end": 1236.0}, {"text": "  Ich sehe C zum ersten Mal, das heisst ich fuege C der Pre-Order-Liste hinzu.  Dann schaue ich mir den ersten Nachbarn von C an, den ich noch nicht untersucht habe, das ist hier das D,  das heisst unser Stack sieht danach folgendermassen aus, A, B, C und dann das D.", "start": 1236.0, "end": 1264.0}, {"text": " Nun schaue ich mir das D an, weil D oben im Stack liegt, D sich zum ersten Mal, das heisst ich fuege es der Pre-Order-Liste hinzu  und nun fuege ich dem Stack den ersten Nachbarn von D hinzu, der noch nicht untersucht wurde, das ist in dem Falle das F.  Mein Stack sieht danach also folgendermassen aus, A, B, C, D, F.  Nun schaue ich mir wieder das oberste Element im Stack an, das ist hier das F.", "start": 1264.0, "end": 1281.0}, {"text": "  Da ich F noch nicht gesehen habe, fuege ich F also der Pre-Order-Liste hinzu.  Nun fuege ich wieder den naechsten Nachbarn von F dem Stack hinzu, den ich noch nicht untersucht habe,  das waeren hier entweder E oder H, alphabetisch waere das also das E.", "start": 1281.0, "end": 1311.0}, {"text": " Nun schaue ich mir das E an, das E sich zum ersten Mal, das heisst es landet in der Pre-Order-Liste  und dann schaue ich welche Nachbarn ich von E noch nicht untersucht habe, das sind G und H,  das heisst ich fuege als erstes alphabetisch G dem Stack hinzu.", "start": 1311.0, "end": 1333.0}, {"text": " Nun schaue ich mir das G an, das G sich zum ersten Mal, es landet also in der Pre-Order-Liste  und nun schaue ich mir auch alle Nachbarn von G an, H und E habe ich noch nicht untersucht,  H ist alphabetisch weiter vorne, das heisst ich fuege H dem Stack hinzu.", "start": 1333.0, "end": 1360.0}, {"text": " Nun schaue ich mir das H an, weil es oben im Stack liegt, ich sehe das das erste Mal,  das heisst ich fuege H der Pre-Order-Liste hinzu und nun schaue ich mir alle Nachbarn von H an,  der einzige Nachbar der noch nicht untersucht wurde ist das E, das heisst ich fuege E dem Stack hinzu.", "start": 1360.0, "end": 1385.0}, {"text": " Nun schaue ich mir das oberste Element an, das ist hier das E,  E habe ich bisher noch nicht gesehen, das heisst es landet in der Pre-Order-Liste  und E hat keinen Nachbarn mehr, die ich noch nicht bearbeitet habe, das heisst E ist nun fertig abgearbeitet,  es landet also in der Post-Order-Liste und wird aus dem Stack entfernt, das heisst mein Stack sieht danach so aus.", "start": 1385.0, "end": 1416.0}, {"text": "  Nun schaue ich mir wieder das H an, auch das H hat jetzt keine Nachbarn mehr, die ich noch nicht abgearbeitet habe,  das heisst ich fuege H der Post-Order-Liste hinzu und entferne H aus dem Stack,  das heisst mein Stack sieht danach folgendermassen aus.", "start": 1416.0, "end": 1442.0}, {"text": " Nun schaue ich mir das G an, G hat keine Nachbarn mehr, die ich noch nicht abgearbeitet habe,  das heisst ich fuege es der Post-Order-Liste hinzu und loesche es aus dem Stack,  das heisst der Stack enthaelt danach nur noch A, B, C, D, F und E.", "start": 1442.0, "end": 1469.0}, {"text": " Nun schaue ich mir noch mal das E an, das E hat jetzt auch keine Nachbarn mehr, die noch nicht abgearbeitet wurden,  das heisst ich fuege es der Post-Order-Liste hinzu und loesche es aus dem Stack, der sieht danach folgendermassen aus.", "start": 1469.0, "end": 1484.0}, {"text": " Nun schaue ich mir erneut das F an, F hat auch keine Nachbarn mehr, die ich noch nicht untersucht habe,  das heisst es landet in der Post-Order-Liste und wird aus dem Stack geloescht, der danach so aussieht.  Nun schaue ich mir das D an, D hat auch keine Nachbarn mehr, die ich noch nicht abgearbeitet habe,  landet also in der Post-Order-Liste und wird aus dem Stack entfernt, der sieht danach so aus.", "start": 1484.0, "end": 1502.0}, {"text": "  Nun ist das naechstes C dran, C hat auch keine Nachbarn mehr, die ich noch nicht abgearbeitet habe,  es landet also in der Post-Order-Liste und A und B bleiben im Stack, das gleiche gilt dann fuer B,  das hat auch keine Nachbarn mehr, die ich noch nicht abgearbeitet habe, bleibt noch A im Stack", "start": 1502.0, "end": 1523.0}, {"text": " und anschliessend entfernen wir auch A aus dem Stack, weil auch das keine Nachbarn mehr hat, welche noch nicht abgearbeitet wurden.  Danach ist der Stack leer und unser Algorithmus ist fertig.", "start": 1523.0, "end": 1548.0}, {"text": " Zuerst entdeckt werden die Elemente also in der Reihenfolge A, B, C, D, F, E, G, H, I, also in der Reihenfolge der Pre-Order-Liste,  vollstaendig abgearbeitet werden sie in der Reihenfolge der Post-Order-Liste, also I, H, G, E, F, D, C, B, A.  In diesem speziellen Fall ist die Post-Order-Liste einfach nur die Pre-Order-Liste in umgekehrter Reihenfolge.", "start": 1548.0, "end": 1559.0}, {"text": "  Das muss allerdings nicht fuer jedes Beispiel so sein.  Probiert noch einmal selbst, die Pre-Order- und die Post-Order-Liste fuer unser vorheriges Beispiel zu erstellen.  Dann werdet ihr sehen, dass die Post-Order-Liste dort nicht die Pre-Order-Liste in umgekehrter Reihenfolge ist.", "start": 1559.0, "end": 1580.0}, {"text": " Nachdem wir nun das Prinzip der Breiten- und der Tiefensuche verinnerlicht haben,  schauen wir uns im naechsten Video abschliessend noch einmal die Hausaufgabe an.", "start": null, "end": 1580.0}]}]