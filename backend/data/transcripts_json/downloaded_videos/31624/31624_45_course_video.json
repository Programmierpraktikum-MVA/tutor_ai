[{"lecture": "31624_45_course_video", "Timestamps": [{"text": "  Dieses Video zeigt, wie man JUnitests mit IDEA erstellt und ein Fortsetzungstell soll auch die Nutzlichter-Solidartiste demonstrieren.  Als Beispiel erstellen wir eine Klasse Matrix, die 2-Dimensionale Integer-Matrizen darstellen koennen.  Als Objektvariable nehmen wir ein 2-Dimensionales Integer-Area, Data, das die Elemente der Matrix enthalten wird.", "start": 0.0, "end": 38.6}, {"text": "  Ich fuege nun einige Methoden ein, die wir benoetigen, aber die im Video keine wichtige Rolle spielen.  Die Groesse der Matrix kann ueber N-Rows und N-Calls festgestellt werden.  Auf die Elemente der Matrix soll ueber Get-Amp-Setter-Methoden zugewuerfen werden, Get-Element und Set-Element.  Damit die Matrix ausgegeben werden kann, wird die Two-String-Methode ueberlal.", "start": 38.6, "end": 63.6}, {"text": "  Wir implementieren auch eine kleine Main-Methode, um den Code starten zu koennen.  Hier wird ein Array mit den Zahlen 1, 2, 3 und 4, 5, 6 erzeugt.  Damit wird der Konstruktor aufgerufen und dann wird das erzeugte Objekt auf den Bildschirmaus gegeben.  Der Aufruf des Konstruktors wird hier natuerlich als Fehler angezeigt, dass es noch keinen Konstruktor gibt.  Der soll nun geschrieben werden.", "start": 63.6, "end": 93.6}, {"text": "  Uebergeben wird ein 2-Dimensionales Integer-Area mit den Daten der Matrix.  Dies wird mit der Clone-Methode in die Objektvariable Data kopiert.  Wir starten die Main-Methode mit Steuerung Shift F10.  Sie sehen hier unten.  Das Ergebnis ist, wie erwartet.  Nun soll ein Share Unit Test fuer die Klasse geschrieben werden.  Zunaechst erzeugen wir einen geeigneten Ordner.", "start": 94.6, "end": 125.6}, {"text": "  Neu Directory nennen wir es Tests.  Und markieren das Verzeitenes als Test-Sources-Route, damit die Idee erweist, dass hier die Tests sind.  Das Schreiben der Tests unterstuetzt die Idee, dass ein Grundgeruest erzeugen werden kann.  Das Generate-Menue erhaelt man mit Rechtsklick und Auswahl von Generate oder dem Shortcut Alt Insert.  Dann waehlt man Tests aus.  Hier steht schon Share Unit 5.", "start": 126.6, "end": 158.6}, {"text": "  Was die Library ist, die wir benutzen wollen.  Falls die noch nicht in dem Modul ist, was beim ersten Mal der Fall ist, klickt man auf Fix.  Die Bibliothek, die hier vorgeschlagen wird, ist auch die Wichtige, die verwendet werden kann.  Hier unten kann man Methoden auswaehlen, fuer deren Lehrers Test Grundgeruest erzeugt werden soll.", "start": 158.6, "end": 189.6}, {"text": "  Hier wurde also die neue Klasse Matrix Test erzeugt, in dem Testordner liegt.  Und hier sieht man die Lehrentests fuer die zwei Methoden N-Rows und N-Cards.  Wir wollen allerdings jetzt einen Test fuer den Konstruktor schreiben.  Test-Konstruktor.  Da erzeugen wir eine Matrix mit zwei Zahlen und drei Spalten wieder.  Rufen den Konstruktor auf.", "start": 189.6, "end": 228.6}, {"text": "  Nun koennen wir zum Beispiel als erstes einmal testen, ob die Matrix die richtige Kurs hat.  Eine Grundmethode von Share Unit Test ist Resort Equals.  Die Vergleich, ob zwei Variablen den gleichen Wert haben.  Und falls es nicht der Fall ist, schlaegt der Testfehl.  Und es wird eine Fehlermeldung ausgegeben.  In unserem Fall sollte die Matrix zwei Zahlen haben.  Also der erwartete Wert ist zwei.", "start": 231.6, "end": 258.6}, {"text": "  Und der tatsaechliche Wert ist der, der von der Methode N-Rows zurueckgegeben wird.  Entsprechende Tests machen wir fuer die Anzahl der Spalten und auch fuer alle Elemente der Matrix.  An dieser Stelle sollten noch mehr Tests implementiert werden.  Zum Beispiel um zu sehen, ob bei Zugriff auf nicht existierende Elemente auch eine Exception geworfen wird.", "start": 262.6, "end": 285.6}, {"text": "  Das lassen wir hierbei Seite und widmen uns dem kritischen Punkt des Konstruktors.  Es muss eine unabhaengige Kopie der uebergebenen Daten erzeugt werden.  Um dies zu testen, erzeugen werden Spalten und auch fuer alle Elemente der Matrix.  Und dann ein Element ab.  Wenn von den Daten eine unabhaengige Kopie erzeugt wurde, darf sich das entsprechende Element von MAD dadurch nicht aendern.", "start": 285.6, "end": 323.68}, {"text": "  Wir testen also, ob die Daten der Matrix zwei  und dann auch, ob das Element von MAD noch den urspruenglichen Wert 17 hat.  Wir koennen den Test mit Steuerungsschifte F10 oder auch ueber dieses gruene Dreieck starten.  Und sehen, dass der Konstruktortest vielgeschlagen ist.  An der kritischen Stelle wird ausgegeben, Konstrukte should make a deep copy.", "start": 323.68, "end": 361.68}, {"text": "  Um den Fehler auf den Grund zu gehen, setzen wir einen Breakpoint,  wo das Element gesetzt wird und starten den Test im Debugmodus.  Nun kann man hier unten die Werte der Objekte sehen.  Zunaechst sind beide Matrizen initialisiert, wie es sein sollte.  Wir gucken in das Datenfeld, die Datenfelder Data, haben unterschiedliche Spaltenadressen.  Es sind also erstmal unabhaengige Kopien.", "start": 361.68, "end": 396.68}, {"text": "  Wir gucken eine eben tiefer.  Hier sind nun die eindimensionalen Errays der Zeilen gespeichert.  Und hier sehen wir nun, dass diese Zeilen identische Speichadressen haben.  Und zwar entspricht das den uebergebenen Erray.  Es wurde also eine sogenannte Shallow Copy gemacht.  Nur die Kopie von Clone reicht nur auf die aeussere Ebene.", "start": 396.68, "end": 434.68}, {"text": " Von den tieferen Ebenen wurden nur die Referenzen kopiert,  um das Problem zu beheben, muss in dem Konstruktor eine tiefe Copy,  eine Deep Copy von einem zweidimensionalen Erray gemacht werden.  Dafuer muss das Erray initialisiert werden.  Und dann mit einer Schleife ueber die Zeilen wird jede Zeile dann mit Clone kopiert.  Wir starten den Test erneut.  Und sehen, dass nun alles wieder freilaeuft.", "start": 434.68, "end": 470.68}, {"text": "  Bei diesem kleinen Beispiel wird die Nuetzlichkeit von JUnit-Tests allerdings nicht richtig deutlich.  Das selbe Ergebnis haette man durch den entsprechenden Code in der MainMethode  und anschliessend in den Bugging erreicht.  Der Vorteil von separatem Test ist, dass das Testen ausgelagert wird  und das Repertoire an Aspekten, die getestet werden, staendig waechst.", "start": 470.68, "end": 492.68}, {"text": "  Und vor allen Dingen, dass die Tests kontinuierlich bei der Entwicklung des Programms  immer wieder einfach ausgefuehrt werden koennen.  Dagegen zeigt die Erfahrung, dass sich das Testen ueber Code in der MainMethode  oft nur auf die neusten Methoden und neusten Aenderungen bezieht.", "start": 492.68, "end": 510.68}, {"text": " Fehler, die in aelteren, urspruenglich funktionierenden Methoden  und neue Aenderungen an anderer Stelle entstehen, bleiben dabei leicht unentdeckt.  Das Fortsetzungsvideo zu JUnit-Tests erweitert das Matrixbeispiel  um diesen Aspekt zu demonstrieren.", "start": 510.68, "end": 518.68}]}]