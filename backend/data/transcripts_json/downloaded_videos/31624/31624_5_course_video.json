[{"lecture": "31624_5_course_video", "Timestamps": [{"text": "  In diesem Video werden wir uns mit dem Thema Haching beschaeftigen.  Beginnen wir damit, uns das Prinzip von Haching bzw. der Hatchfunktion anzuschauen.  Eine Hatchfunktion wird dazu verwendet, ein Objekt, was oft viele Attribute und Methoden haben kann,  in eine kompaktere Repraesentation zu bringen, in diesem Fall eine Zahl bzw. ein Hatchwert.", "start": 0.0, "end": 32.0}, {"text": "  Mit einer entsprechenden Hatchfunktion kann also jedem Objekt eine eindeutige Zahl ein eindeutiger Hatchwert zugeordnet werden.  Dieser ist fuer das selbe Objekt immer der gleiche.  Fuer andere Objekte, auch wenn sie von der gleichen Klasse sind, ist der Hatchwert ein anderer.  Somit erhaelt jedes Objekt eine kompakte und eindeutige Identifikationsnummer.", "start": 32.0, "end": 52.0}, {"text": "  An eine gute Hatchfunktion stellen wir die folgenden Anforderungen.  Zum einen die Anforderung der Suektivitaet.  Eine Hatchfunktion sollte naemlich den ganzen Wertebereich voll ausnutzen.  Die zweite Anforderung ist das Chaos.  Sollte sich ein Objekt auch nur geringfuegig aendern, dann soll ein komplett anderer Hatchwert erzeugt werden.  Punkt 3 ist die Gleichverteilung.", "start": 52.0, "end": 79.0}, {"text": "  Alle Hatchwerte innerhalb des Wertebereiches sollten gleich oft vorkommen.  Der letzte Punkt ist die Effizienz.  Da Hatchfunktion oft verwendet werden, um Algorithmen effizienter zu gestalten,  muss auch der Hatchwert sehr schnell und einfach zu berechnen sein.", "start": 80.0, "end": 101.0}, {"text": " Wo findet dieses Hatching nun in der Realitaet Anwendung?  Ein Beispiel hierfuer ist, wenn ihr grosse Dateien aus dem Internet herunterladet  und am Ende ueberpruefen wollt, ob die Datei fehlerlos uebertragen wurde.", "start": 101.0, "end": 118.0}, {"text": " Ihr koennt dann einfach einen Hatchwert oder eine sogenannte Pruefsumme ueber die Datei berechnen  und wenn diese dann mit der Pruefsumme uebereinstimmt, dann wurde die Datei erfolgreich und vollstaendig uebertragen.  Ein weiteres Anwendungsgebiet ist die Kryptologie.", "start": 118.0, "end": 131.0}, {"text": " Hier wird Hatching vor allem verwendet, weil die Hatchwertberechnungen oft nicht invertierbar sind  und somit Schluesse, die Hatching verwenden, schwer zu knacken sind.  Ein weiterer Anwendungsbereich, den wir uns gleich noch im Detail anschauen wollen, sind die Hatchtabellen.  Hier verwenden wir den Hatchwert eines Objektes, um eine bestimmte Position fuer das Objekt zu bestimmen.", "start": 131.0, "end": 147.0}, {"text": "  Schauen wir uns das wie gesagt aber nun noch einmal im Detail an.  Hatchmaps sind Aries von einer festen Groesse.  Auf Hatchmaps sind dann die folgenden Funktionen definiert.  Mit der Funktion Add kann ich Objekte in die Hatchmap hinzufuegen.  Mit der Funktion Remove Objekte aus der Hatchmap herausholen.  Mit der Funktion Resize kann ich die Groesse der Hatchmap veraendern.", "start": 147.0, "end": 174.0}, {"text": "  Und mit der Funktion Contains kann ich ueberpruefen, ob ein Objekt in der Hatchmap vorhanden ist.  Der grosse Unterschied zu einem Array oder auch einer Liste ist,  dass Objekte, wenn sie mit der Add Funktion hinzugefuegt werden, an die Stelle im Array gespeichert werden,  die dem Hatchwert des Objektes entspricht.", "start": 174.0, "end": 194.0}, {"text": " Damit ist der Zugriff auf diese Objekte sehr schnell,  da die Position bekannt ist, sobald man den Hatchwert berechnet hat.  Schauen wir uns das Ganze allerdings mal an einem Beispiel an.  Wir wollen nun die Werte 3, 7, 11 und 14 in eine Hatchtabelle der Groesse 5 einfuegen.  Die Hatchfunktion h von k, die wir dazu verwenden, ist k modulo 5.", "start": 195.0, "end": 216.0}, {"text": "  Das bedeutet, wir nehmen den Wert, den wir in unsere Hatchtabelle einfuegen wollen,  nehmen diesen modulo 5 und dieser Hatchwert, den wir dann erhalten,  ist der Index, an dem wir unseren Wert speichern wollen.  Probiert diese Aufgabe gerne erst einmal selbst zu loesen und anschliessend zeige ich euch die Loesung.  Beginnen wir nun damit, den Wert 3 in unsere leere Hatchtabelle einzufuegen.", "start": 216.0, "end": 254.0}, {"text": "  3 modulo 5 ergibt 3, das heisst der Hatchwert von 3 ist 3  und somit fuegen wir den Wert 3, an Index 3 in unserem Array ein.  Als naechstes wollen wir die 7 einfuegen.  7 modulo 5 ergibt 2, das heisst wir fuegen die 7, an Index 2 in unserem Array ein.  Als naechstes wollen wir die 11 einfuegen.  11 modulo 5 ergibt 1, das heisst ich fuege die 11 anstelle 1 in unserem Array ein.", "start": 254.0, "end": 282.0}, {"text": "  Und abschliessend schauen wir uns noch die 14 an.  14 modulo 5 ergibt 4, das heisst ich fuege die 14 anstelle 4 in unserem Array ein.  Noch einmal kurz zur Wiederholung.  Die Modulo-Operation kann man sich vorstellen, als der Rest einer ganzzahligen Teilung.  Das heisst ich teile in diesem Fall meine Zahl durch 5 und der Rest der uebrig bleibt ist mein Ergebnis.", "start": 282.0, "end": 310.0}, {"text": "  Modulo-Operatoren werden gern verwendet fuer Hatchfunktion, da so sichergestellt wird,  dass ich keine Indizes groesser als mein Area halte.  Schauen wir uns nun noch eine zweite Aufgabe an.  Nun sollen die Werte 5, 6, 7, 9 und 10 in eine leere Hatch-Tabelle der Groesse 5 eingefuegt werden.  Die Hatchfunktion dazu lautet wieder h von k ist gleich k modulo 5.", "start": 310.0, "end": 339.0}, {"text": "  Probiert das gerne erst einmal wieder selbst, anschliessend zeige ich euch die Loesung.  Beginn wir damit den Wert 5 in unsere leere Hatch-Tabelle einzufuegen.  5 modulo 5 ergibt 0, das heisst ich speicher den Wert 5 an Index 0.  Als naechstes moechte ich die 6 einfuegen.  6 modulo 5 ergibt 1, das heisst ich fuege die 6 anstelle 1 in unserem Array ein.  Dann folgt die 7.  7.", "start": 350.0, "end": 384.0}, {"text": "  Modulo 5 ergibt 2, das heisst ich fuege die 7 anstelle 2 in unserem Array ein.  Nun folgt noch die 9.  9 modulo 5 ergibt 4, das heisst die 9 landet anstelle 4 in unserem Array.  Und abschliessend wollen wir noch die 10 einfuegen.  10 modulo 5 ergibt 0, das heisst wir muessen die 10 anstelle 0 in unserem Array speichern.  Jetzt sehen wir allerdings schon ein Problem.", "start": 385.0, "end": 406.0}, {"text": "  Anstelle 0 in unserem Array steht bereits die 5.  Hier muessten wir nun allerdings auch unsere 10 speichern.  Was wir in solchen Faellen machen koennen, zeige ich euch nun.  In unserem letzten Beispiel kam es naemlich zu einer sogenannten Kollision.  Diese treten auf, wenn zwei Werte bzw. Objekte den gleichen Hatchwert aufweisen  und dann beide der Hatchmap hinzugefuegt werden.", "start": 407.0, "end": 438.0}, {"text": "  Diese wuerden dann naemlich auf der gleichen Position einsortiert werden  und sich somit gegenseitig ueberschreiben.  Eine Moeglichkeit, um auf solche Kollisionen zu reagieren,  ist der Separate Chaining Ansatz.  Hier erzeugen wir fuer jede Stelle in der Hatchmap eine Liste.  Wenn nun Werte bzw.", "start": 438.0, "end": 460.0}, {"text": "Objekte mit dem gleichen Hatchwert hinzugefuegt werden,  dann werden diese hintereinander in der Liste an dieser Stelle gespeichert.  Wie machen wir das Ganze genau?  So nun ein Element der Hatchmap hinzugefuegt werden,  berechnen wir den Hatchwert und dann fuegen wir das Element der Liste an der Position im Array hinzu,  die dem Hatchwert entspricht.", "start": 461.0, "end": 482.0}, {"text": " Wenn wir nun ein Element wieder loeschen wollen,  dann gehen wir die Liste an der Array Position durch, die dem Hatchwert entspricht  und durchsuchen diese gesamte Liste nach dem Element, was wir entfernen wollen.  Genauso muessen wir bei der Contains Funktion vorgehen.", "start": 482.0, "end": 499.0}, {"text": " Wir berechnen wieder den Hatchwert,  gehen dann an die Position in diesem Array, dort haben wir eine Liste stehen  und diese koennen wir dann nach unserem Element durchsuchen.  Das Ganze moechte ich einmal an folgendem Beispiel zeigen.  Auch hier haben wir wieder eine Hatchmap der Groesse 5  und die gleiche Hatchfunktion wie zuvor,  also k modulo 5.", "start": 500.0, "end": 514.0}, {"text": "  Und nun moechten wir die folgenden Operationen ausfuehren.  Wir moechten zuerst in der Reihenfolge die 10, 3, 8, 13 und 7 hinzufuegen  und anschliessend die 3 und die 13 wieder loeschen.  Sollten dabei Kollisionen auftreten,  dann loesen wir diese mit dem Separate Chaining Ansatz.  Beginnen wir damit den Wert zu zueinander.  Beginnen wir damit den Wert 10 in unsere Hatchfunktion einzufuegen.", "start": 514.0, "end": 544.0}, {"text": "  10 modulo 5 ergibt 0,  das heisst ich fuege die 10 in meine Liste ein, die an Position 0 steht.  Nun moechte ich die 3 einfuegen, 3 modulo 5 ergibt 3,  das heisst ich fuege die 3 der Liste hinzu, die an Position 3 steht.  Als naechstes moechte ich die 8 hinzufuegen, 8 modulo 5 ergibt auch 3  das heisst ich fuege die 8 der Liste an Position 3 hinzu.", "start": 544.0, "end": 576.0}, {"text": "  Nun moechte ich noch die 13 hinzufuegen, auch 13 modulo 5 ergibt 3,  das heisst auch die 13 wird der Liste anstelle 3 in meiner Hashmub hinzugefuegt.  Abschliessend moechte ich noch die 7 hinzufuegen, 7 modulo 5 ergibt 2,  das heisst ich speichere die 7 in der Liste, die an Position 2 in meiner Hashmub steht.", "start": 576.0, "end": 601.0}, {"text": "  Nun moechte ich die 3 aus meiner Hashmub loeschen, das bedeutet ich berechne erst meine Hashfunktion,  3 modulo 5 ergibt 3, das heisst ich muss die Liste an Position 3 in meiner Hashmub durchsuchen,  nach dem Element 3 und dieses dann loeschen.  Das Element 3 ist direkt das erste Element, das heisst ich kann dieses nun aus der Liste loeschen.", "start": 601.0, "end": 621.0}, {"text": "  Nun moechte ich noch die 13 loeschen, hier gehe ich genauso vor,  ich berechne den Hashwert, der Hashwert von 13 ist 3,  das heisst ich durchsuche meine Liste an Position 3 in meiner Hashmub,  mein erstes Element ist 8, 8 ist nicht 13, das heisst ich gehe zum naechsten Element  und mein naechstes Element ist die 13, das heisst ich kann dieses dann loeschen.", "start": 621.0, "end": 645.0}, {"text": "  Nun bin ich fertig mit all meinen Operationen und das ist die daraus resultierende Hashmap.  Der separate Chaining Ansatz bringt allerdings ein grosses Problem mit sich.  Wenn wir mehrere Elemente in einer Liste haben,  dann wissen wir nicht in welcher Reihenfolge diese Elemente in dieser Liste stehen.  Das bedeutet wir koennen jetzt auch nicht mehr effizient auf diese Elemente zugreifen.", "start": 645.0, "end": 668.0}, {"text": "  Der Vorteil von Hashmub im Allgemeinen ist ja,  dass die Position meiner Elemente bekannt sind,  da ich den Hashwert davon berechnen kann.  Das heisst Zugriffe auf diese Elemente funktionieren in konstanter Laufzeit.  Muss ich allerdings fuer jede Position erst einmal die gesamte Liste durchsuchen,  dann entspricht meine Laufzeit immer der Laenge der Liste.", "start": 668.0, "end": 693.0}, {"text": "  Um das Verwenden von Listen zu vermeiden, gibt es noch den Ansatz des linearen Sondierens.  Hier werden Werte bzw. Objekte nicht in einer Liste an der Position beantragen.  Sondern wir speichern die Werte bzw. Objekte an der naechsten freien Stelle in der Hashmap.  Das funktioniert wie folgt.", "start": 694.0, "end": 714.0}, {"text": " Moechte ich ein Element hinzufuegen, berechne ich erst einmal wieder den Hashwert  und untersuche die Stelle in meinem Array.  Wenn diese Stelle leer ist, dann fuege ich mein Element an dieser Stelle ein.  Wenn diese Stelle nicht frei ist,  dann suche ich die naechste freie Stelle und fuege dort mein Element ein.", "start": 714.0, "end": 730.0}, {"text": " Moechte ich nun ein Element wieder loeschen,  da muss ich auch erst einmal wieder den Hashwert berechnen  und dann beginne ich an dieser Stelle im Array nach dem Element zu suchen.  Wenn mein Element nicht an der Stelle im Array steht, die dem Hashwert entspricht,  dann muss ich die darauffolgenden Elemente ueberpruefen.  Und das solange, bis ich mein Element gefunden habe.", "start": 730.0, "end": 748.0}, {"text": "  Dieses kann ich dann loeschen  und dann muss ich gegebenenfalls darauffolgende Elemente ueberpruefen.  Und dann muss ich gegebenenfalls darauffolgende Elemente aufruecken lassen,  wenn sie das naeher an ihren Hashwert bringen wuerde.  Moechte ich nur ueberpruefen, ob ein Element in der Hashmap enthalten ist.  Da beginne ich auch wieder an der Stelle des Hashwertes nach dem Element zu suchen.", "start": 748.0, "end": 771.0}, {"text": "  Und wenn es sich nicht an dieser Stelle befindet,  gehe ich immer ein Element weiter und das solange, bis ich ein leeres Feld gefunden habe.  Dann kann ich die Suche stoppen.  Das Ganze moechte ich auch noch einmal an demselben Beispiel zeigen.  Hier beginnen wir nun auch damit, den Wert 10 in unsere Hashmap hinzuzufuegen.  10 modulo 5 ergibt 0.", "start": 771.0, "end": 800.0}, {"text": "  Position 0 in unserem Array ist noch frei, das heisst, ich speichere mein Wert 10 an dieser Stelle.  Nun gehen wir ueber zur 3.  3 modulo 5 ergibt 3.  Position 3 in unserem Array ist noch frei, das heisst, ich kann meine 3 hier speichern.  Als naechstes moechte ich die 8 hinzufuegen.  8 modulo 5 ergibt 3.", "start": 801.0, "end": 824.0}, {"text": " Die Position 3 in meinem Array ist allerdings schon belegt,  das heisst, ich muss die 8 nun an die naechste freie Position hinzufuegen.  Ich ueberpruefe also als naechstes Position 4.  Die ist frei, das heisst, ich kann hier meine 8 einfuegen.  Nun moechte ich noch die 13 einfuegen.  13 modulo 5 ergibt 3.", "start": 824.0, "end": 842.0}, {"text": "  Position 3 in meinem Array ist allerdings leider schon belegt, das heisst, ich schaue auf die naechste Position.  Position 4 ist allerdings auch schon belegt, das heisst, ich muss mir die naechste Position anschauen.  Da ich hier am Ende meines Arrays angekommen bin, muss ich wieder zurueck zum Anfang.  Ich schaue mir also als naechstes Position 0 meines Arrays an.  Diese ist auch schon belegt.", "start": 842.0, "end": 860.0}, {"text": "  Das heisst, ich ueberpruefe als naechstes Position 1.  Die ist dann frei.  Das heisst, ich kann meine 13 hier einfuegen.  Abschliessend moechte ich noch die 7 einfuegen.  7 modulo 5 ergibt 2.  Position 2 in meinem Array ist noch frei.  Das heisst, ich kann die 7 hier einfuegen.  Nun moechte ich das erste Element aus meiner Hashmap loeschen, und zwar die 3.  Das bedeutet, erstmal muss ich die 3 finden.", "start": 860.0, "end": 887.0}, {"text": "  Ich berechne also den Hashwert von 3, das ist 3,  und beginne anstelle 3 nach der 3 zu suchen.  Ich habe mein Element direkt gefunden, das heisst, ich loesche mein Element,  und nun muss ich alle darauf folgenden Elemente ueberpruefen, ob diese aufruecken muessen.", "start": 887.0, "end": 913.0}, {"text": " Eine einfache Methode, um festzustellen, ob ein Element aufruecken muss, ist,  das Element aus der Hashmap zu loeschen und anschliessend neu hinzuzufuegen.  Ich loesche also die 8,  und fuege diese neu hinzu.  8 modulo 5 ergibt 3, das heisst, das Element landet hier.  Als naechstes muss ich dann fuer die naechste Position ueberpruefen, ob das Element aufrutschen muss.  Das ist hier die 10.", "start": 914.0, "end": 934.0}, {"text": "  Ich loesche also die 10.  10 modulo 5 ergibt 0.  Die Stelle 0 ist noch frei, das heisst, ich fuege die 10 hier ein.  Hier aendert sich also nichts.  Als naechstes ueberpruefe ich die 13.  Ich loesche also die 13.  13 modulo 5 ergibt 3.  Stelle 3 ist schon belegt.  Stelle 4 ist allerdings noch frei, das heisst, ich fuege die 13 an Stelle 4 ein.  Nun ueberpruefe ich noch abschliessend die Position 2.", "start": 934.0, "end": 965.0}, {"text": "  Ich loesche also die 7.  Und 7 modulo 5 ergibt 2.  Das heisst, auch die 7 bleibt bei ihrer Position.  Nun habe ich alle Positionen einmal ueberprueft, das heisst, das Loeschen dieses Elements ist fertig.  Ich muss so lange die darauf folgenden Position ueberpruefen, bis ich entweder einmal durchs Erie gegangen bin oder die erste freie Stelle erwischt habe.", "start": 966.0, "end": 993.0}, {"text": "  Das sehen wir, wenn wir jetzt die 13 loeschen wollen.  Ich berechne erstmal den Hashwert der 13, der ist 3.  An Stelle 3 steht allerdings 8, das heisst, ich ueberpruefe die naechste Stelle.  Hier steht die 13, das heisst, ich loesche die 13 und ueberpruefe nun alle darauf folgenden Positionen.", "start": 994.0, "end": 1024.0}, {"text": "  Die 10 steht bereits an der richtigen Stelle, das sehe ich, wenn ich sie jetzt loeschen und neu hinzufuegen wuerde, dann wuerde ich naemlich 10 modulo 5, also 0, als Hashwert bekommen und die 10 erneut an Stelle 0 einfuegen.  Als naechstes an Position 1 in meiner Hashmap ist jetzt ein leeres Feld, das heisst, ich kann aufhoeren zu ueberpruefen, ob noch Elemente nachruecken muessen.", "start": 1025.0, "end": 1044.0}, {"text": "  Abschliessend wollen wir uns noch ein zweites Beispiel zum linearen Sondieren angucken.  Hier sollen das erste Mal Buchstaben in eine Hashmap eingefuegt werden, und zwar die Buchstaben A, L, G, O, D und T.  Die Hash-Tabelle hat nun Groesse 7 und die Hash-Punktion dazu lautet 11 mal K modulo 7, wobei K die Stelle des Buchstabens im Alphabet ist.", "start": 1045.0, "end": 1070.0}, {"text": "  Sollten Kollisionen auftreten, sollen diese mit des linearen Sondieren geloest werden.  Probiert das gerne erst einmal selbst zu loesen und anschliessend zeige ich euch dann die Loesung.  Der Einfachheit halber habe ich hier fuer jeden Buchstaben noch einmal die Stelle im Alphabet notiert.  Wir beginnen nun damit, den Buchstaben A in die Hashmap einzufuegen.", "start": 1071.0, "end": 1107.0}, {"text": "  Buchstabe A steht an Position 1 im Alphabet, das heisst, ich rechne 11 mal 1 modulo 7.  Das sind also 11 modulo 7 und als Ergebnis erhalte ich 4.  Ich pruefe also Stelle 4 in meiner Hashmap, die ist noch frei, das heisst, ich kann hier mein A einfuegen.  Nun fuege ich es naechstes L ein. L steht an Stelle 12 des Alphabetes.  11 mal 12 ergibt 132, das modulo 7 ergibt 6.", "start": 1108.0, "end": 1139.0}, {"text": "  Ich ueberpruefe also Position 6 in meiner Hashmap, diese ist noch frei, das heisst, ich kann an der Stelle mein L einfuegen.  Nun folgt das G. G steht an Stelle 7 des Alphabetes.  11 mal 7 ist 77, modulo 7 ergibt 0.  Ich ueberpruefe also Stelle 0 in meinem Array, Stelle 0 in meinem Array ist noch frei, das heisst, ich kann dort mein G einfuegen.  Nun schauen wir uns als naechstes das O an.", "start": 1140.0, "end": 1168.0}, {"text": "  O steht an Stelle 15 im Alphabet, 15 mal 11 ergibt 165, modulo 7 ergibt 4.  Ich ueberpruefe also Stelle 4 in meiner Hashmap, diese ist allerdings bereits belegt, das heisst, ich ueberpruefe die naechste Stelle, Stelle 5.  Stelle 5 ist noch frei, das heisst, ich fuege hier mein O ein.  Nun ueberpruefe ich als naechstes D. 4 mal 11 ergibt 44, modulo 7 ergibt 2.", "start": 1169.0, "end": 1196.0}, {"text": "  Ich ueberpruefe also Stelle 2 in meinem Array, Stelle 2 in meinem Array ist noch frei, das heisst, ich kann hier das D einfuegen.  Nun schieben wir an dieser Stelle nochmal die Buchstaben A zwischen, damit das Wort Algodat auch vollstaendig ist.  Das heisst, wir wollen jetzt vor dem T erstmal noch ein A einfuegen.  A steht an Stelle 1 des Alphabetes.  11 mal 1 ergibt 11, modulo 7 ergibt 4.", "start": 1197.0, "end": 1218.0}, {"text": "  Ich ueberpruefe also Stelle 4 in meinem Array, die ist schon belegt.  Ich ueberpruefe also Stelle 5 in meinem Array, die ist auch schon belegt.  Ich ueberpruefe also Stelle 6 in meinem Array, die ist auch belegt.  Dann ueberpruefe ich Stelle 0 in meinem Array, die ist auch belegt.  Und abschliessend Stelle 1 in meinem Array, die ist naemlich frei, das heisst, ich kann in der Stelle mein A einfuegen.", "start": 1218.0, "end": 1241.0}, {"text": "  Nun folgt abschliessend noch das T.  T steht an Stelle 20 des Alphabetes.  20 mal 11 ergibt 220, modulo 7 ergibt 3.  Ich ueberpruefe also Stelle 3 in meiner Hashmap, die ist noch frei, das heisst, ich kann hier mein T einfuegen.  Allerdings ist auch der Ansatz des Linears und die uns nicht perfekt.", "start": 1241.0, "end": 1275.0}, {"text": "  Auch hier kann es sein, dass wir Elemente nicht direkt finden, da Elemente nicht am Index ihres eigentlichen Hashwertes im Array stehen muessen.  Das hinzufuegen und loeschen kann somit sehr zeitaufwendig sein, da man erst einmal eine freie Position finden muss und gegebenenfalls beim loeschen die Position anderer Elemente veraendern muss.  Auch die Funktion resize einer Hashmap ist sehr aufwendig.", "start": 1276.0, "end": 1297.0}, {"text": "  Das sich bei einer Hashmap um ein Array handelt, hat diese eine feste Groesse.  Wenn ich also eine groessere Hashmap erzeugen moechte, muss ich eine komplett neue Hashmap erstellen, die die neue Groesse hat und kann nicht einfach die Alte vergroessern.  Dann muss sich alle Elemente aus der alten Hashmap neu in die neue hinzufuegen.", "start": 1298.0, "end": 1323.0}, {"text": " Warum kann ich nicht einfach alle Elemente rueber kopieren?  Das liegt daran, dass sich bei einer neuen Groesse natuerlich auch die Hashwertete Elemente aendern.  Somit kann es sein, dass die Elemente in der neuen Hashmap an ganz anderen Positionen landen.", "start": 1324.0, "end": 1343.0}, {"text": "  Wir wissen also, wenn wir jetzt lineare Sondieren oder separate Chaining bei Kollision anwenden, dann erhoeht sich auf alle Faelle unsere Komplexitaet und auch das Vergroessern oder Verkleinern einer Hashmap ist sehr zeitaufwendig.  Wie werden diese Probleme also in der Realitaet geloest?  Zum einen werden Hashmaps oft ausreichend gross gewaehlt, um Kollision generell zu vermeiden.", "start": 1344.0, "end": 1360.0}, {"text": "  In Kombination mit gutem Hashfunktion kann man die Objekte und Werte so gleichmaessig ueber die Hashmap verteilen.  Im Fall von Kollision kann man auch mehrere Hashfunktionen, das sogenannte DoubleHashing anwenden, um das neu hinzugefuegte Objekt an einer anderen Stelle zu speichern.  Naemlich an der Stelle, die wir von der zweiten Hashfunktion erhalten.", "start": 1361.0, "end": 1382.0}, {"text": "  Ausserdem werden oft mehr dimensionale Hashtabellen verwendet, um Listen zu vermeiden.  Das bedeutet, es wird ein aehnlicher Ansatz wie beim separate Chaining gewaehlt,  nur dass anstelle einer Liste fuer jeden Eintrag eine weitere Hashtabelle gespeichert wird.", "start": 1383.0, "end": 1393.0}]}]