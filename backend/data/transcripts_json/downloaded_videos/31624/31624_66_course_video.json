[{"lecture": "31624_66_course_video", "Timestamps": [{"text": "  Welcome back. In this video, we will talk about comparable and comparator.  In our previous video, I talked about why we create programs and said that we want to represent the world  and the information about it and to process this information we write code, we write programs.  Now, most of the time we want to take decisions based on information and to do that, we need to compare information.", "start": 0.0, "end": 40.0}, {"text": "  With primitive data types, this is relatively simple. We can use the mathematical formulations and the logical comparators.  But when we have objects with different types of information, then we have to use comparable or comparator.  Because it's not obvious what properties we want to compare.", "start": 40.0, "end": 67.0}, {"text": "And why do we have two different ways to do that?  It's simple. Comparable is the default that you use to order things between the same type of objects.  And comparator is an alternative. And in a practical example, I will show you how to use both.", "start": 69.0, "end": 90.0}, {"text": "  So why do we need an alternative? Because maybe we want a different property to sort things or we need to sort twice information based on different properties.  One sorting is based on color, the other one based on size.  In other times, when you work with a large code base and use external libraries, then you might not have access to the actual implementation of a class.", "start": 90.0, "end": 114.0}, {"text": "  And in that case, you are not able to change the default ordering property.  So you need to have an alternative to use and this is comparator.  And you will see that by using this alternative comparator, we actually can save clutter from our code in the class.  Because this is not going to be implemented in the class itself. So the class logic will stay as it is.", "start": 114.0, "end": 147.0}, {"text": "  And we have the freedom to do different types of comparison in the same code.  So let's have a look at the example.  And we go back to the example of having the main, now it's empty main, and we have a class called cars.  If you remember, we had a property and let's make that now private, which is model, private horsepower.  And let's have another private double price.", "start": 148.0, "end": 194.0}, {"text": "  All right. And let's add a constructor.  Let's say we have something here to generate automatically constructors.  Generate constructor.  And we can choose the fields. And we want to select all of them and look automatically we generated the constructor.  We can also generate automatically a two string method for all of this.", "start": 196.0, "end": 242.0}, {"text": "  Isn't that nice? So we can remove our old print R info to string where we hand coded how we want to describe.  And now with this automatic generation, we have all these here.  Moreover, let's find out what other we can generate and get and set.  If we have private properties, we can't access these outside of the object methods.  So let's just create for all of these a get and set.", "start": 242.0, "end": 282.0}, {"text": "  We have an update. You should always apply updates, but now we will skip that.  So now we have two string methods and setting and getting the attributes of this class.  Now, what should be the default ordering of a car?  Is it the model, horsepower or price?  I would say that horsepower is the default ordering.", "start": 282.0, "end": 321.0}, {"text": " When you see here already arises the question, what should be the default ordering?  And this is the developers choice.  So this is an interface.  So we will implement a comparable for cars.  And let's correct an old mistake by calling this with small c.  Let's rename this rename file.  Classes should start with capital letters.  Great.  Now we have an error.  Let's figure that out.", "start": 321.0, "end": 383.0}, {"text": "  All right, so already that we say that it implements a comparable,  it suggests that we should implement the compare to method.  This will allow us to compare an object with another object of the same type.  How do we do that?  We take one property and return the order which is based on an integer value,  whether the ordering is larger or smaller.", "start": 383.0, "end": 423.0}, {"text": "  Positive will give larger and negative will be smaller.  And zero will show that it is the same.  And we said we want to look at the horsepower.  So as you can see, it has an argument, a car will compare to this new object,  the existing object that will be created and is calling this method.", "start": 423.0, "end": 460.0}, {"text": "  And to apply to the current object, you hold this and we will get horsepower minus object to compare to the...  And we can write horsepower, but this is a private property.  We will not be able to access it, so let's just get this to horsepower.  And as you can see, again, this is red because we try to return something.  Let's see what is the error message.  A double and the required type is int.", "start": 460.0, "end": 498.0}, {"text": "  So let's type cast this to an int.  How to do that?  Let's look it up.  Java type cast double to int.  And it's super simple.  We just need to write in front of it, int parenthesis, int.  And then it will be an integer value.  int and we want to make int both.  So we want to make int the computation, so we add an additional parenthesis.  Right?  Right.  Great.", "start": 498.0, "end": 563.0}, {"text": "  We have also here now something with red.  Let's try to build things and see whether the problems are solved.  Invalid method declaration.  Cars.  Obviously, we need to change that the constructor's name matches the class's name.  And as I changed, I have to apply that.  So let's try to build.  And build was successful.  Amazing.  Let's go to main.", "start": 563.0, "end": 611.0}, {"text": "  And let's assume that we want to buy a car and we check the market and we create a list  of cars.  Cars to buy.  And this is the proper way.  It's an array list of cars.  So let's have a quick look at the cool feature of the IDE.  But this feature is also somewhat dangerous.", "start": 611.0, "end": 659.0}, {"text": " So when I start writing a link list, automatically imports a library, Java utils list, which  is great, so you don't have to care what libraries you need for what functionalities.  These libraries will implement the interface to use a list.", "start": 659.0, "end": 680.0}, {"text": " And when I also declare what type of list I want to use, it will also automatically update  that actually imports everything from utils with that star symbol after java.utils.star.  So what's the danger?  In your homework, you're not allowed to use other than standard libraries in Java.  Like list or ATS or standard libraries.", "start": 680.0, "end": 700.0}, {"text": "  If you include some other libraries by mistake or by automatically using the IDE's feature,  then we will not be able to compile your code and that will result in failing the homework.  So be careful.  Always check what do you import and whether that is allowed for that specific homework.  Great.  And then now let's add to cars to buy some instances of cars.  Let's create a new cars, new car.", "start": 700.0, "end": 752.0}, {"text": "  And let's give the model is dachio, horsepower, 50.  And then price, let's say it's 1200.  And then let's put this column and it already shows again that we are giving a string when it is expecting a double.  Let's make it more fun to press 99.99.  Realistic, right?  What else is the problem?  Method call expected.  So we have to, what do we want?  This list.", "start": 752.0, "end": 805.0}, {"text": "  Now like we are going to construct it, but we actually want to add this to the list, right?  So let's just add a few more.  Let's add a lot on.  It's not that powerful, but it's way cheaper.  And then a BMW, which is the most powerful of them all, but it also costs a lot.  So now we have a list and I want to say that I want to buy the most powerful car.  So cars to buy and I can sort them.", "start": 805.0, "end": 866.0}, {"text": "  And as you can see, it offers sort and it will say that if I want to sort, then I need to have the comparator interface implemented.  And we did that just before.  So that's fine.  Actually, we want to apply this on the collections.  So we call this from the collections class, the sorting method.  And actually I want to apply that on cars to buy.  This is the proper way to do.", "start": 866.0, "end": 918.0}, {"text": "  And then we want to print with a for loop all the cars in this list.  So there is a simple way.  We've seen the for loop that we can have an iterator and see the length.  But there is a nicer way that you can directly iterate on the list.  I'll iterate over list to list.  And let's go with Stack Overflow because we like that.  And let's see if we can find a for loop.  Example, no.", "start": 918.0, "end": 970.0}, {"text": "  So let's go back.  So if you don't find what you want and you know that you want a for loop,  iterator for list.  Seven ways.  Oh my God, that would be amazing.  So simple for loop, that would be the first one.  That's what we were looking for.  Okay, this is one way.  And we are looking for this nicer way.", "start": 970.0, "end": 1029.0}, {"text": " So basically we want to give this, that this is a type of,  this is cars, seeing for loop.  Over the list of cars to buy.  And we will print out, see the string.  And let's run this code.  And there is no ordering applied.  Let's see why does that happen.  And we can check that here.  Let's do a debug.  And we are currently at this line.  Actually to be easier to debug.", "start": 1029.0, "end": 1100.0}, {"text": "  Let's create here a double.  This is difference.  Equal width.  And that's all that we will have temporarily.  The difference property.  And now let's debug this code.  And the difference is minus 20, which is good.  Minus 15, 13.  And that's it.  So the console output.  Is that.  Why so?  So let's try to find what we are doing wrong.  So we want to print line that before sorting.", "start": 1100.0, "end": 1196.0}, {"text": "  And after sorting.  All right.  So we are actually sorting correctly, but in the reverse order.  So there is no mistake here.  Just I want that it's the most expensive at the top.  So what do we do then?  We can multiply this with minus one.  And then the side will flip.  So now the positive.  Change.  Will result the highest, right?  Okay, so after sorting now BMW is at the top.  All right.", "start": 1196.0, "end": 1256.0}, {"text": "  So, now let's assume that we don't have access to this class.  But we have the documentation and we know it's attributes and we know that it has a get function.  So we can get the properties.  So let's try to implement.  Now a different sorting without accessing its property.  So let's create now our own sorting.  That takes not horsepower into account, but the price.  After sorting.  Price.", "start": 1256.0, "end": 1302.0}, {"text": "  This was horsepower.  And now we want to use a different sorting.  And now we need to apply the comparator.  So we will not touch now the class and we keep the defaults as it is because that's how the developer intended it.  The class.  But actually we have a budget and we want to know what is the cheapest to buy.  So we want to use now comparator.  And we want to do that on cars.", "start": 1302.0, "end": 1359.0}, {"text": "  So we create this car comparator.  That will be a new comparator of cars.  So this interface will define how to do that.  And now because this is not within the class implemented, the comparator method receives two cars.  And let's see if we want to return now.  Again let's do the same trick.  So we will make an integer of o1.getPrice minus o2.getPrice.  Alright.", "start": 1359.0, "end": 1434.0}, {"text": "  So now we defined another way to compare instances of cars.  And what we need to do now is to resort our list.  So we again use the collections sorting method on cars to buy.  But we now specify how we want to do that.  And we use this car comparator.  And let's see what is the result of that.  So this is now wronged. This is now price based sorting.", "start": 1434.0, "end": 1492.0}, {"text": "  And let's look at the output. So initially we had this order.  Then we arranged by horsepower and here by price.  Now in a simple example we could have just flipped the order of horsepower.  But if the developer designed this way, then we always give back the ordering in a descending order.  Then we need to create a comparator to have an ordering in a descending order.", "start": 1492.0, "end": 1541.0}, {"text": "  So the main takeaway message is that you can have a default ordering of a list of objects of the same type by using a comparable.  And then you implement that in the class itself to compare two instances of the same type.  But if you need flexibility and you want to do something else than the default,  or you don't have access to the class, then you need to use comparator.", "start": 1541.0, "end": 1563.0}, {"text": "  Thank you for watching. See you next time.", "start": null, "end": 1563.0}]}]