[{"lecture": "31624_71_course_video", "Timestamps": [{"text": "  In Hashtapellen werden Schluesselwertpare gespeichert.  Um einen schnellen Zuhuerf zu implementieren, wird jeden Schluessel ueber eine Haschfunktion  eine Haschadresse zugeordnet.  Unter der Haschadresse wird das Schluesselwertpare gespeichert.  Dabei lassen sich allerdings Kollisionen nicht vermeiden.  Das heisst, dass unterschiedliche Schluessel auf dieselben Haschadressen abgebildet werden.", "start": 0.0, "end": 30.0}, {"text": "  Mehrers hierzu wird in dem Video ueber Haschfunktionen erlaeutert.  In diesem Video geht es um eine Strategie, wie man mit Kollisionen umgeht.  Bei der Aufloesung durch Verkettung auf Englisch-Separate-Chaining  ist jeder Eintrag der Hasch-Stabelle eine verkettete Liste.  Wenn also mehrere Schluessel unter derselben Adresse gespeichert werden,  stellt dies kein Problem dar.", "start": 30.0, "end": 54.0}, {"text": "  Jeder Schluessel wird einfach an die entsprechenden Liste angehaengt.  Zu einem Problem kann es doch werden,  und zwar, wenn sehr viele Schluessel an derselben Liste angehaengt werden.  Dieses Problem besprechen wir spaeter.  Schauen wir uns erst einmal den Ablauf an.  Wir haben eine kleine Hasch-Stabelle der Groesse 7  und eine Haschfunktion der Divisions-Restmethode.", "start": 54.0, "end": 78.0}, {"text": "  Der Schluessel K wird also auf K-Modulo 7 abgebildet.  Die Schluessel stehen in der linken Spalte  und die Hasch-Adressen wurden schon mit der Haschfunktion berechnet.  Die Hasch-Stabelle hat unter jeder der Adressen eine verkettete Liste,  die zu Beginn der ist.  Nun werden der Reihe nach die Schluessel eingefuegt.", "start": 78.0, "end": 102.0}, {"text": " Fuer den Schluessel 9 nehmen wir seine Hasch-Adresse 2  und gehen in die entsprechende Liste.  Dort wird der Schluessel angehaengt.  Fuer den Schluessel 5 gehen wir zur Hasch-Adresse 5  und haengen den Schluessel dort an die Liste.  Der Schluessel 16 hat auch wieder die Hasch-Adresse 2, genau wie der Schluessel 9.", "start": 102.0, "end": 128.0}, {"text": " Wir gehen also zu der Liste, die hier schon existiert, nicht leer ist,  unter der Adresse 2 und haengen den Schluessel an die Liste an.  Der Schluessel 7 kommt in die leere Liste unter der Adresse 0.  Der Schluessel 2 kommt wieder an die schon existierende Liste und wird hinten angehaengt.  Der Schluessel 12 wird an die Liste in der Hasch-Adresse 5 angehaengt.", "start": 128.0, "end": 148.0}, {"text": "  So werden also Schluessel und gegebenenfalls die zu behoerigen Werte  in eine Hasch-Stabelle mit Verkettung eingefuegt.  Sollen uns zum Beispiel der Eintrag zu den Schluessel 16 gesucht werden,  geht man zu der Liste, die unter der entsprechenden Hasch-Adresse gespeichert ist, also hier.  Die Liste wird dann der Reihe nach abgesucht, bis der Schluessel gefunden wird oder eben nicht.", "start": 148.0, "end": 172.0}, {"text": "  Zusammenfassend funktionieren die Methoden folgendermassen.  Zuerst wird immer die Hasch-Funktion auf den gegebenen Schluessel angewendet,  um die Hasch-Adresse und damit die entsprechende Liste zu finden.  Bei der Suche nach einem Schluessel wird die Liste nach dem Schluessel durchsucht.  Wenn er enthalten ist, wird der entsprechende Wert zurueckgegeben.", "start": 172.0, "end": 198.0}, {"text": " Beim Einfuegen, eine Schluessel zu beachten,  dass zunaechst diese Liste durchsucht wird, ob der Schluessel bereits enthalten ist,  falls ja, wird der zugehoerige Wert aktualisiert,  andernfalls wird das Schluessel wertbar an die Liste angehaengt.  Um einen Schluessel zu loeschen, wird der Schluessel in der Liste gesucht  und dann hat der Liste geloescht.", "start": 198.0, "end": 220.0}, {"text": "  Es werden also die jeweiligen Operationen, Suchen, Einfuegen loeschen,  auf die entsprechende Liste angewendet.  Nun betrachten wir die Laufzeit.  Alle Operationen haben eine Worstcase-Laufzeit, die linear in der Laenge der Liste ist.  Hierbei ist es hervorzuheben, dass bei der Suche in den Listen  ein Schluesselvergleich durchgefuehrt werden muss.", "start": 220.0, "end": 242.0}, {"text": "  Wenn Schluessel komplexe Datenschrukturen wie Spielstellungen sind,  kann dies ein sehr aufwendiger Vergleich sein.  Daher ist fuer die Laufzeit eigentlich nur erheblich,  wie viele dieser Schluesselvergleich durchgefuehrt werden muessen.  Unter der Annahme, dass die Hash-Advessentuerk, die Hash-Funktionen gleichemessig verteilt sind,  ist die Laenge der Listen N durch N.", "start": 242.0, "end": 267.0}, {"text": "  Nn ist die Anzahl der Schluessel und M die Groesse der Tabelle.  Die Anzahl der Schluesselvergleich ist fuer alle Operationen also proportional zur N durch N.  Ein Beispiel.  Wenn eine Hash-Tabelle der Groesse 1000 mit 10.000 Schluesseln gleichemessig belegt ist,  hat jede Liste die Laenge 10.  Dann sind fuer jede Operation maximal 10 Schluesselvergleichen notwendig.", "start": 267.0, "end": 296.0}, {"text": "  Wenn anstatt der Hash-Tabelle eine einzige verkettete Liste verwendet wird,  die dann also die Laenge 10.000 hat, sind im Wernstcase 10.000 Schluesselvergleichen notwendig.  Die Hash-Tabelle beschleunigt also in diesem Fall um den Faktor 1000.  Bei Hashingen mit Verkettung wird meist in diesem Beispiel mit einer Ueberbelegung gearbeitet.", "start": 296.0, "end": 321.0}, {"text": "  Die uebliche Strategie ist, den Belegungsgrad N durch M in der Groessenordnung von 5 zu halten.  Um dieses gewaehrleisten wird gegebenenfalls die Groesse der Hash-Tabelle dynamisch angepasst.  So kann die Anzahl der notwendigen Schluesselvergleichen ungefaehr bei 5 gehalten werden,  also in einem komfortablen Bereich der konstanten Aufzeit.", "start": 321.0, "end": 337.0}]}]