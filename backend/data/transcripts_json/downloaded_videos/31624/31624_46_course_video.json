[{"lecture": "31624_46_course_video", "Timestamps": [{"text": "  So, wir machen an der Stelle weiter, an der das erste Video zu JUnitis aufgehoert hat.  Die klasse Matrix soll um weitere Funktionalitaeten erweitert werden.  Und zwar als erstes bekommt es ja eine Methode Transform, die die Matrix vertikal spiegelt.  Die Details der Implementierung sind nicht wichtig.  Ich verspreche, dass die Methode korrekt funktioniert.", "start": 0.0, "end": 29.92}, {"text": "  Die Main Methode wird durch einen Aufruf von Transform erweitert.  Und wir starten.  Sie sehen hier das Ergebnis.  Die Matrix ist vertikal gespiegelt.  Die beiden Zahlen sind hier vertauscht.  Um die korrekte Funktionalitaet auch fuer die Zukunft zu sichern,  fuegen wir einen entsprechenden Test in die klasse Matrix-Test ein.", "start": 33.52, "end": 66.52}, {"text": "  In diesem Test wird einfach eine Matrix definiert und das erwartete Ergebnis,  wo die Matrix vertikal gespielt ist.  Dann wird die Funktion Transform aufgerufen und es wird fuer alle Elemente der Matrix geprueft,  ob das zurueckgegebene Element mit dem erwarteten Element uebereinstimmt.  Und falls dem nicht so ist, wird eine Fehlermeldung ausgegeben.  Wir starten den Test.  Und alles fehlerfrei.", "start": 66.52, "end": 100.8}, {"text": "  Nun gehen wir zurueck zur Matrix-Klasse und erweitern die Transform-Methode  um eine zweite Transformation, horizontale Spiegel.  Zum Aussehen der Transformation definieren wir Konstanten, Mirror V und Mirror H.  Dann spendieren wir der Methode Transform, ein Eingabeargument, Type,  ueber das die gewuenschte Transformation ausgewaehlt werden kann.  Mit Mirror V wird der urspruengliche Kot ausgefuehrt.", "start": 100.8, "end": 143.51999999999998}, {"text": "  Und mit Mirror H wird eine neue horizontale Transformation ausgefuehrt.  Dies ist auch wieder eine korrekte Implementation, der in Details hier nicht relevant sind.  Nun rufen wir in der Main-Methode die neue horizontale Spiegelung auf.  Hier sehen wir jetzt beim Kompilieren einen Fehler in dem Test.  Auch hier muss der Kot schon angepasst werden.", "start": 146.51999999999998, "end": 173.52}, {"text": "  Also muss hier ein Eingabeargument Mirror V angegeben werden.  Nun konnten wir die Main-Methode starten.  Und in der Tat ist das Resultat an der horizontale Spiegelung der Ausgangsmatrix.  Nun erstellen wir einen neuen Test fuer die Funktionalitaet des horizontalen Spiegels.  Dafuer koennen wir das vertikale Spiegel kopieren,  umbenennen und hier natuerlich beim Aufruf beruecksichtigen.", "start": 173.52, "end": 218.52}, {"text": "  Und ansonsten wird hier nun das Ausgabeargument geaendert.  Das erwartete Argument geaendert.  Hochzeitige Spiegelung ist das 321 und 654.  Test gestartet.  Auch hier alles korrekt.  Gehen wir zurueck zu der Matrix-Klasse.  Wenn wir noch weitere Transformationen zu der Transform-Methode hinzufuegen wollen,  ist es schoener anstelle von vielen IFF-Hells-IF-Cascaden.  Eine Switch-Anweisung zu benutzen.", "start": 218.52, "end": 260.52}, {"text": "  Also Switch von Type.  Und dann hat man Case Mirror V.  Und hier Case Mirror H.  Wunderbar, wir starten die Main-Methode  und sehen, dass alles wie vorher funktioniert mit dem horizontalen Spiegel.  Befragen wir sicherheitshalber nochmal den Test.  Obwohl wir gefuehlt nichts an der vertikalen Transformation geaendert haben,  zeigt der Test an, dass es nicht mehr korrekt funktioniert.", "start": 263.52, "end": 314.52}, {"text": "  Nun gehen wir wieder eine Fehler suchen mit Debugging.  Ich gebe die Aufloesung.  Nach dem Switch-Block fehlt eine Break-Anweisung.  Wunder die Break-Anweisung wird nach dem Ausfuehren der vertikalen Transformation  das Programm in der naechsten Case fortgesetzt.  Also wird die Matrix zusaetzlich horizontal gespiegelt.", "start": 314.52, "end": 351.52}, {"text": " Tatsaechlich ist das fehlende Break bei Switch-Anweisungen laut Statistiken  einer der haeufigsten Fehlerquellen Java-Programmen.  Dieses Video hat nicht gezeigt, wie man Toller J Unit-Test schreibt.  Es sollte viel mehr motivieren, warum das Schreiben von Test  bei der Programmentwicklung sinnvoll ist.", "start": 351.52, "end": 368.52}, {"text": " Es hilft dabei zu verhindern, dass neue Aenderungen zu Fehlern  in alten und schon getesteten Funktionalitaeten fuehren.  Dies koennen subtile Fehler sein, die sich erst spaet bei der Programmentwicklung  bemerkbar machen und dann sehr schwierig zu finden sind.  Bei kleinen Programmierprojekten mag der Overhead des Tests Schreiben zu gross sein.", "start": 369.52, "end": 385.52}, {"text": "  Aber bei umfangreicher Softwareentwicklungen fuehren die Tests  oft insgesamt zu einer deutlichen Zeiteinsparung.", "start": 385.52, "end": 388.52}]}]