[{"lecture": "31624_90_course_video", "Timestamps": [{"text": "  In diesem Video wird ein Ansatz mit dynamischer Programmierung fuer das Problem der laengsten  gemeinsamen Teilfolge entwickelt.  Nehmen wir als Beispiel die Zeichenketten A gleich Algo und B gleich Lego.  Gemeinsame Teilfolgen sind zum Beispiel L, G und auch LO.  Die Teilfolgen muessen also nicht zusammenhaengend sein.", "start": 0.0, "end": 30.82}, {"text": "  Die Zeichen der Teilfolger muessen allerdings in der gleichen Reihenfolge in beiden Zeichenketten vorkommen.  Eine weitere gemeinsame Teilfolge ist L, G, O.  Das ist in diesem Fall die laengste.  In anderen Faellen kann es auch mehrere laengste Teilfolgen geben.  Die Aufgabenstellung ist es nun, zu zwei gegebenen Zeichenketten A und B, die Laenge der oder  einer der laengsten Teilfolgen zu bestimmen.", "start": 33.300000000000004, "end": 56.54}, {"text": "  Sehen wir uns zunaechst den Brut & Force Ansatz an.  Zunaechst wird die Variable fuer die Laenge der laengsten Teilfolge max auf 0 gesetzt.  Dann gibt es eine Schleife ueber alle Teilsequenzen S der ersten Zeichenkette A.  Dann wird geprueft, ob diese Teilfolge ueberhaupt ein guter Kandidat ist, um eine neue maximale  Laenge zu bringen.", "start": 60.22, "end": 90.89999999999999}, {"text": "  Wenn S auch tatsaechlich eine Teilfolge von B ist, ist ein neues Maximum gefunden und  die Variable max wird auf die Laenge der Teilfolge S gesetzt.  Machen wir eine Laufzeitbetrachtung.  Die Anzahl der Teilfolgen von A ist in der Groessenordnung zwei Hochlaenge von A.  Das ist also die Anzahl, wie viel Durchlaeufe diese Vorschleife macht.", "start": 91.3, "end": 120.74}, {"text": "  Und die Ueberpruefung der IF-Bedingungen hat die Laufzeit in der Laenge von B, um zu pruefen,  ob S eine Teilfolge von B ist.  Das heisst, insgesamt hat der Brut Force Ansatz eine Laufzeit in Laenge der Zeichenkette B mal zwei  Hochlaenge der Teilchenkette von A.  Man koennte natuerlich auch die Rollen von A und B vertauschen.", "start": 120.74, "end": 145.3}, {"text": "  Der Brut Force Ansatz mit exponentieller Laufzeit ist also sehr ineffizient und wir wollen nun versuchen,  mit dynamischer Programmierung eine effizientere Loesung hinzubekommen.  Dazu muessen wir sehen, wie wir ein Problem auf Teilprobleme zurueckfuehren koennen.  Wir haben also zum Beispiel die zwei Zeichenketten, Algo und Lego.", "start": 145.3, "end": 173.14000000000001}, {"text": "  Nun muessen wir sehen, wie wir das Problem der laengsten gemeinsamen Teilfolge auf ein kleineres Problem,  ein Teilproblem zurueckfuehren koennen.  Naheliegend ist es hier, die Zeichenketten zu verkuerzen, also Zeichen wegzulassen.  Da gibt es unterschiedliche Moeglichkeiten.  Wir koennen zum Beispiel Zeichen von vorne weglassen, Zeichen hinten weglassen  oder Zeichen in der Mitte weglassen.", "start": 173.14000000000001, "end": 205.26}, {"text": "  Bei der Moeglichkeit Zeichen in der Mitte weglassen ist unklar, wo man es nun genau weglaesst.  Deswegen wuerde man das erstmal nach hinten stellen und eine der anderen beiden Moeglichkeiten probieren.  Die kommen im Prinzip auf selber hinaus, vorne und hinten weglassen, die uns schalten uns hier fuer Zeichen hinten weglassen.  Schauen wir uns mal an, wie das aussieht und ob das sinnvoll sein koennte.", "start": 205.26, "end": 232.1}, {"text": "  Das Ursprungsproblem ist in unserem Fall gegeben durch die beiden Zeichenketten Algo und Lego.  Nun gibt es drei Moeglichkeiten, Zeichen hinten weglassen.  Entweder von der ersten Zeichenkette, von A, dann erhalten wir Alg und Lego  oder von beiden Zeichenketten, dann haben wir Alg und Leg  oder nur von der zweiten Zeichenkette B, dann haben wir Algo und Leg.", "start": 232.1, "end": 266.94}, {"text": "  Wenn wir dies noch noch einen weiteren Schritt ausfuehren, erhalten wir hier Al,  Lego, Al, Leg und Alg, Leg.  In der Mitte erhalten wir Al, Leg, Al, Leg  und Alg, Leg  und Alg, Leg  und auf der rechten Seite Alg, Leg  Alg, Leg  und Algo, Leg  und hier sehen wir auch schon die ueberlappenden Teilprobleme.  Hier haben wir die gleichen Teilprobleme.  Hier haben wir die gleichen Teilprobleme.", "start": 267.78, "end": 335.46}, {"text": "  Hier haben wir die gleichen Teilprobleme  und hier  sieht also so aus, als ob der Ansatz des duemmandmaennischen Programmierens  sehr gut zum Tragen kommen kann.  Nun muss eine Funktion opt auf rekursive Weise definiert werden,  die den Loesungsweg des Problemes zurueckgibt.  Wir wollen die Zeichenketten von hinten verkuerzen,  d.h.", "start": 335.46, "end": 372.46}, {"text": "wir nehmen die Variablen I und J  und definieren opt von I und J als die maximale Laenge einer gemeinsamen Teilfolge.  Der Anfangssequenzen der ersten I Zeichen von A,  also A0 bis Ai-1  und der ersten J Zeichen von B, also B0 bis Bj-1.  Nun muessen wir die rekursive Definition  dieses optimalen Loesungswertes aufstellen.", "start": 376.46, "end": 411.46}, {"text": " Zunaechst den Anfangsfall, wenn eine der Zeichenketten leer ist,  also wenn I gleich 0 ist oder wenn J gleich 0 ist,  dann ist die Laenge der laengsten gemeinsamen Teilfolge 0.  Und anderenfalls gucken wir, ob die letzten beiden Zeichen uebereinstimmen oder nicht.  Falls also A von I-1 gleich B von J-1 ist,  dann stimmen die letzten beiden Zeichen ueberein.", "start": 411.46, "end": 438.46}, {"text": "  Dann schauen wir, was ist die optimale Loesung fuer die Zeichenketten,  wenn die letzten Zeichen weggelassen werden.  Das ist also der Wert, den wir rekursiv mit opt von I-1 und J-1 bekommen.  Und fuer unser urspruengliches Problem, also mit den Zeichenketten der Laenge I und J,  wird das letzte gemeinsame Zeichen, in dem Fall sind wir ja, noch angehaengt.", "start": 438.46, "end": 469.46}, {"text": "  Das heisst, dann ist die laengste gemeinsame Teilfolge ein Zeichen laenger,  als die laengste gemeinsame Teilfolge dieses Teilproblems.  Damit gehen wir zu dem letzten Fall, wenn die letzten beiden Zeichen ungleich sind.", "start": 469.46, "end": 496.46}, {"text": " In diesem Fall lassen wir das letzte Zeichen der einen Zeichenkette  oder das letzte Zeichen der anderen Zeichenkette weg  und lassen uns rekursiv die optimale Loesung von diesem Teilproblem zurueckgeben.  Also opt von I-1,J, hier wird A verkuerzt  und opt von I-1, hier wird B verkuerzt.  Und von diesen beiden Teilproblemen nehmen wir das Maximum.", "start": 496.46, "end": 528.46}, {"text": " So konnten wir die Opt-Funktion rekursiv definieren  und mit dieser Definition koennte leicht eine Implementierung mit dynamischer Programmierung vorgenommen werden,  so wie wir das aus der Vorlesung kennen.  Ohne weitere Details der Implementation festzulegen,  koennen wir sagen, dass ein Feldopt benutzt wird,  was die Groesse Laenge der Zeichenkette A mal Laenge der Zeichenkette B besitzt.", "start": 528.46, "end": 555.46}, {"text": "  Das einfuehlen dieser Werte in das Arrayopt geht von den Randfaellen I,J,J,Aus  und setzt sich dann in die Mitte fort  und die Berechnung benutzt nur schon berechnete Werte,  Maximumsbildung und das Adieren von I.  Es ist also in konstanter Laufzeit zu erledigen,  das heisst insgesamt braucht der Algorithmus eine Laufzeit O von Laenge von A mal Laenge von B, um das Array zu fuellen.", "start": 555.46, "end": 592.46}, {"text": "  Im Vergleich dazu nochmal die Laufzeit von der Bootforce Methode,  Laenge der Einzeichenkette A mal 2 hoch Laenge der anderen Zeichenkette.  Wir sehen also einen enormen Laufzeitgewinn durch Verwendung der dynamischen Programmierung.", "start": 592.46, "end": 607.46}]}]