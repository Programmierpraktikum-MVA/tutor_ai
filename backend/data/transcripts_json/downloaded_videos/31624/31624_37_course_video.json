[{"lecture": "31624_37_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns eine bestimmte Art der Queue angucken, die sogenannte Priority Queue.  Wenn wir uns noch mal erinnern, die normale Queue funktioniert nach dem Prinzip FirstIn, FirstOut,  das heisst alle Elemente, die zuerst eingefuegt werden, werden auch als erstes wieder herausgeholt.  Die Priority Queue geht nicht nach diesem Prinzip vor.", "start": 0.0, "end": 30.0}, {"text": "  Hier werden nicht die Elemente, die als erstes hinzugefuegt werden, auch als erstes wieder herausgeholt,  sondern die Elemente mit der hoechsten Prioritaet werden als erstes wieder herausgenommen.  Jetzt fragt euch sicher, was heisst Prioritaet in diesem Zusammenhang?  Prioritaet ist hier erst mal ein sehr weit gefaster Begriff.  Das kann je nach Klasse etwas ganz unterschiedliches sein.", "start": 30.0, "end": 54.0}, {"text": "  Das Wichtige hierbei ist allerdings, um eine Prioritaet bestimmt zu koennen,  muessen unsere Elemente irgendwie miteinander vergleichbar sein.  Die Suendtags einer Priority Queue sieht folgendermassen aus.  Diese ist wieder aehnlich zu der Suendtags der Listen, die wir bereits kennengelernt haben.", "start": 54.0, "end": 81.0}, {"text": " Um eine neue Priority Queue zu erstellen, verwende ich als Datentyp Priority Queue,  entspitzen Klammern wieder den Datentyp meiner Elemente und gebe dann einen Namen.  Um eine neue Priority Queue zu erzeugen, verwende ich wieder als Schluesselwort New,  anschliessend wieder Priority Queue als Datentyp und entspitzen Klammern den Datentypen der Elemente.  Dann folgen Runde Klammern.", "start": 81.0, "end": 100.0}, {"text": "  Um nun Elemente hinzuzufuegen, verwendet man die Methode Add.  Um Elemente zu loeschen, die Methode Remove.  Die Groesse der Queue laesst sich mit der Methode Size zurueckgeben.", "start": 100.0, "end": 122.0}, {"text": " Nun stellt sich allerdings die Frage, kann man einfach so alle Elemente in eine Priority Queue einfuegen?  Ich habe ja gerade eben gesagt, die Elemente muessen irgendwie miteinander vergleichbar sein, um eine Prioritaet zu bestimmen.  Bei so etwas wie Zahlen ist das relativ einfach.  Ist zum Beispiel eine Zahl sehr klein, hat sie eine sehr hohe Prioritaet.", "start": 122.0, "end": 133.0}, {"text": "  Grosse Zahlen zum Beispiel haben eine eher niedrigere Prioritaet.  Was ist nun aber, wenn ich zum Beispiel Elemente selbstgeschriebener Klassen in eine Priority Queue hinzufuegen moechte?  Was benoetige ich dann noch, um eben beliebige Elemente einzufuegen?  Um das einfuegen beliebiger Elemente zu ermoeglichen, gibt es das Interface Comparable.", "start": 133.0, "end": 158.0}, {"text": "  Dieses Interface soll ermoeglichen, Objekte einer Klasse miteinander vergleichen zu koennen.  Wenn man mit einer Klasse das Interface Comparable implementiert, muss man die Comparative Methode implementieren.  Hierbei wird ein Objekt, was als Parameter uebergeben wird, verglichen mit dem aktuellen Objekt unserer Klasse.", "start": 158.0, "end": 182.0}, {"text": "  Wenn wir das Interface implementieren, koennen wir nun selbst entscheiden, anhand welcher Parameter wir die Objekte miteinander vergleichen.  Wir werden gleich noch anhand unseres Beispiels sehen, dass wir Kunden zum Beispiel anhand ihres Alters sortieren.  Damit unsere Priority Queue funktioniert, muss die Comparative Methode folgendermassen funktionieren.", "start": 182.0, "end": 206.0}, {"text": "  Wenn unser Objekt 1 kleiner ist als unser Objekt 2, also eine hoehere Prioritaet hat, dann muss die Comparative Methode ein Wert zurueckgeben, der kleiner als 0 ist.  Wenn unser Objekt 1 groesser ist als Objekt 2, also die Prioritaet nicht so hoch ist, dann muss ein Wert groesser 0 ausgegeben werden.  Und wenn zwei Objekte die gleiche Prioritaet haben, dann soll genau 0 zurueckgegeben werden.", "start": 207.0, "end": 227.0}, {"text": "  Das Ganze wollen wir uns allerdings nun an dem folgenden Beispiel angucken.  Probiert wie immer erst einmal selbst das Ganze zu implementieren und anschliessend zeige ich meine Loesung.  In dem vorherigen Video haben wir bereits begonnen, das Beispiel aus letzter Woche zu erweitern.  Wir haben hier die Klasse Kunde geschrieben.  Nun soll die Klasse Shop weiter angepasst werden.", "start": 227.0, "end": 250.0}, {"text": "  Diese erhaelt nun ein weiteres Attribut.  In diesem Attribut soll eine Warteschlange von Kunden gespeichert werden.  Die Warteschlange soll hier als Priority Queue implementiert werden.  Um Kunden zu dieser Warteschlange hinzuzufuegen, muss die Klasse Kunde das Interface Comparable implementieren.  Schreibt nun weiterhin eine Methode in der Klasse Shop, die die Kunden der Reihe nachbedient.", "start": 250.0, "end": 278.0}, {"text": "  Die juengste Kunde soll hierbei immer zuerst bedient werden.  Der Kunde soll dann alle Produkte von seiner Liste bekommen, welche verfuegbar sind.  Und wenn ein Produkt gerade nicht verfuegbar ist, dann kann er dieses logischerweise nicht kaufen.  Beginnen wir nun erst einmal damit, in der Klasse Kunde das Interface Comparable zu implementieren.", "start": 278.0, "end": 308.0}, {"text": "  Dazu verwende ich das Schluesselwort Implements und anschliessend gebe ich das Interface Comparable an.  Jetzt erhaelt ich bereits ein Fehler, denn ich habe die Methode, die im Comparable steht, noch nicht implementiert.  Um die Methode mit der richtigen Signatur zu erzeugen, kann ich hier auf diese Fehlermeldung klicken und dann Implement Methods auswaehlen.", "start": 308.0, "end": 331.0}, {"text": "  Hier sehen wir dann, welche Methode noch zu implementieren ist, diese waehlen wir aus und klicken auf OK.  Wir sehen hier schon das Schluesselwort Add Overwrite, was bedeutet, dass wir eine bestehende Methode ueberschreiben.  Das haben wir im letzten Video bereits mit der Two-String Methode gemacht.", "start": 331.0, "end": 355.0}, {"text": "  Wenn wir uns die Comparative Methode nun genauer anschauen, dann sehen wir, dass als Parameter nicht unbedingt ein Kunde uebergeben wird, sondern generell ein Objekt.  Was wir also nun im ersten Schritt in der Comparative Methode machen muessen, ist erst einmal zu ueberpruefen, ob unser Objekt ueberhaupt vom Typ Kunde ist.  Das Ganze machen wir mit Hilfe einer Bedingung.", "start": 355.0, "end": 380.0}, {"text": "  Um zu ueberpruefen, ob ein Objekt von einer bestimmten Klasse ist, gibt es in Java das Schluesselwort Instance of.  An dieser Stelle kann ich also ueberpruefen, ob O eine Instance der Klasse Kunde ist.  Und nur, falls das der Fall ist, kann ich auch auf meine Attribute zugreifen.  Nun moechte ich naemlich die Objekte anhand ihres Alters sortieren.", "start": 380.0, "end": 412.0}, {"text": "  Wir erinnern uns, wir moechten ein Wert kleiner als 0 ausgeben, wenn unser Objekt, in dem wir uns aktuell befinden, eine hoehere Prioritaet hat, als das Objekt, was wir uebergeben bekommen.  Wir moechten ein Wert gleich 0 ausgeben, wenn die Prioritaeten gleich sind.", "start": 412.0, "end": 427.0}, {"text": "  Und wir moechten eine Zahl groesser als 0 ausgeben, wenn das Objekt, in dem wir uns aktuell befinden, eine niedrigere Prioritaet hat, als das Objekt, was uebergeben bekommen.  Das Ganze in Code sieht also folgendermassen aus.  Wenn das Alter von unserem aktuellen Objekt niedriger ist, als das Alter von unserem Objekt 0, dann moechte ich ein Wert zurueckgeben, der kleiner als 0 ist.", "start": 428.0, "end": 460.0}, {"text": "  Was idea nun automatisch hinzugefuegt hat, ist dieser TypeCast.  Um naemlich auf die Methode GetAlter zugreifen zu koennen, muss unsere variable O vom Typ Kunde sein.  Wer hierzu noch einmal eine genaue Erklaerung benoetigt, der kann sich noch einmal das Thema Polymorphie anschauen.  Dort habe ich das Ganze etwas ausfuehrlicher erklaert.  Nun kuemmern wir uns um den zweiten Fall.", "start": 460.0, "end": 499.0}, {"text": "  Wenn naemlich das Alter unseres aktuellen Objekts groesser ist, als das Alter von dem Objekt, was wir uebergeben bekommen, dann moechte ich ein Wert zurueckgeben, der groesser als 0 ist.  Hierbei ist nun unwichtig, ob das minus 1 und 1 sind oder minus 2 und 2.  Hauptsache es ist kleiner als 0 oder groesser als 0 und es muss ein Integer sein.", "start": 499.0, "end": 522.0}, {"text": "  Falls weder das Alter von einem aktuellen Produkt niedriger ist, noch groesser ist, als das Alter von dem Objekt, was ich uebergeben bekomme, dann muss das Alter zwangslaeufig gleich sein.  In diesem Fall komme ich in den erst Block.  Und wenn beide Alter gleich sind, dann moechte ich 0 return.  Was hier nun fehlt, ist noch ein erst an dieser Stelle, da ich nur in eine der drei Faelle gehen moechte.", "start": 522.0, "end": 550.0}, {"text": "  Ich ueberpruefe nun also, ist das Alter von meinem aktuellen Kundenobjekt kleiner, als das Alter von dem Kundenobjekt, was ich uebergeben bekomme, dann gebe minus 1 zurueck.  Ansonsten, wenn das nicht der Fall ist, ueberpruefe, ob das Alter meines aktuellen Kundenobjekts groesser ist, als das Alter von dem Kundenobjekt, was ich uebergeben bekomme, dann gebe 1 zurueck.", "start": 550.0, "end": 567.0}, {"text": "  Und wenn beides nicht zutrifft, dann gebe 0 zurueck.  Ausserdem geben wir nun immer 0 zurueck, wenn unser uebergebenes Objekt O nicht vom Typ Kunde ist.  Da wir aber eigentlich nicht zulassen wollen, dass Objekte verschiedener Klassen miteinander verglichen werden, koennen wir das Interface anpassen, was oben im Klassenkopf implementiert wird.", "start": 568.0, "end": 594.0}, {"text": "  Hier koennen wir naemlich neben Comparable noch den Datentypen angeben, den wir vergleichen wollen, in dem Falle Kunde.  Was sich nun naemlich aendert, ist der Datentyp in unserer Comparative-Methode.  Dieser ist nun nicht mehr Objekt, sondern nun Kunde.  Damit sparen wir uns auch die Ueberpruefung, ob unser Objekt vom Typ Kunde ist.  Nun sind alle Kunden miteinander vergleichbar.", "start": 595.0, "end": 625.0}, {"text": "  Im naechsten Schritt wollen wir unseren Shop anpassen.  Dazu wollen wir das Attribut Warteschlange hinzufuegen.  Dieses werden wir jetzt der Einfachheit halber als Public definieren.  Der Datentyp dieses Attributs ist eine Priority Queue, die Elemente vom Datentyp Kunde speichert.", "start": 626.0, "end": 651.0}, {"text": " Ich schreibe also Public, anschliessend Priority Queue,  in Spitzen klammern meinen Datentyp, der gespeichert wird, in dem Falle Kunde,  und dann waehle ich als Name zum Beispiel Warteschlange.  Wir sehen, IDEA hat automatisch den Import von Priority Queue durchgefuehrt.  Nun muessen wir diese im Konstrukte noch initialisieren.", "start": 652.0, "end": 674.0}, {"text": "  Dazu schreibe ich wieder meinen Attributname, Warteschlange, ein ISGleich,  verwende anschliessend das Schluesselwort New und rufe damit den Konstruktor der Priority Queue auf.  In Spitzen klammern muss ich erneut den Datentyp angeben.  Nun sollen wir als naechstes eine Methode schreiben, die die Kunden der Reihe nach bedient.  Der Einfachheit halber wollen wir immer nur ein Kunden bedienen.", "start": 674.0, "end": 703.0}, {"text": "  Diese Methode muss auch wieder von aussen erreichbar sein, deswegen ist die Public,  sie gibt nichts zurueck, deswegen waehlen wir es Rueckgabetypen Void  und ich nenne die Methode Bedienung.  Parameter werden auch nicht benoetigt.  Innerhalb dieser Methode wollen wir zuerst den Kunden aus der Priority Queue holen, der am juengsten ist.", "start": 704.0, "end": 725.0}, {"text": "  Diesen wollen wir uns in einer Variable zwischenspeichern, die nenne ich hier einmal k.  Um ein Element aus einer Priority Queue herauszuholen, verwenden wir die Methode Remove.  Ich schreibe also this.badeschlange.remove.", "start": 727.0, "end": 752.0}, {"text": " Das praktische an der Priority Queue ist nun, dass die Elemente innerhalb dieser Queue sortiert sind  und ich somit mit der Methode Remove automatisch das Element erhalte, was die hoechste Prioritaet hat.  So wie wir unsere Comperto Methode in der Klasse Kunde geschrieben haben,  erhalten wir somit immer den juengsten Kunden an dieser Stelle.", "start": 753.0, "end": 770.0}, {"text": "  Nun wollen wir die Einkaufsliste des Kunden durchgehen und versuchen jedes Produkt auf dieser Einkaufsliste zu kaufen.  Um jedes Produkt der Einkaufsliste durchzugehen, koennen wir eine Schleife verwenden.  Da unsere Einkaufsliste als Queue implementiert ist, erhalten wir das naechste Element unserer Einkaufsliste mit der Methode Poll.  Das Ganze machen wir nun so lange, bis unsere Queue leer ist.", "start": 771.0, "end": 799.0}, {"text": "  Wir gehen also in eine Schleife und diese soll laufen so lange, wie unsere Queue noch nicht leer ist.  Auf unsere Einkaufsliste bzw. unsere Queue greifen wir zu, indem wir k schreiben und anschliessend die GetListe Methode aufrufen.  Diese Queue soll dann nicht leer sein.  Das heisst, ich rufe die Methode isMT auf und dann verneine ich diese Aussage.", "start": 800.0, "end": 836.0}, {"text": " Was habe ich hier nun so mitgeschrieben?  So lange nicht die Einkaufsliste von unserem Kunden leer ist, fuege das aus, was in der Schleife steht.  Innerhalb unserer Schleife wollen wir nun das naechste Produkt bzw. den naechsten Produktnamen aus unserer Queue herausholen.  Das wollen wir dann in einer Variable zwischenspeichern.  Ich nenne diese Variable hier zum Beispiel Name.", "start": 837.0, "end": 866.0}, {"text": "  Um nun das naechste Element aus unserer Queue zu erhalten, schreibe ich wieder k.getListe, bekomme damit meine Einkaufsliste und rufe auf dieser die Poll Funktion auf.  Nun moechte ich dieses Produkt, was ich hier in meiner Variable Name gespeichert habe, aus dem Shop kaufen.  Dazu lege ich mir wieder eine Hilfsvariable an, in dem Fall das Produkt, das nenne ich hier P.", "start": 867.0, "end": 888.0}, {"text": "  Und um dieses Produkt zu erhalten, rufe ich von meinem Shop, in dem ich mich gerade befinde, die Kaufenmethode auf.  Dieser uebergebe ich den Namen des Produkts, was ich kaufen moechte.  Dieses Produkt muss ich nun nur noch in den Rucksack unseres Kunden einfuegen.  Hier gibt es allerdings einen kleinen Sonderfall.", "start": 890.0, "end": 909.0}, {"text": "  Wenn naemlich unser Produkt nicht im Shop vorhanden ist, dann gibt uns unsere Kaufenmethode Null zurueck.  Das muessen wir vorher also noch einmal ueberpruefen.  Wenn unser Produkt P, also ungleich Null ist, bedeutet, wenn wir ein gueltiges Produkt zurueckbekommen haben, dann moechten wir dieses auch in den Rucksack unseres Kunden hinzufuegen.", "start": 910.0, "end": 939.0}, {"text": "  Das mache ich, indem ich auf meinem Kunden die Methode kaufen aufrufe und ihm das Produkt P uebergebe.  Fassen wir nun also noch einmal zusammen.  Ich hole erst den naechsten Kunden aus meiner Priority Queue.  Dann gehe ich in eine Schleife, solange seine Einkaufsliste noch nicht leer ist.  Im ersten Schritt hole ich das erste Element aus seiner Einkaufsliste.", "start": 941.0, "end": 969.0}, {"text": "  Kaufe dieses Element im Shop und wenn der Kauf erfolgreich war, also P ungleich Null ist, dann packe ich dieses Element in sein Rucksack.  Das mache ich so lange, bis die Einkaufsliste leer ist.  Wie wir dieses nun doch schon relativ komplexe Programmen testen koennen, das schauen wir uns dann im naechsten Video an.  Danke fuers Zuschauen.", "start": 971.0, "end": 989.0}]}]