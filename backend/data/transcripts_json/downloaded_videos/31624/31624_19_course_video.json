[{"lecture": "31624_19_course_video", "Timestamps": [{"text": "  Hallo, heute gibt es ein kleines Video fuer dich zum Thema Hashtabellen. Das Video soll  so ein bisschen in der Einfuehrung sein und in den ganzen anderen Vorlesungsvideos.  Schau dir dann die ganzen Details. Die Einfuehrung moechte ich gerne machen anhand  von einem Beispiel. Und zwar ein Beispiel mit Kennzeichen von Autos.", "start": 0.0, "end": 39.84}, {"text": "Also im Grunde genommen  so eine Anwendung fuer Kraftfahrzeugbundesamt oder so, wo alle Fahrzeuge gespeichert sein sollten.  Da haben wir also die Daten zur Autos, die wir irgendwie so abspeichern wollen, dass man sie  gut wieder auslesen kann.", "start": 39.84, "end": 64.68}, {"text": "Wir haben also ein Problem von solchen Kennzeichen und damit wir die  abspeichern koennen und die damit assoziierten Informationen wie zum Beispiel Fahrzeugtyp,  Erstzulassung, Farbe und so was muessen wir natuerlich das Nummernschild auf eine Art Schluessel,  also nicht auf eine Art, sondern auf ein Schluessel abbilden.", "start": 64.68, "end": 83.76}, {"text": "Das heisst, wir wollen jedes  Nummernschild abbilden in eine eindeutige Zahl, die wir benutzen koennen, um den gesamten Datensatz  zu indizieren. Und es geht ganz einfach, wir nehmen die Buchstaben und die Zahlen und versuchen  daraus eine Gesamtzahl zu machen.", "start": 83.76, "end": 104.28}, {"text": "Und das geht, indem ich die Buchstaben nehme und jeweils mit  26 hoch irgendeiner Potenz rechne. Also wenn ich davon ausgehe, dass es vier Buchstaben gibt,  dann habe ich jeweils die Potenzen 3, 2, 1, 0 von 26, deswegen 26, weil es im Alphabet 26  Buchstaben gibt.", "start": 104.28, "end": 127.6}, {"text": "Obwohl mir faellt ein, vielleicht gibt es auch noch Oels, ne? Naja, aber wir gehen mal  davon aus, wir haben keine Umlaute oder Sonderzeichen. Das heisst, aus den vier Buchstaben B, A, D, C  machen wir eine Zahl, multiplizieren das mit 10 hoch 5 und koennen dann noch eine Zahl hinzuadieren,  die der Zahl nach den Buchstaben im Nummernschild entspricht.", "start": 127.6, "end": 147.44}, {"text": "Dadurch, dass wir mit 10 hoch 5  multiplizieren, haben wir eigentlich fuenf Stellen frei, in diesem Beispiel werden nur vier benutzt.  Das heisst, wir haben eine Abbildung von einem beliebigen Nummernschild auf einen eindeutigen  Schluessel.", "start": 147.44, "end": 169.12}, {"text": "Und die Anzahl der Schluessel oder dann antworten die Anzahl der Nummernschilder,  die wir abspeichern wollen, ergibt sich aus allen Nummernschildern zwischen A, A, A, 1, 1, 1, 1 bis  Z, Z, Z, Z, 9, 9, 9. Wie gesagt, da koennte eigentlich noch eine fuenfte Zahl stehen, aber ist  egal.", "start": 169.12, "end": 193.8}, {"text": "Allein das reicht schon und das sind ungefaehr fuenf mal zehn, noch minus zehn verschiedene  Nummernschilder. Jetzt stellt sich uns die Frage, wie wir das gerne gestalten wollen. Da haben wir  einige Dinge schon gelernt, die wir benutzen koennen und schauen uns aber mal an, was da die Lage ist.  Also insgesamt abspeichern und aufrufen von Daten mit Schluessel.", "start": 193.8, "end": 216.20000000000002}, {"text": "Wir haben diese Tuple aus Schluessel  und Daten. Wir haben S Schluessel, die Anzahl der Schluessel ist S und N ist die Anzahl der Datensaetze.  Wir haben gerade gesehen, wir haben ungefaehr zehn hoch, was war das? Zehn hoch, ich schau nochmal zurueck,  zehn hoch zehn.", "start": 217.2, "end": 242.76}, {"text": "Wir haben ungefaehr zehn hoch zehn verschiedene Schluessel, aber natuerlich wissen wir,  das ist niemals auf der ganzen Welt nicht, zehn hoch zehn Autos geben wird, die jeweils ein Nummernschild  brauchen. Das heisst, wir sind in der Situation, dass wir viel mehr Schluessel haben, als wir erwarten  Datensaetze zu haben.", "start": 242.76, "end": 261.64}, {"text": "Woran liegt das? Das liegt daran unter anderem, dass wir eine bestimmte Struktur  an den Nummernschildern haben. Wir haben also die ersten zwei Buchstaben vielleicht fuer den Ort  und natuerlich gibt es nicht alle Buchstabenkombinationen als Ort. Das heisst, da ist eine gewisse Luecke in  unseren Daten.", "start": 261.64, "end": 284.91999999999996}, {"text": "Aber festzuhalten ist, wir haben hier ein Problem, indem die Schluessel viel vielfaeltiger  sind als die Anzahl der Datensaetze, die wir haben. Okay, was koennen wir jetzt machen? Was kennen wir denn  schon? Wir kennen das lineare Array. Das ist nicht ganz unbekannt, sieht ungefaehr so aus.", "start": 284.91999999999996, "end": 306.2}, {"text": "Wir haben  die Elemente dieses Arrays durchnummeriert und wenn wir jetzt ein Array benutzen wuerden, dann  wuerden wir sagen, der Index im Array entspricht einfach dem Schluessel. Und daraus wuerde folgen,  dass wir ein Array haben muessen, der Laenge zehn hoch zehn. Das ist sportlich. Also das ist wahrscheinlich  keine sehr effiziente Implementierung.", "start": 306.2, "end": 328.40000000000003}, {"text": "Ihr habt auch schon gesehen, dass wir einen Suchbaum  verwenden koennen. Da werden Daten in so einem vielleicht sogar binaerer Suchbaum, in so einem  Suchbaum abgespeichert und dann muessen wir in dem Baum nach dem Schluessel suchen und wie viel  Schritte wir da maximal machen muessen, richtet sich nach der Tiefe des Baums.", "start": 328.40000000000003, "end": 348.8}, {"text": "Und wenn wir sagen,  wir haben einen balancierten Binaerbaum, erinnert euch vielleicht an diese Datenstruktur, dann haben  wir logarithmisch Basis 2, 10 hoch 10, ungefaehr 33 Schritte, die wir machen muessten, um eine bestimmte  Nummernschild im schlimmsten Fall zu finden. So, dann geht es um die Hashstabelle.", "start": 348.8, "end": 374.15999999999997}, {"text": "Das ist  eine Deutdatenstruktur. Die sieht aus erst mal wie ein Array, ist auch ein Array, hat auch,  natuerlich weil es ein Array ist, die ganzen Elemente in dieser Tabelle sind durchnummeriert mit einem  Index. Nur der Unterschied zum Array ist, dass der Index gleich die Hashfunktion vom Schluessel ist.  Das muessen wir uns noch genauer angucken.", "start": 374.15999999999997, "end": 406.28000000000003}, {"text": "Wir benutzen also nicht genau den Schluessel als Index  in dieser Array, sondern wir tun den Schluessel noch in der Funktion und die bildet es dann ab auf  den, auf die Spanne von Indices, die es in der Hashstabelle gibt. Okay, wir wissen das in einem,  lass uns jetzt einfach mal diese drei Dinge vergleichen. Wir wissen das in einem linearen Array.", "start": 406.28000000000003, "end": 429.47999999999996}, {"text": "  Wir, die Anzahl der Schluessel ungefaehr der Anzahl der Elemente in diesem Array entsprechen muss.  Das heisst, wenn wir viele Schluessel haben, was in unserem Nummernschild Beispiel der Fall ist,  ist das nicht so gut. Im Beispiel von einem Suchbaum kann die Anzahl der Schluessel viel,  viel groesser sein als die Anzahl der Datensaetze.", "start": 429.47999999999996, "end": 451.24}, {"text": "Das macht uns hier eigentlich ueberhaupt nichts  aus, weil im Grunde genommen der Schluessel einfach nur ein Teil des Datensatzes ist und  wir speichern diesen Datensatz sortiert in diesem Benaehrbaum ab.", "start": 451.24, "end": 471.56}, {"text": "Diese Eigenschaft der Suchbraeume,  die wir ja ganz gut finden, weil sie genau unser Problem zu loesen scheint, die bleibt erhalten  bei den Hashstabellen. Also auch hier koennen wir damit umgehen, dass es viel mehr Schluessel gibt,  als es eigentliche Daten gibt, die wir erwarten eintragen zu muessen.", "start": 472.16, "end": 487.16}, {"text": "Und der Schluessel,  no pun intended, liegt natuerlich jetzt hier genau in dieser Hash-Funktion. Aber vergleichen wir doch  erst mal die verschiedenen Dinge hier, die wir haben, je nach, was der Aufwand ist,  zum Speichern und zum Finden.", "start": 487.16, "end": 509.44}, {"text": "Also bei einem Array, dadurch, dass wir einfach nur den Schluessel  benutzen muessen und wir haben sofort den richtigen Eintrag im Array, ist das hier natuerlich konstant,  also Order 1 und finden mit demselben Argument ist auch Order 1. Im Suchbaum etwas zu speichern,  kann erfordern, dass wir den Baum umsortieren muessen.", "start": 509.44, "end": 537.72}, {"text": "Also das ist zumindest Log N und auch das  Finden, wie wir gerade schon gesehen haben, kann erfordern, dass wir den Baum durchlaufen muessen  und auch das kann Log N sein. So, jetzt haben wir so ein bisschen eine Zwickmuehle.", "start": 537.72, "end": 556.64}, {"text": "Wir haben hier  eine Eigenschaft, die wir ganz gut finden und wir haben hier eine Eigenschaft, die wir ganz gut  finden. Wir wollen also eigentlich so speichereffizient sein wie so ein Binaerbaum. Wir wollen aber so  Zugriffs- und Abspeicher-Schnell sein wie ein Array.", "start": 556.64, "end": 572.0799999999999}, {"text": "Und das klingt jetzt so, als ob man natuerlich  beides nicht haben koennte. In diesem Fall schon, genau das machen Hash-Tabellen, die erlauben uns  naemlich im Order 1 abzuspeichern und zu finden.", "start": 572.08, "end": 599.2}, {"text": "Das ist manchmal, also das ist der, je nachdem,  wie wir das implementieren, wird das der erwartete Wert sein, aber im Grunde genommen ist der erwartete  Wert, dass wir in konstanter Zeit die Daten abspeichern koennen und auch in konstanter Zeit die Daten  wiederfinden koennen.", "start": 599.2, "end": 616.5600000000001}, {"text": "Das heisst, wir haben hier die Situation, dass wir beide interessante  Dinge vereint haben. Wir haben eine Datenstruktur, die es uns ermoeglicht, Daten effizient abzuspeichern  und effizient wiederzufinden, auch fuer den Fall, dass die Anzahl der moeglichen Schluessel viel,  viel groesser ist, als die Anzahl der Daten, die ich eigentlich wirklich abspeichern will.", "start": 616.5600000000001, "end": 635.8}, {"text": "  Okay, das ist sozusagen der Unique Selling Point von Hash-Tabellen. Und jetzt schauen wir uns mal an,  wie das vom Prinzip her funktioniert. Wir haben also S ist viel groesser als N.", "start": 635.8, "end": 663.12}, {"text": "Das heisst, wir haben eine  grosse Menge von Schluesseln und innerhalb dieser Menge gibt es ein paar Elemente, die die Daten  entsprechen, die wir abspeichern wollen.", "start": 663.12, "end": 680.4799999999999}, {"text": "Und wir haben jetzt ein Array, also unsere Hash-Tabelle,  wo wieder die einzelnen Elemente durchnummeriert sind und die Groesse dieser Hash-Tabelle entspricht  aber nur ungefaehr der Groesse der Anzahl der Daten-Elemente. Das heisst, in der Blase links gibt es viel  mehr moegliche Daten, als die Tabelle rechts platzert.", "start": 680.4799999999999, "end": 698.0}, {"text": "Und wie ich schon gesagt habe, der Schluessel,  wie wir jetzt von der linken Seite auf die rechte Seite kommen, ist die Hash-Tabelle. Es ist die  Hash-Funktion. Wir haben also einen Datenpunkt hier, den ganz linken, der wird mit Hilfe der  Hash-Funktion ueber diesen gelben Pfeil auf ein bestimmtes Element in der Hash-Tabelle abgebildet.", "start": 698.04, "end": 718.2}, {"text": "  Und wir koennen natuerlich in diese Hash-Funktion jeden beliebigen Schluessel reintun und die  Hash-Funktion berechnet aufgrund des Schluesseln fuer ein Datensatz den Ort, an dem der Datensatz  abgespeichert werden soll. Nun, welche Eigenschaften muss diese Hash-Funktion erfuellen? Sie muss alle  Schluessel, die moeglich sind, auf, in diesem Fall, die Zahlen 0 bis Groesse H abbilden.", "start": 718.2, "end": 756.84}, {"text": "Wir wissen aber,  dass die Anzahl der moeglichen Schluessel auf der linken Seite viel, viel groesser ist als H.", "start": 756.84, "end": 784.8}, {"text": "Das heisst,  wenn wir jetzt alle Elemente aus der linken Seite mit der Hash-Funktion oder die Schluessel aller Elemente  auf der linken Seite mit der Hash-Funktion abbilden wuerden auf die Hash-Tabelle, dann muesste es eine  Doppelbelegung geben. Wenn ich zum Beispiel jetzt rechne S durch Anzahl der Elemente, also Anzahl  der eintrigen Hash-Tabelle, dann kriege ich raus den Faktor der Mehrfachbelegung.", "start": 784.8, "end": 814.8}, {"text": "  Das ist natuerlich ein Problem, ich muss das leider jetzt wegwischen, weil die naechste Animation  genau dahin will. Das ist natuerlich ein Problem, weil es uns passieren kann, dass die Hash-Funktion  ein Datenelement auf genau das gleiche Feld in der Hash-Tabelle abbildet wie ein anderen Schluessel.  Das nennen wir eine Kollision.", "start": 814.8, "end": 848.24}, {"text": "Eine Kollision passiert, wenn zwei verschiedene Schluessel auf das  gleiche Feld in der Hash-Tabelle abgebildet werden.", "start": 848.24, "end": 867.24}, {"text": "Wir wissen, dass das passieren koennen muss,  weil die Anzahl der Schluessel so viel groesser ist als die Anzahl der Elemente in der Hash-Tabelle,  deswegen muessen bei einer kompletten Abbildung aller Schluessel auf die Hash-Tabelle eben mehrere  Schluessel auf das gleiche Elemente Hash-Tabelle abgebildet werden.", "start": 867.24, "end": 873.92}, {"text": "Und wenn wir jetzt eine kleine  Untermenge der moeglichen Schluessel auf uns aussuchen, koennen wir Pech haben und diese Hash-Funktion  bildet diese zwei Schluessel auf das gleiche Element der Hash-Tabelle ab. Gut, also das ist was  eine Hash-Tabelle macht, die benutzt eine Hash-Funktion um Schluessel abzubilden auf einer Tabelle.", "start": 873.92, "end": 899.0}, {"text": "Dabei  kann es Probleme geben, naemlich Kollision und genau darum werden sich die naechsten Vorlesungsvideos  handeln. Wie waehle ich mir eine gute Hash-Funktion aus? Eine gute Hash-Funktion ist eine, die  moeglichst wenig Doppelbelegung hervorruft.", "start": 899.04, "end": 923.68}, {"text": "Und die zweite Frage ist, wenn es dann aber doch  passiert, dass die Hash-Funktion zwei Schluessel auf das gleiche Feld abbildet, wie kann ich mit dieser  Kollision umgehen? Das sind die beiden Probleme, die geloest werden muessen, damit wir diese Datenstruktur  der Hash-Tabelle vervollstaendigen. Und genau darueber gehen die naechsten Videos.", "start": 923.68, "end": 937.1999999999999}, {"text": "Also ich habe  sehr gespannt auf die Loesung fuer diese Probleme, dann schaut euch die naechsten Videos an. Bis dann, ciao!", "start": null, "end": 937.1999999999999}]}]