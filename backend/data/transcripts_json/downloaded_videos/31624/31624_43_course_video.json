[{"lecture": "31624_43_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir die wichtigsten Themen aus der letzten Woche kurz wiederholen.  Im Speziellen geht es hier um Klassen, Vererbung, Interfaces, abstrakte Klassen, Polymorphie und Generics.  Beginnen wir aber mit einer kurzen Wiederholung zu den java-spezifischen Schluesselwoertern.  Ich wuerde euch bitten, einmal kurz darueber nachzudenken, was die folgenden Begriffe bedeuten.", "start": 0.0, "end": 34.0}, {"text": "  Wir haben hier einmal Static, dann This in Bezug auf Variablen innerhalb einer Klasse und Extents.  Ich gebe euch einen Moment Zeit und zeige anschliessend die Loesung.  Das Schluesselwort Static benoetigen wir, wenn wir eine Funktion bzw. Methode ohne Erstellung eines Objektes aufrufen wollen.  Das wohl bekannteste Beispiel ist hier die MainMethode.", "start": 34.0, "end": 69.0}, {"text": "  Diese sollte sich naemlich aufrufen lassen, ohne dass vorher ein Objekt erstellt wurde, da diese zu Beginn des Programms ausgefuehrt wird.  Das Schluesselwort This in Bezug auf Variablen einer Klasse referenziert die Attribute des Objekts bzw. der Klasse.  Das findet oft Verwendung in Methoden der Klasse, vor allem im Konstruktor.", "start": 69.0, "end": 90.0}, {"text": "  Mit dem Schluesselwort Extents in der Klassendefinition gebe ich an, dass diese Klasse von einer anderen Klasse erbt.  Hierbei werden alle Attribute und Methoden der Superklasse vererbt, die nicht private definiert sind.  Hier habe ich nun eine kleine Beispielklasse definiert.  Diese heisst Auto und besteht aus drei wichtigen Abschnitten.  Diese wuerde ich euch nun einmal bitten zu benennen.", "start": 90.0, "end": 114.0}, {"text": "  Beginn werden wir mit dem ersten Abschnitt.  Hierbei handelt es sich um ein sogenanntes Attribut.  Attribute sind Variablen, die sich eben genau auf diese Klasse bzw. Objekte der Klasse beziehen.  Was ist mit diesem Abschnitt?  Bei diesem Abschnitt handelt es sich um den Konstruktor.  Den Konstruktor erkennt man daran, dass er den gleichen Namen traegt wie die Klasse selbst.", "start": 120.0, "end": 154.0}, {"text": "  Ausserdem werden innerhalb des Konstruktors die Attribute initialisiert.  Und wie nennt man den letzten Abschnitt?  Hier sind mehrere Antwortmoeglichkeiten richtig.  Im Allgemeinen handelt es sich hier um eine Methode der Klasse.", "start": 154.0, "end": 184.0}, {"text": " Im Speziellen handelt es sich allerdings um eine Getter Methode, was man daran sieht,  dass sie den Namen Get und dann Attributnamen traegt und nichts weiter macht,  als den Wert unseres Attributes zurueckzugeben.  Diese wird hier benoetigt, weil unser Attribut als private definiert ist  und somit nicht von aussen darauf zugegriffen werden kann.", "start": 184.0, "end": 196.0}, {"text": "  Nun schauen wir uns noch einmal kurz das Prinzip der Polymorphie an.  Polymorphie besagt, dass Objekte einer Klasse auch als Objekte der Superklasse behandelt werden koennen.  Das hat nun den Vorteil, dass Objekte gleicher Superklasse so zum Beispiel in einem Array  oder in einer Liste gemeinsam gespeichert werden koennen,  obwohl sie nicht den gleichen Datentypen haben.", "start": 196.0, "end": 217.0}, {"text": "  Hierzu habe ich noch einmal ein kleines Beispiel.  Zum einen habe ich die Klasse Vogel definiert  und zum anderen die Klasse Adler, welche von der Klasse Vogel erbt.  In der Main-Methode habe ich nun ein neues Array erzeugt.  Das seht ihr an diesen eckigen Klammern.  In diesem Array werden Objekte vom Datentyp Vogel gespeichert.  Das Array traegt den Namen Voegel.", "start": 217.0, "end": 242.0}, {"text": "  Um das Array zu erzeugen habe ich das Schluesselbord New verwendet,  anschliessend meinen Datentypen, in dem Fall Vogel  und in eckigen Klammern die Groesse des Arrays in dem Falle 2.  An Position 0 des Arrays habe ich nun die Moeglichkeit,  ein neues Vogelobjekt zu speichern.", "start": 242.0, "end": 267.0}, {"text": " Ich habe allerdings ausserdem die Moeglichkeit,  an Position 1 zum Beispiel ein neues Adlerobjekt zu speichern,  weil Adler von der Vogelklasse erbt.  Somit laesst sich auf dieses Beispiel Polymorphie anwenden  und ich kann ein Objekt der Subklasse, in dem Fall Adler,  in ein Array speichern, was Objekte der Subklasse  in dem Falle Vogel speichert.  Kommen wir nun zu Interfaces.", "start": 269.0, "end": 287.0}, {"text": "  Interfaces kann man sich vorstellen,  wie eine kleine Bauanleitung fuer Klassen.  Interfaces selbst enthalten nur Methodenkoepfe.  Wird ein Interface dann von einer Klasse implementiert,  muss diese auch die Methoden des Interfaces implementieren.  Hierbei ist es moeglich, mit einer Klasse mehrere Interfaces  gleichzeitig zu implementieren.", "start": 287.0, "end": 312.0}, {"text": "  Als Beispiel habe ich hier einmal das Interface-Fahrzeug definiert.  Dieses enthaelt lediglich den Methodenkopf fuer die Methode Gewicht pro Rad.  Diese erhaelt als Parameter ein Gewicht  und gibt dann ein Double zurueck, wie viel Gewicht auf jedem Rad liegt.", "start": 312.0, "end": 335.0}, {"text": " Moechte ich nun zum Beispiel mit meiner neuen Klasse Auto  das Interface-Fahrzeug implementieren,  dann muss ich auch die Methode Gewicht pro Rad implementieren.  Dass sich hierbei um ein Auto handelt,  macht die Methode nichts weiter,  als das Gewicht durch die vier Raeder zu teilen und zurueckzugeben.  Aehnlich wie Interfaces funktionieren auch abstrakte Klassen.", "start": 335.0, "end": 354.0}, {"text": "  Im Gegensatz zu Interfaces handelt es sich hierbei allerdings tatsaechlich um Klassen  und somit ist auch Vererbung moeglich.  Erbe ich also von einer abstrakten Klasse,  so vererbe ich wie gewohnt Attribute und Methoden.  Der Unterschied zu anderen Klassen ist,  dass sich hier wieder Funktionen offen lassen kann,  welche spaeter implementiert werden sollen.", "start": 354.0, "end": 373.0}, {"text": "  Dazu schreibe ich hier wieder nur den Funktionskopf,  der diesmal aber das Stichwort Abstract enthaelt.  Wenn nun eine Klasse von einer abstrakten Klasse erbt,  muss diese auch die abstrakten Funktionen der Superklasse implementieren.  Hierzu schauen wir uns einmal ein aehnliches Beispiel wie bei den Interfaces an.", "start": 373.0, "end": 397.0}, {"text": " Ich habe hier diesmal eine abstrakte Klasse, die Fahrzeug heisst  und diese hat als Attribut ihr Gewicht,  einen einfachen Konstruktor des Gewicht initialisiert  und wieder die Gewicht pro Rackmethode, die hier als Abstract definiert ist.  In dem Fall braucht man kein Parameter,  weil wir an der Stelle unser Attribut Gewicht verwenden.", "start": 397.0, "end": 421.0}, {"text": " Wenn ich nun von dieser Klasse erbe,  dann erbe ich den Konstruktor und das Attribut,  muss allerdings auch die abstrakte Methode Gewicht pro Rack implementieren,  was ich hier gemacht habe.  Hierbei greife ich dann auf das Attribut Gewicht zu,  teile das durch 4 und gebe den Wert zurueck.  Um die Struktur von Klassen noch einmal zu wiederholen,  habe ich hier eine kleine Aufgabe fuer euch.", "start": 421.0, "end": 445.0}, {"text": "  Probiert diese am besten erst einmal selbst  und anschliessend zeige ich euch die Loesung.  Hierbei sollt ihr eine Klasse Shop schreiben.  Diese Klasse soll die privaten Attribute, Name und Besitzer besitzen.  Diese Attribute sollen dann in einem Konstruktor initialisiert werden.  Da die Attribute auf Private gesetzt sind,  benoetigen wir weiterhin Getter-Methoden fuer alle Attribute.", "start": 445.0, "end": 471.0}, {"text": "  Schreibt ausserdem die Klasse Produkt,  die der Einfachheit halbern nur das private Attribut Name besitzt.  Ausserdem ein einfachen Konstruktor  und eine Getter-Methode fuer das private Attribut.  Fuer diese Aufgabe habe ich eine Idee schon mal ein neues Projekt erstellt.  Dieses enthaelt bisher nur die Klasse Test und eine leere Main-Methode.", "start": 471.0, "end": 498.0}, {"text": "  Beginn moechte ich nun damit, eine neue Klasse zu erzeugen,  welch den Namen Shop traegt.  Dazu mache ich Rechtsklick auf mein Source Ordner,  waehle New und dann Java Class.  Diese Klasse nenne ich Shop.  Innerhalb dieser Klasse beginnen wir damit, die Attribute zu definieren.  Als Attribut soll sowohl der Name des Shops  als auch der Name des Besitzers gespeichert werden.", "start": 498.0, "end": 529.0}, {"text": "  Da es sich hierbei jeweils um Zeichenketten handelt,  ist String der geeignete Datentyp.  Darueber hinaus sollen beide Attribute private sein.  Fuer den Namen des Shops schreibe ich deshalb Private,  dann den Datentyp, also String  und dann den Name der Variable, in dem Falle Name.  Das gleiche mache ich nun noch einmal fuer den Besitzer.", "start": 529.0, "end": 562.0}, {"text": "  Diese Attribute sollen nun in einem Konstruktor initialisiert werden.  Ein Konstruktor hat immer die folgende Signatur.  Da man von aussen immer darauf zugreifen koennen sollte,  ist er als Public definiert.  Weiterhin traegt er den Namen der Klasse, in dem Falle Shop  und anschliessend folgt eine Liste mit Parametern.", "start": 566.0, "end": 591.0}, {"text": " Da ich den Namen und den Besitzer initialisieren moechte  und beide vom Typ String sind, sollten meine Parameter auch beide vom Typ String sein.  Ich habe also einmal ein String, mit dem ich den Namen initialisieren moechte  und ein String, mit dem ich den Besitzer initialisieren moechte.  Um nun auf die Attribute der Klasse zugreifen zu koennen,  benutze ich das Schluesselwort This.", "start": 591.0, "end": 613.0}, {"text": "  Anschliessend benutze ich den Attributname.  Und nun weiss ich den Wert zu, den ich als Parameter uebergeben bekommen habe.  Das gleiche mache ich noch mit Besitzer.  Um von aussen auf unsere privaten Attribute zugreifen zu koennen,  brauchen wir jetzt noch Gattermethoden.  Auch hier wollen wir wieder von aussen darauf zugreifen,  deswegen ist die Gattermethode Public.", "start": 613.0, "end": 645.0}, {"text": "  Als Rueckgabetypen haben wir immer den Datentyp unseres Attributs,  in dem Falle also String.  Und als Name waehlen wir Get unter den Attributnamen,  das heisst in dem Falle GetName.  Parameter werden bei einer Gattermethode nicht benoetigt.  Innerhalb dieser Gattermethode machen wir dann nichts anderes,  als den Wert unseres Attributs zurueckgeben.", "start": 645.0, "end": 674.0}, {"text": "  Das gleiche mache ich jetzt noch einmal fuer den Besitzer.  Nehmen der Shopklasse benoetigen wir noch eine weitere Klasse, die den Namen Produkt traegt.  Dazu mache ich wieder einen Rechtsklick auf meinen Sourceordner,  waehle New, Java Class und gebe ihr den Namen Produkt.  Und dann habe ich den Namen Produkt.  Und dann habe ich den Namen Produkt.", "start": 678.0, "end": 707.0}, {"text": "  Ich habe den Namen Java Class und gebe ihr den Namen Produkt.  Ein Produkt sollte auch wieder das private Attributname haben.  Einen einfachen Konstruktor, der dieses Attribut initialisiert.  Und eine Gattermethode, um auf den Namen des Produktes zugreifen zu koennen.  Die Schritte sind hierbei identisch wie bei unserem Shop.", "start": 707.0, "end": 761.0}, {"text": "  Falls euch das Ganze zu schnell ging, koennt ihr das Video gerne pausieren und zurueckspulen.  Das letzte Thema, welches wir letzte Woche kennengelernt haben, waren die sogenannten Generics.  Diese werden als Platzhalter benutzt, wenn noch unbekannt ist, welchen Datentyp ein bestimmtes Objekt hat.", "start": 761.0, "end": 783.0}, {"text": " Dies wird beispielsweise fuer Listen verwendet, da hier die Struktur der Liste immer gleich ist,  nur der Datentyp, der in der Liste gespeichert wird, ist immer ein anderer.  Auf Listen werde ich allerdings im naechsten Video genauer eingehen.", "start": 783.0, "end": 788.0}]}]