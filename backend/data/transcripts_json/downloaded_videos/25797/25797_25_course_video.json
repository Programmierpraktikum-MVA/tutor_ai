[{"lecture": "25797_25_course_video", "Timestamps": [{"text": "  Wir kommen zur naechsten Uebung im wissenschaftlichen Rechner.  In dieser Uebung wollen wir mit Python weiter machen.  Das heisst, die zeigt euch den Eserpreter, Jupyter Notebooks, Binder.  Dann werden wir da in die Grundlinien ein Sprachkonzept erkennen.  In einem breiten grossen Teil wollen wir dann die Grundleitende Linien an Algebra wiederholen.", "start": 0.0, "end": 21.0}, {"text": "  Dann kannst du direkt mit der Bibliothek NumPy in Verbindung bringen.  So, zunaechst mal die Varianten, wie ihr Python ausfuehren koennt.  Das hatte ich in den Installationsvideo schon einmal kurz angesprochen.  Die Besonderheit an Python ist, dass Python nicht kompiliert wird, sondern mit einem Interpreter arbeitet.", "start": 21.0, "end": 45.0}, {"text": "  Das heisst, Interpreter nimmt den Code und fuehrt dann Operationen auf der Maschine aus, abhaengig von dem Code.  Wenn ihr z.B. Cod programmiert, dann wird er direkt im Maschinencode uebersetzt und der Maschinencode wird direkt ausgefuehrt.  Bei Python haengt immer noch dieser Interpreter dazwischen.", "start": 45.0, "end": 61.0}, {"text": "  Ich mache die Programmiersprache ein bisschen landenammer, weil der Code hat jedes Mal beim Ausfuehren erst frisch interpretiert wird,  und nicht nur einmal im Maschinencode uebersetzt wird.  Dafuer wird die Sprache aber konzeptionell einfacher.  Der Code ist plattformunabhaengig.", "start": 61.0, "end": 80.0}, {"text": "  Man muss den Interpreter nur einmal fuer die Plattform kompilieren, also einmal fuer Windows, einmal fuer Linux, was auch immer.  Dann kann man den selben Python Code einfach an die unterschiedlichen Interpreter auf den verschiedenen Plattformen uebergeben.  Der kann ihn dann immer gleichermassen interpretieren.  Genau, das kann ich einmal zeigen, das haette ich schon einmal gemacht.", "start": 80.0, "end": 98.0}, {"text": "  Also ich kann einen Terminal vorbereitet.  Dann habe ich hier mein Virtual Environment aktiviert.  Dann kann ich jetzt einfach eingeben Python.  Dann schalte ich einen Python Interpreter, indem ich programmieren kann.  Achtung, auch verbunden, dann muesst ihr dann halt z.B. Python 3 eingeben, damit ihr wirklich Python 3 verwendet.", "start": 98.0, "end": 122.0}, {"text": "  Eine weitere Variante ist, dass ihr halt Code in eine Datei schreibt,  und dann kann der Interpreter diesen Code in der Datei ausfuehren.  Da gibt es mehrere Varianten.  Zum einen kann man einfach direkt den Interpreter diese Datei uebergeben, also Python 3, Function.py, dann wird diese Funktion ausgefuehrt.", "start": 122.0, "end": 147.0}, {"text": " Eine andere Variante, was auch noch geht, was ich jetzt hier gemacht habe,  hat diese Datei Function.py als Ausfuehrbar markiert auf mein System.  Also hier seht ihr dieses X, und das ist gut hinterlegt.  Als ich kann die Datei direkt ausfuehren, das koennte erreichen mit ChangeMod plus X Datei.  Da markiert ihr diese Datei aus Ausfuehrbar.  Und in dieser Datei befindet sich Python Code.", "start": 147.0, "end": 169.0}, {"text": "  Und wichtig, wenn ich die Datei direkt ausfuehren will, ist die sogenannte Shebang.  Hier steht ein Verweis auf den Python Interpreter.  Ich bin Python, das ist mein Standard System Python.  Diese Zahl wird halt eingeleitet mit den Hashtag ausrufverzeichnen.  Und hier koennte ich genauso gut auch den Fahrt von meiner Python Installation im Virtual Environment angeben.", "start": 169.0, "end": 191.0}, {"text": "  Das heisst, ich halte es jetzt ja einmal um.  Hier bin ich gerade in meinen Virtual Rewards Ordner, in meinen Standard Virtual Rewards Ordner,  im Bind Ordner und hier liegt auch die Binary.  Und genauso koennte ich diesen Fahrt zu dieser Binary jetzt hier oben reinschreiben.  Und dann wuerde ich halt die Python Binary erstmal Virtual Environment.", "start": 191.0, "end": 209.0}, {"text": "  Genau, und das ist dann jetzt einfach machen koennen.  Also der Code hier ist jetzt erstmal egal.  Wir wollen jetzt wirklich, jetzt geht es erstmal in das Concept from in, also in das Code.  Jetzt halt auch machen kann, das einfach sagen, Punkt slash fuer Suche, also man ist halt gespashed.", "start": 209.0, "end": 231.0}, {"text": " Soll nach einer ausprobierenden Datei in diesen Verzeichnungssuchung geben,  ich den Namen an und dadurch, dass diese Datei halt als Ausfuehrer markiert ist,  wird jetzt diese Datei direkt wieder ausgehen.  Eine dritte Variante, mit der wir halt dann so viel arbeiten werden ist Jupyter.  Jupyter ist eine interaktive Programmierumgebung und basiert auf Hype halten.", "start": 231.0, "end": 251.0}, {"text": "  Als dann statt direkt in die Interpreter zu arbeiten, was relativ lang um praktisch werden kann,  wird einmal der Hype halten Interpreter verwendet.  Der hat noch ein paar weitere interessante Features, zum Beispiel kann ich hier direkt LS eingeben.  Das kann ich auf den Standard Interpreter glaube ich nicht tun, nein, kann ich nicht.  Da ist Hype halten ganz angenehm.", "start": 251.0, "end": 273.0}, {"text": "  Und aufwander auf Hype halten gibt es dann diese Jupyter Notebooks.  Jupyter muesste genauso wie alle anderen Packete, die wir verwenden, also wie NumPy auch installieren,  aber mit PIP installe Jupyter.  Dann koennte Jupyter einfach starten mit Jupyter Notebook.  Weil ich mich vertippt.  Wenn ihr das macht, dann sieht das ungefaehr wie hier aus, hier habe ich Jupyter Notebook gestartet.", "start": 273.0, "end": 298.0}, {"text": "  Und dann kommen hier ganz viele Blog-Eintraege.  Und am kurzerhin war es hier, ich habe meinen Jupyter ein bisschen konfiguriert.  Normalerweise, wenn ihr Jupyter startet, oeffnet sich direkt mit einem Browser,  dann koennt ihr dann quasi mit den Notebooks arbeiten.", "start": 298.0, "end": 319.0}, {"text": " Also sieht dann so aus, das heisst in dem Ordner hier, naemlich ich Jupyter gestartet habe,  habe ich ein paar Dateien drin, da liegen, wie seht ihr jetzt hier auch.  Dann kann ich halt direkt diese Jupyter Notebook starten.  Und wenn ihr das tut, oeffnet mal das extra Zeit Notebook, dann startet halt Jupyter in Kerne.  Und dann koennt ihr jetzt hier interaktiv arbeiten.", "start": 319.0, "end": 341.0}, {"text": "  Einmal gibt es halt Markdownzellen, da koennt ihr quasi Kommentare und Beschreibungen einschreiben.  Und in diesen Code-Sale kann man halt direkt programmieren.  Auswaehlen kann man die dann mit Shift Enter bzw. wenn man also bei Shift Enter schwindet der ans runter,  wenn man direkt hier bleiben will, Steuerung Enter.  Diese Seite moechte ich wieder verlassen, den Kernel herunterfahren.", "start": 341.0, "end": 365.0}, {"text": "  Und jetzt gehe ich hier wieder in meinen speziellen Notebook.  Hier habe ich ganz viele Slides vorbereitet, dafuer werde ich noch ein extra Plug-in,  mit dem ich dann halt diese Slides praesentieren kann.  Genau, machen wir weiter mit Beinern.  Hier werden die Notebook Dateien in ein GitHub Reproportion.  Das ist dieses hier auf den GitLab von der TU Berlin.", "start": 365.0, "end": 387.0}, {"text": "  In den Ordner Notebooks werdet ihr dann all diese Notebooks finden, mit dem wir arbeiten.  Und ein Beiner ist jetzt ein Tool, was aus dem GitHub Reproportion immer ein Docker Image baut.  Und dieses Docker Image beinhalten dann ein Jupyter Server und eben diese Notebooks aus dem GitHub Reproportion.", "start": 388.0, "end": 419.0}, {"text": " Und wenn ihr dann als Nutzer auf den Beiner link zugreift, dann wird ein Container gestartet,  wo ihr dann quasi interaktiv die Rate mit den Notebooks arbeiten koennt.  Aber Achtung, die Aenderungen, die ihr in den Notebooks macht, werden nicht gespeichert.  Wenn ihr die Aenderungen speichern wollt, muesst ihr halt lokal mit Jupyter Notebook arbeiten.", "start": 419.0, "end": 432.0}, {"text": "  Genau, den Link zu Beinern werden wir auf Isis verknuepfen.  Das sieht dann halt ganz normal aus, wie ein normales Notebook.  Ihr seht ihr, dass ich bei meinem Beiner gerade unterwegs bin.  Die Tutoriumsletter werden wir wahrscheinlich auf Isis hochladen, kann aber auch sein, dass sie die mit auf GitHub pushen.  So, dann wollen wir weitermachen und jetzt richtig anfangen mit Python zu arbeiten.", "start": 432.0, "end": 459.0}, {"text": "  Heisst, wir legen los mit ein paar theoretischen Rezepten, dann werden wir vor allem noch Code sehen in dem Rest des Videos.  Python ist ein Interpreter, hoehere Programmiersprache. Interpreter haben wir schon.  Und das Ziel hinter Python ist gut lesbarer, knapperer Code.  Heisst, Python ist eigentlich fast wie Pseudocode, das heisst, man kann Python-Codes sehr einfach lesen und verstehen.", "start": 459.0, "end": 485.0}, {"text": "  Eine Sache, die damit einhergeht, ist, dass Python zum Beispiel auf geschweifte Klammern verzichtet.  Also, wenn ihr C-Code seht, dann sind in den Ruhm von einer Funktion immer geschweifte Klammern drum.  Bei Python haben wir eigentlich die Strukturen nur durch Einrueckung.  Also, in Stadt von geschweiften Klammern wird dann ein Block an Code immer in derselben Tiefe eingeruckt.", "start": 485.0, "end": 511.0}, {"text": "  Ausserdem ist Python dynamisch typisiert, das heisst, er hat keine Variabendeklaration,  das heisst, er muesste nicht sagen IntHR A oder FloatB,  und dann ihr koennt quasi direkt den Wert an eine Variable uebergeben.  Ausserdem beinhalten Python mehrere Programmierparadepthmen,  das heisst, wir koennen mit Python objektorientiert arbeiten.", "start": 511.0, "end": 537.0}, {"text": "  Es gibt funktionale Programmierungen, das heisst, wir koennen mit den Lambda-Operator kurz und knapp Funktionen uebergeben  und koennen Funktionen in zweiter Ordnung schreiben, also Funktionen in zweiter Ordnung erstellen,  das werden wir nachher noch sehen.", "start": 537.0, "end": 556.0}, {"text": " Und jetzt zum Thema Objektorientierung, ich habe eben einmal ganz kurz dieses Exercise Notebook hier geoeffnet,  neben dem beiden Notebooks, die ich in den Tutorialen hier durchgeben werde,  gibt es halt eine Exercise Notebook, was noch mal tiefer geht in die Information,  um Beinhalte zu Python, wo zum Beispiel auch auf die Objektorientierung eingegangen.", "start": 556.0, "end": 569.0}, {"text": "  Genau, jetzt wollen wir einfach mal loslehnen und einfach eine Variable definieren,  heisst, ihr koennt einfach sagen A ist gleich 1, ohne dass ihr den Datentyp festlegen,  genauso gut koennen wir es halt in der naechsten Zeile A wieder ueberschreiben mit einem String oder mit einem Float.  Einz Punkt ist dann einfach ein Float, waehrend eins halt der IntHR Wert ist.", "start": 569.0, "end": 592.0}, {"text": "  Achtung, es gibt nur Sign IntHRs, heisst, ihr koennt auf wenn ihr quasi nur mit positiven Werten arbeitet,  ist es immer der sehr bedaten Typ, der dahinter steckt.  So, dann koennen wir hier in String definieren 42 und genauso koennen wir hier den String mit einfachen Anfuehrungzeichen  in Staffeln doppelten Anfuehrungzeichen verwenden, macht jetzt endlich keinen Unterschied.", "start": 592.0, "end": 616.0}, {"text": "  Wo das Ganze interessant wird, ist, wenn man einen Text hat mit einem Zitat  und quasi moechte, dass in den Anfuehrungzeichen, in den aeusseren Anfuehrungzeichen, auch innere Anfuehrungzeichen verwendet werden.  Wenn man die halt mit ausgeben moechte, dann muss man halt aussen andere Anfuehrungzeichen verwenden,  als die, die man innen verwenden.", "start": 616.0, "end": 639.0}, {"text": "  So, mit der FRIEN Function kann ich mir die beiden Variablen einfach ausgeben lassen,  zusaetzlich lasse ich mit den Datentypen ausgeben.  Jetzt sehen wir, wir haben hier die 1 und diese 1 ist ein Objekt von der Klasse Integer  und das ist ein Objekt der Klasse String und hier sehen wir halt relativ schoen, wie jetzt da ein FRIEN Zeichnick.", "start": 639.0, "end": 671.0}, {"text": "  Heut am weitere Datentypen sind Listen, also das quasi das Gegenstueck zu Ares aus C.  Der Unterschied zu den Ares in C ist, dass die normalerweise an einen Typ gebunden sind  und in den Listen von Pfeifen kann man verschiedene Datentypen reinschreiben,  also auch als Strings und Floats, die kann man alle miteinander mixen.", "start": 671.0, "end": 694.0}, {"text": "  Hier sehen wir halt, dass das dann wieder ein Objekt der Klasse Liste ist.  Genauso haben wir Diction Ares, Diction Ares sind im wederlichen Hash Maps,  das heisst wir haben Key Value Paere, der ist hier das X waere dann der Key  und der Wert zu den Key ist dann halt die 1.  Dann koennen wir uns jetzt wieder hier die beiden Objekte ausgeben lassen und den Typ.", "start": 694.0, "end": 716.0}, {"text": "  Hier sehen wir das ein Objekt, Typ Diction Ares.  So, dann wollen wir weitermachen mit ganz einfachen Funktionen.  Als hier seht ihr, wie ihr eine ganz einfach Definitionen definieren koennt.  Schluesselwort ist DEF, dann kommt der Funktionsname und dann in Runden klammern die Parameter  und hier seht ihr jetzt auch diese erste Struktur durch Einruecken.", "start": 716.0, "end": 739.0}, {"text": "  Das ist durch einen Doppelpunkt, wo ihr Funktionsrumpf eingeleitet.  Bei Funktionsrumpf hebt sich dann halt hervor von den Funktionskopf durch diese Einruecken.", "start": 739.0, "end": 760.0}, {"text": " So, was hier im Wedelichem passiert ist, dass wir ein Wert uebergeben bekommen,  optimalerweise ein String und an diesen String haengen wir dann an, durch dieses Fluss ist gleich,  das ist ja fuer ihr lends so Value ist gleich Value plus Borealis,  das kann man einfach kurz schreiben, ist plus gleich.", "start": 760.0, "end": 770.0}, {"text": "  Und ja, diese Funktion wird jetzt hier definiert und dann koennen wir diese Funktion direkt aufrufen.  Erst mal definieren wir noch eine Variable Anaconda und dann geben wir die einmal aus,  dann rufen wir die Funktionen auf, uebergeben diesen Wert Anaconda  und nach der Funktion pfinden wir nochmal dieses X, was auch immer in diesem X drin steht.", "start": 770.0, "end": 790.0}, {"text": "  Was ihr jetzt sehen, wenn man das halt ausfuehren ist, das nach Anaconda,  in dem ersten Punkt der Wert in der Variable Unveraenderplatte.  Borealis, dieses X an diese Funktionen uebergeben und hier dieses X, was Value veraendert wird.  Es laesst darauf schliessen, dass fuer dieses einfaches Stringer-Bekt,  wir a call by value haben, das heisst, der Wert dieser Variable wird uebergeben.", "start": 790.0, "end": 814.0}, {"text": "  Das ist aber in Pfeifen nicht immer so der Fall.  Dann wird es ein aehnliches Setup, hier haben wir jetzt wieder den Wert, den wir uebergeben,  dann haben wir jetzt plus gleich eine andere Liste.  Wenn wir jetzt als Wert eine Liste uebergeben und dann eine Liste plus eine Liste haben,  dann werden die Listen einfach einander gehangen.", "start": 815.0, "end": 839.0}, {"text": " Ein aehnlichen Effekt kann man erzielen mit der Funktion append,  das heisst, value ist ja ein Objekt von einer Klasse Liste.  Diese Klasse Liste hat eben diese Funktionen, diese Methode append definiert,  die dann die sieben noch an diese Liste an.  Jetzt definieren wir uns die Liste 123, geben die einmal aus, rufen die Funktionen auf und geben die wieder aus.", "start": 839.0, "end": 860.0}, {"text": "  Und wenn wir die jetzt uebergeben, dann wird halt 456 angehangen, dann wird die 7 angehangen.  Und was jetzt erstaunlich ist, ist, dass bei den zweiten Foehn tatsaechlich der Inhalt  von dieser Liste veraendert wurde.  In diesem Fall haben wir nicht call by value, sondern call by reference.", "start": 860.0, "end": 883.0}, {"text": " Hier wird wirklich die Referenz auf das Objekt uebergeben,  der Objekt wird veraendert und dann sehen wir diese Veraenderungen auch ausserhalb von der Funktion.  Das ist in den ersten Moment ein bisschen verwirrend.  Und setz dich einmal im Python erstmal feststellen, alles ist ein Objekt,  heisst, wird die einfachen Datentypen wie Integers oder Floats.", "start": 883.0, "end": 901.0}, {"text": "  Und Objekte koennen halt entweder veraenderlich sein, so wie wir sie eben gesehen haben,  mit Listen, Directionary, sehen auch dazu, in den Numper-Evers, die wir spaeter kennenlernen.  Objekte koennen aber auch unveraenderlich sein, das heisst, strings, Integers, Floats und Tuple.  So wie wir hier halt eine Stringer hatten, da arbeiten wir dann wirklich mit call by value.", "start": 901.0, "end": 921.0}, {"text": "  Also der Wert kann nicht veraendert werden durch eine Funktion.  Nur veraenderliche Objekte koennen durch Funktionen abgewandelt werden.  So, jetzt haben wir eben eine erste Funktion gesehen,  jetzt wollen wir uns angucken, wie man ein bisschen kompizitere Funktionen liefern kann.  Die erste Sache, die man im Python machen kann, ist Standardwert uebergeben.", "start": 921.0, "end": 946.0}, {"text": "  Das heisst, wir haben eine Funktion mit drei Werten, A, B und C, und drei Parameter.  Und B und C haben halt den Standardwert 42 und 1 vorgegeben.  Was ich jetzt machen kann, ist, haette diese Funktion aufrufen, hier rufe ich sie auf,  und dann gebe ich das Ergebnis der Rap mit Fuend aus.", "start": 946.0, "end": 966.0}, {"text": " Und hier uebergebe ich quasi nur 1 und 2, das wird uebergeben in die ersten Variationen,  das wird uebergeben in die ersten Variationen, Parameter und B, die werden dann auf 1 und 2 gesetzt.  Und fuer die dritten Parameter wird der Standardwert genommen.  Wenn ich nur 1 Parameter uebergebe, werden die Standardwerte fuer die anderen beiden Parameter uebergeben.", "start": 966.0, "end": 980.0}, {"text": "  Muss aber mindestens 1 Parameter angeben, weil hierfuer kein Standardwert bekannt ist.  So, was ich dann auch machen kann, also das sind quasi anonyme Parameter,  die werden in der Reihenfolge noch zugeordnet, dann die Parameter aber auch explizit benennen.", "start": 980.0, "end": 1002.0}, {"text": " Das ist dann ein Kieberparameter, ich die explizit benenne und bei dem Funktionsaufruf sage ich,  wie C auch 2 setzen, A auf 1 und B auch 2, und das ist die Reihenfolge egal,  dann kann ich den in einer beliebigen Reihenfolge uebergeben.  Eine andere Variante, was man auch mit den Parameter machen kann, man kann ein Parameter typisieren.", "start": 1002.0, "end": 1019.0}, {"text": "  Das heisst, ich kann sagen, A soll vom Typ in sein, B soll vom Typ in sein,  oder String oder Float oder was auch immer.  Allerdings wird das Ganze von dem Interpreter nicht ueberprueft.  Also ich kann hier diese Funktionen aufrufen, mit 1 und 2, also mit Integers,  dann aber genauso gut einfach Springs uebergeben und das funktioniert trotzdem,  und dass ich einen Fehler bekomme.", "start": 1019.0, "end": 1040.0}, {"text": "  Das heisst, dass es quasi nur eine Randnotie an der Information beim entwickeln,  wird aber von dem Interpreter selbst nicht kontrolliert.  Also es ist ja nicht streng typisiert.  Was noch relativ interessant ist, wir haben vorhin eine Funktion gesehen,  die eine Rueckgabe wert hatte, ganz am Anfang.", "start": 1040.0, "end": 1064.0}, {"text": " Wir haben eben Funktionen gesehen, die hatten eine Rueckgabe wert,  und jetzt sehen wir hier eine Funktion, die hat zwei Rueckgabe Werte,  naemlich einmal A plus B, einmal A mal W.  Das funktioniert bei den Python auch, in Python koennen Funktionen immer tuppel zurueckgeben, also zwei Werte.  In dem Fall geben wir halt zwei Werte zurueck, und die koennen wir direkt durch zwei Variabeln im Fall nehmen.", "start": 1064.0, "end": 1085.0}, {"text": "  Also wir sagen die Red C ist dann halt A plus B, und die ist Red A mal B.  Genauso gut koennen wir aber auch einfach sagen, E ist gleich diese Ausgabe.  Dann gebe ich das halt alles ja einmal aus, C und D sind halt 3 und 2,  einmal 1 plus 2 ist 3, einmal 1 mal 2 ist 2.  Wenn ich hier E ausgebe, dann sehe ich, okay, da schicken halt beide Werte drin.  Hier kriege ich halt dieses tuppel zurueck.", "start": 1085.0, "end": 1109.0}, {"text": "  Und wenn ich das halt mit zwei Variabeln aufgebe, wird dieses tuppel direkt aufgeholt.  Relativ interessante Eigenschafts an tuppeln,  wenn ich kann auch sagen F ist gleich 3, 4, 5, 6.  Und jetzt koennt ihr zum Beispiel sagen, B, H und I sind jetzt F.  Und dann werden diese drei Werte aus dem tuppel tatsaechlich direkt an diese drei Variabeln aufgeteilt und aufgeloest.", "start": 1109.0, "end": 1147.0}, {"text": "  Ja, jetzt koennen wir an der Stelle nochmal zurueckkommen auf die Python-Werteile, die ich am Anfang einmal gezeigt habe,  wo wir uns den Code nicht genauer angeguckt haben.  Haben wir das erste Teil halt diese Shebang.  Und jetzt haben wir diese Funktionen hier.  In der Funktion definieren wir einmal die Variable Ausgabe.  Dann haben wir hier ein bisschen Kontrollfluss.", "start": 1147.0, "end": 1168.0}, {"text": "  Das heisst, wir checken, ob diese der Parameter Text wirklich gesetzt wird, wird er nicht gesetzt.  Also rufe ich einfach eine Funktion auf, dann steht auf Nann.  Das ist hier nicht der Fall.  Also wenn das nicht der Fall ist und das nicht Nann ist, dann haenge an die Ausgabe was an.  An der Stelle haben wir ein Format String stehen.", "start": 1168.0, "end": 1187.0}, {"text": "  Genau, markiert wird er oder eingeleitet wird er mit den Anfuehrungszeichen.  Dadurch haben wir ein String.  Und durch dieses F davor weiss Python, dass ein Format String ist.  Dann kann ich den geschweiften Klammern direkt die Variable reinschreiben.  Und dann wird hier an dieser Stelle direkt der Werte Variabeln eingesetzt.  Und dann gebe ich den Text aus.", "start": 1187.0, "end": 1210.0}, {"text": "  Normalerweise, wenn wir jetzt diese beiden unteren Zahlen hier mal ignorieren oder auskommen hier mit dem Hashtag,  dann wuerde jetzt, wenn ich Python, also wenn ich diese Datei einfach ausfuehrung Python uebergebe,  dann passiert einfach nichts.  Bei der Interpreter definiert jetzt intern diese Funktionen,  aber die Funktionen wird er nun so aufgerufen.", "start": 1211.0, "end": 1229.0}, {"text": "  Und ich wollte das machen, jetzt koennte ich einfach sagen hier function.  Und jetzt wird aber jedes Mal diese Funktion aufgerufen.  Heisst auch, wenn ich jetzt hier diese Funktion importiere und sie jetzt ausfuehrere,  dann wird sie moment ohne das.  Das funktioniert jetzt nicht, verdoppt.", "start": 1232.0, "end": 1257.0}, {"text": " Dann wuerde diese, also auch wenn ich jetzt diese Funktionen hier nicht aufrufen wuerde,  nur durch den Import wuerde jetzt Funktion direkt ausgefuehrt werden.  Und das will ich aber in der Regel nicht.  Was ich in der Regel moechte, ist, dass der Funktion nur ausgefuehrt wird.  Wenn ich das die Datei direkt in Interpreter uebergebe und nicht ausgefuehrt wird,  wenn ich sie importiere.", "start": 1257.0, "end": 1273.0}, {"text": "  Das kann ich erreichen durch dieses,  ist einfach wieder normaler Kontrollfluss.  Ich gucke, ob diese Variable unter unterstrich,  unterstrich, unterstrich auf Main gesetzt ist.  Und wenn ja, dann mache irgendwas.  Und diese Variable Name ist genau dann auf Main gesetzt,  wenn ich die Datei direkt in Interpreter uebergebe oder sie quasi direkt auf den Terminal ausfuehren.", "start": 1273.0, "end": 1304.0}, {"text": "  Das ist direkt diese Datei ausfuehrer, dann wird auch die Funktion aufgerufen.  Wenn ich jetzt dagegen aber eben diese Datei nur importiere,  dann wird die nicht aufgerufen.  Da muss ich sie explizit aufrufen.", "start": 1305.0, "end": 1328.0}, {"text": " Als durch diesen Spezialteil hier mit den fname gleich Main,  kann ich quasi meine Funktion oder mein Module,  mein Pipenmodul hier sowohl dafuer anpassen,  dass ich es direkt ausfuehren kann,  als auch ermoeglichen, dass ich mit den Funktionen halt weiterarbeiten.  Ja, dann haben wir eben jetzt schon in dieser Datei hier gesehen,  wie man Funktionen definieren kann.", "start": 1328.0, "end": 1345.0}, {"text": "  Und wir haben auch schon ein bisschen einen Kontrollfluss gesehen.  Und mit dem Kontrollfluss, wenn wir jetzt weiter machen.  Das ist ja ein einfaches Beispiel.  Ich definiere mir den string x gleich Hallo.  Und dann pruefe ich, ob x gleich 0 ist.  x ist offensichtlich nicht gleich 0, sondern ein string.  Heisst, das print x ist gleich 0, sollte nicht ausgegeben werden.", "start": 1345.0, "end": 1367.0}, {"text": "  Und wenn das nicht der Fall ist,  ich hier also nicht reingehe,  den gehe ich in den x-Teil.  Hier sehen wir wieder relativ schoen.  Wir haben hier den inneren, den aeussersten Teil.  Durch einen Doppelpunkt wird dann ein neuer Codeblock eingeleitet,  der dann einhaltig eingerueckt ist.", "start": 1367.0, "end": 1390.0}, {"text": " Und genau in diesen x-Teil haben wir dann wiederum Verzweigung  und checken, ob der Buchstabe A in x enthalten ist.  Und offensichtlich ist es an A in Hallo enthalten.  Und dann gebe ich halt aus, ja, A ist in den string.  Und ich halte wieder den format string.  Also das f davor, dadurch ist es ein format string.  Und geschweiften Klammern sage ich dann,  bittepark hier, dem waert x rein.  Genau.", "start": 1390.0, "end": 1413.0}, {"text": "  Das heisst, hier sollte dann dastehen, A ist in x, also Hallo enthalten.  Und wenn das nicht der Fall sein sollte, dann gebe ich was aus.  Aber das funktioniert, wie zu erwarten,  was jetzt hier relativ haesslich ist,  ist, dass ich halt dieses if, else habe und dann in dem else wieder ein if, else.  Das kann ich schoener loesen, mit denen ich schluesse, wo es else ist.", "start": 1413.0, "end": 1438.0}, {"text": "  Also ich frage hier ab, if x, wenn nicht, aber das sie gilt, dann tue das.  Und wenn das auch nicht gilt, dann tue das.  Quasi genau den gleichen Effekt.  Genau, jetzt wollen wir uns im weiteren umschleifen kuemmern.  Dafuer muessen wir die range Function kennenlernen.  Die range Function kriegt im wenigen Reil werte uebergeben,  am start end non step.", "start": 1438.0, "end": 1460.0}, {"text": "  Und das habe ich jetzt hier mal exemplarisch auf 2, 11 und 3 gesetzt.  Wenn ich das dann ausfuehre, kriege ich ein range Objekt.  Weil ich dieses range Objekt mit list, der von so ein list in eine liste caste,  dann kann ich direkt die werte sehen, die bei den werten werten,  die werte sehen, die bei den range Objekt rauskommen.  Und zwar leben wir bei 2 los.", "start": 1460.0, "end": 1483.0}, {"text": "  Step ist 3, das heisst wegen Genen in Dreier schritten, also 2 plus 3 ist 5, 5 plus 3 ist 8,  8 plus 3 ist 11, 11 ist aber schon der letzte Wert,  der letzte Wert ist immer nicht mehr enthalten.  Genau, jetzt koennte ich das mal anpassen und koennte hier einfach jetzt eine 11 reinschreiben.  Dann wuerde step automatisch auf 1 gesetzt werden und start ist 0.", "start": 1483.0, "end": 1503.0}, {"text": "  Wir haben alle Werte von 0 bis inklusive 10, aber nicht mehr die 11 in einer Schrift.  Das sehen wir jetzt hier.  Und das kann man dann relativ schoen verwenden, diese range Funktionen um zu iterieren.  Dann haben wir einmal den for loop.  Da haben wir jetzt hier drei verschiedene Varianten.  Einmal haben wir jetzt index, index ist immer noch dieses range Objekt hier.", "start": 1503.0, "end": 1525.0}, {"text": "  Das passt sich mal so an wie es vorher war.  Genau und jetzt sage ich vor ich in diesem range Objekt.  Das koennte ich also jetzt hier auch einmal mal explizit direkt hinschreiben start and step.  Und dann gebe ich fuer jede iteration das i aus dem Wert und dann habe ich 2, 5, 8.  Die Synthesie ist relativ intuitiv vor ich in eben den range Objekt.", "start": 1525.0, "end": 1550.0}, {"text": "  Genauso gut kann ich aber auch einfach ueber Listen integrieren.  Das heisst, die habe ich die Liste mit dem Buchstaben A, die Liste mit dem Buchstaben B.  Koennten auch 2 beliebige Floats sein.  Dann iteriere ich jetzt hier rueber und vor i von dem Buchstaben sage ich print i.  Dann gebe ich eben einmal A aus einmal B.", "start": 1550.0, "end": 1572.0}, {"text": "  Genauso kann ich auch ueber Springs iterieren und dann gehe ich einfach auch ueber die einzelnen Buchstaben OBA.  Also ueber A und ueber B.  Dann haben wir jetzt hier eine weitere Liste.  Und zwar mache ich jetzt folgendes, ich caste einmal das Range Objekt, was wir vorher haben, jetzt fest auf einer Liste.  Gebt man das aus, das heisst, die habe ich jetzt wirklich Liste 2, 5, 8.", "start": 1572.0, "end": 1595.0}, {"text": "  Jetzt moechte ich ueber die Listen Indices iterieren, also 0, 1, 2.  Jetzt kann ich sagen vor i in range.  Hier hilft mir jetzt eben diese Range Funktion Laenge Index.  Laenge Index ist jetzt eben die Laenge von dieser Liste und das ist 3.  Das ist die sage vor i in range 3.  Hier sage ich jetzt print index value und index ist eben immer 0, 1, 2.", "start": 1595.0, "end": 1625.0}, {"text": "  Und hier in den Index von i, kauf ich eben auf den i-Ton Eintracht in die Liste zu, also 2, 5 und 8.  Dann sage ich hier print und hier sehen wir jetzt eine andere Variante, wie man mit Format Springs arbeiten kann.  Das ist an Schleifern in F davor.  Und jetzt habe ich den Swing geschrieben und dieser Swing ist ja auch ein Objekt mit der Funktion Format.", "start": 1625.0, "end": 1651.0}, {"text": "  Und hier kann ich jetzt in geschweiften Klammern 0, in geschweiften Klammern 1, in geschweiften Klammern ueber was hinschreiben, also 2, 3, 4 und in Index.  Und dann werden die Parameter, die ich der Format Funktion uebergebe, der Reihenfolge nachher eingesetzt.", "start": 1651.0, "end": 1669.0}, {"text": "  Also i ist der erste Wert, also der nullte Wert, der wird an stelle 0 eingefuegt, das ist der erste Wert, der wird an stelle 1 eingefuegt und so weiter.  So, genauso gut, wenn ich hier sowas machen moechte, kann ich aber auch einfach sagen, vor i und e in enumer rate index.  Enumer rate gibt eine Liste von tuppeln zurueck.", "start": 1669.0, "end": 1690.0}, {"text": "  Also genau gesagt ein enumer rate Objekt, aber in dem versteckt sind quasi tuppeln, also eine Liste von tuppeln.  Und diese tuppeln enthalten dann jeweils einmal den Index und das Objekt von dieser Liste, die wir quasi enumer rate.  Sondern habe ich am Ende fuer i und e genau denselben Effekt.  i sind quasi immer die Indizies und e sind eben diese Objekte, also 2, 5, 8, neb.", "start": 1690.0, "end": 1719.0}, {"text": "  So, genauso gut, kann man jetzt auch ueber Diction Erroris ertrigenen, das heisst, die habe ich in der Diction Errori von Anfang.  Und hier ist der Schluessel quasi d von items.  Dann kriege ich wieder eine Liste an tuppeln und zwar an tuppeln mit den Key values.  Da ist k, ist der Key, v ist der Value, kann ich mir das ausgeben, also x1, y abc, z3.", "start": 1719.0, "end": 1747.0}, {"text": "  Genau, auch moeglich sind halt Weilschleifen, das ist ja einfach i ist gleich eins und so lange i kleiner als 3, es gebe i aus und setze i um eins nach oben.  Das ist denke ich relativ enttweet.  Jetzt kommen wir so langsam zum Ende und zwar hatte ich am Anfang eben auch erwaehnt, dass Python zum einen Objektorientierung unterstuetzt.", "start": 1747.0, "end": 1766.0}, {"text": "  Das brauchen wir halt in dem Semester nicht, deswegen seidet ihr euch da, wenn ueberhaupt, wenn es euch interessiert, das Exercise-Knobbock eingucken.  Fuer mich ist eben die funktionale Programmierung mit dem Lambda-Operator.  Der Lambda-Operator, moeglich ist es, uns halt kurz und knapp Funktionen zu definieren.", "start": 1766.0, "end": 1783.0}, {"text": "  Also hier sage ich jetzt einfach diese Funktionen f, das ist gleich lambda, x und y, das sind die beiden Parameter.  Und die beiden Parameter werden verarbeitet zu x plus y, das heisst, das gibt dann x und y zurueck.  In anderen Worten, das ist equivalent zu def, oops, def, f, x und y, which earn x plus y.  Das ist quasi genau das gleiche hier.", "start": 1783.0, "end": 1818.0}, {"text": "  Ja, und dann kann ich diese Funktion halt genauso aufrufen, ich sage f von 2 und 3, muesste sein 2 plus 3 ist 5, uebergebe ich dann z, gebe z aus und z ist 5.  Genau, und das ermoeglicht mir halt relativ schoen funktionale Programmierung.  Das heisst, in lieben Fall habe ich jetzt die Liste 1, 2, 3, also kann ich mit Map und Filter bestimmte Operationen auf diese Liste ausfuehren.", "start": 1819.0, "end": 1838.0}, {"text": "  Map bendet eine Funktion, die wir hier als Lambda-Funktion schreiben, auf jedes Element dieser Liste an.  Das ist die Lambda Funktion, die wir in Map uebergeben, ist Lambda von x, x mal 2, das heisst, jeder Eintrag wird verdoppelt.", "start": 1838.0, "end": 1868.0}, {"text": " Also wir sagen mit Map fuehrte diese Funktion auf jedes Listenelement aus und zwar auf dieser Liste, dann kriegen wir ein Map-Objekt, dieses Map-Objekt,  kasten wir wieder zu einer Liste, der Listsfunktion und geben es aus, dann sehen wir hier haben wir tatsaechlich 2, 4 und 6, also genau jeweils das Elementweise doppelt von dieser Liste.", "start": 1870.0, "end": 1884.0}, {"text": "  Die Filterfunktion verlangt eine Funktion als Eingabe, die Tour oder Vollzucht gebt, hier hat wieder als Lambda Funktion gegeben und wir sagen jetzt Lambda x, x ist groesser als 2,  das heisst genau dann, wenn x groesser als 2 ist, steht hier Tour, sonst steht da Vollz und alle Elemente fuer diese Funktion hier zu Vollz ausgewertet wird, die werden aus der Liste entfernt.", "start": 1884.0, "end": 1907.0}, {"text": "  Heisst bei 1, 2, 3 bleibt eigentlich nur noch die 3 uebrig, weil die 3 ist der einzige Gewert, der groesser als 2 ist und dann sehen wir, wir bekommen zurueck Liste 3.  Genau wie gesagt, koennen wir erstmal einen FilterObjekt zurueck, das wir wieder zu einer Liste kasten und das ist dann eben Liste 3.", "start": 1907.0, "end": 1923.0}, {"text": "  Map und Filter sind sogenannte Funktionen 2. Ordnung, als es ist eine Funktion, die eine andere Funktion uebergeben bekommt, das Parameter und damit ja arbeitet.  Genau das hier nochmal ein bisschen ausfuehrlicher, hier haben wir die Funktion 2. Ordnung, Apply, Apply bekommt eben eine Funktion F und die beiden Parameter A und B und Apply wendet halt diese Funktion F einfach auf A und B an.", "start": 1924.0, "end": 1950.0}, {"text": "  Jetzt koennen wir uns hier kurz und knackig mit dem Lambda-Operator eine Funktion definieren, sagen halt x und y sollen zu x plus y ausgewertet werden, also dieselbe Funktion wie vorhin.", "start": 1951.0, "end": 1964.0}, {"text": "  Das koennen wir halt in diese Funktion 2. Ordnung, Apply, diese Funktion uebergeben und Apply wendet Funktion einfach auf 3 und 4 an, dann koennen wir 3 plus 4 zurueck, uebergeben das dann C und C wird ausgegeben und ist die.  Genau, damit sind wir jetzt am Ende von den ersten Video angekommen.", "start": 1965.0, "end": 1976.0}, {"text": "  Ein Hinweis, das war jetzt relativ kurz oder nicht ganz so kurz, mit 30 Minuten, aber relativ kompakt gewoehnelt.  Eine Programmiersprache lernt man vor allem durch Anwendung.  Also ich wuerde euch empfehlen, wirklich einmal durch das Exercise Notebook durchzugehen.", "start": 1977.0, "end": 1991.0}, {"text": "  Da koennt ihr nochmal einen tieferen Einblick im Python, guckt euch das an und genau ihr bekommt nochmal da was mit zur Objektorientierung.  wirklich verstehen tut es dann aber halt erst, wenn ihr selber Code schreibt.  Genau, in jedem Sinne viel Erfolg und bis zum naechsten Video mit der Lina Wiederholung.", "start": 1991.0, "end": 2000.0}]}]