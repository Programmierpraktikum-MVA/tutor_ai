[{"lecture": "25797_46_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns der schnellen Fourier-Transformation widmen, die auch kurz als FFT bezeichnet wird.  Mein Name ist nach wie vor Julian, fuer alle die es schon wieder vergessen haben.  Der Ansatz den wir hier verfolgen wollen beruht auf der Feststellung, dass die diskrete Fourier-Transformation  eines Signals der Laenge 2n durch zwei kleinere DFTs der Laenge n berechnet werden kann.", "start": 0.0, "end": 36.0}, {"text": "  In diesem Sinne koennen wir unser Signal immer und immer wieder halbieren und wenden so, dass die Wight-in-Conquer-Prinzip an,  dass man in Deutsch auch Teilen- und Herrschen-Prinzip nennt.  Damit koennen wir die Komplexitaet reduzieren des Problems von o von n Quadrat auf o von n Log n.", "start": 36.0, "end": 60.0}, {"text": "  Und den Algorithmus, den wir hier zu anschauen werden, kommt von Cooley und Tucky, die den 1965 veroeffentlicht haben.  Aber hier sei Vorsicht geboten, denn man kann den nur auf Signale der Laenge 2 hoch n anwenden.  Das folgende Beispiel soll die Grundidee der FFT veranschaulichen.  Hierzu betrachten wir eine DFT-Matrix fuer eine Signalinge in Gleich 2.  Diese ist, wie hier zu sehen, aufgebaut.", "start": 60.0, "end": 85.0}, {"text": "  Mit der Einheitswurzel Omega 2 gleich minus 1.  Damit ergibt sich diese Matrix hier.  Die naechste groessere DFT-Matrix bezieht sich auf eine Signalinge n Gleich 4.  Und ist hier zu sehen, die Einheitswurzel Omega 4 ist gleich i.  Und damit ergibt sich dann diese Matrix hier.  Im naechsten Schritt sollen die Spalten dieser Matrix umgeordnet werden.", "start": 85.0, "end": 119.0}, {"text": "  Dies kann erfolgen, indem man sie mit einer Permutationsmatrix P multipliziert.  Wie genau die aussieht, ist naeher im Skript beschrieben.  Die Umordnung soll so erfolgen, dass Spalten in dieser Matrix mit geraden Index nach vorne sortiert werden  und Spalten mit ungeraden Index nach hinten.", "start": 119.0, "end": 146.0}, {"text": " Wenn wir jetzt die Spalten durchnummerieren,  heisst es, dass sich 0 und die zweite Spalten nach vorne sortiert werden.  Also die ist dann wieder hier zu finden.  Die zweite Spalten ist dann hier zu finden.  Jetzt kommen die ungeraden Spalten.  Spalten 1 ist dann hier zu finden.  Und Spalten 3 bleibt hier hinten am Ende.", "start": 146.0, "end": 176.0}, {"text": "  Als naechstes schauen wir uns die Multiplikation einer Matrix F mit der DFT-Matrix Omega 2 Strich an.  Die Matrix F wird im Allgemeinen so angegeben  und fuer Endgleich 2 ergibt sie sich zu dieser Matrix hier.  Die Matrix Omega 2 Strich ist hier gegeben,  sowie oben das Strichlein soll anzeuten, dass wir hier den Normierungsfaktor nicht mitnehmen.  Und das Produkt daraus sieht man dann hier.", "start": 176.0, "end": 212.0}, {"text": "  Wenn wir jetzt wieder einen Blick auf die Matrix hier oben werfen,  dann koennen wir manche Teile von hier unten wieder entdecken.  Zum einen diese Matrix Omega 2 Strich hier finden wir in den vorderen Spalten und Seilen,  oben sowie auch hier unten.  Und das Produkt hier finden wir hinten oben und mit minus 1 multipliziert hier hinten unten.", "start": 212.0, "end": 247.0}, {"text": "  Die Unterteilung in einzelne Bloecke dieser Matrix ist hier unten nochmal zu sehen.  Und wie eingangs schon erwaehnt, koennen wir diese Unterteilung durchfuehren fuer alle Signale der Laenge 2n.", "start": 247.0, "end": 274.0}, {"text": " Haben wir jetzt nun ein Ausgangssignal der Laenge 2 hoch,  koennen wir also diese Unterteilung immer und immer wieder machen  und koennen so zu einer rekursiven Berechnungsweise der Fourier-Transformation gelangen.  Wenn sich an dieser Stelle aber fragt, wie genau das geht,  den moechte ich auf das Zusatzvideo hinweisen, das ich aufgenommen habe, wo das genauer erklaert wird.", "start": 274.0, "end": 298.0}, {"text": "  Ansonsten geht es jetzt hier weiter mit einem Codebeispiel des rekursiven Algorithmus.  Hier sehen wir nun eine Implementierung der rekursiven FFT.  Der rekursive Aufruf erfolgt immer in diesen zwei Zeilen  und mit diesem Befehl sortieren wir uns immer nur die Eindraege mit geraden Index raus und hier die mit ungeraden.", "start": 298.0, "end": 333.0}, {"text": "  Das machen wir dann immer und immer so weiter, bis wir bei Signalen der Laenge 1 ankommen,  geben dann dieses Signal zurueck  und dann haben wir hier ein Array der Laenge 1  und dasselbe wird dann auch hier passieren mit den ungeraden Indizes.", "start": 333.0, "end": 365.0}, {"text": " Und dann berechnen wir uns an der Stelle die Einheitswurzel, zu dem Zeitpunkt ist dann endgleich 2  und dann berechnen wir hier die Rueckgabewerte von unserer rekursiven Funktion.  Diesen Rueckgabewert Z weisen wir jetzt einer Rekursionsstufe weiter oben dem Z1 zu.  Dasselbe wird auch bei dem Z2 passieren, d.h. Z1 und Z2 sind Arrays der Laenge 2.", "start": 366.0, "end": 391.0}, {"text": " Dann gehen wir hier unseren Programmablauf weiter  und gehen so die Rekursionsstufen nach oben bis unser letztes Signal,  dass wir zurueckgeben, die Laenge unseres urspruenglichen Ausgangs-Signal hat.  Wie in der Vorlesung erwaehnt wurde, braucht man fuer die inverse Fourier-Transformation keine neue Funktion,  sondern man kann die Vorwaerts-Transformation wieder verwenden.", "start": 391.0, "end": 413.0}, {"text": "  Man muss aber kleine Modifikationen hier vornehmen.  Wir testen nun unseren Algorithmus mit einer Sinus-Schwingung der Laenge 8.  Das Ergebnis, was wir hier sehen, ist vergleichbar mit dem, was auch im Script zu finden ist,  naemlich dass der Realteil dieser transformierten ueberall 0 ist  und nur der Imaginerteil vom zweiten und vom letzten Eintrag sind von 0 verschieden.", "start": 413.0, "end": 453.0}, {"text": "  Zwar unterscheiden die sich auch nur im Vorzeichen hier, d.h. dass dieser Wert der Komplexkonjugierte von diesem Wert ist.  Ausserdem wollen wir ueberpruefen, was passiert, wenn wir unser Signal erst transformieren und dann wieder ruecktransformieren.  Die Erwartung ist natuerlich hier, dass sich nach Transformation und Ruecktransformation nichts geaendert hat.  Das wird dann hier ueberprueft.", "start": 453.0, "end": 478.0}, {"text": "  Ausserdem wollen wir unseren Algorithmus mit dem von NumPy implementierten FFT-Algorithmus vergleichen.  Wir sehen, dass sowohl durch unsere Transformation und Ruecktransformation nur ein sehr, sehr geringer Fehler auftritt  und dass auch unsere Implementierung sehr nahe an der NumPy FFT-Funktion liegt.  Wie aus dem Rekursiven Algorithmus ein iterativ verfolgt, habe ich im Zusatzvideo auch erklaert.", "start": 481.0, "end": 513.0}, {"text": "  Hier will ich euch diese iterative FFT nur vorstellen.  Dafuer muessen wir zuerst eine Umordnung des Signals vornehmen, indem wir auf jeder Ebene hier die Elemente des Areas mit geraden Index nach vorne sortieren.  Hier, 2, 4, 6.  Und die mit ungeraden nach hinten.", "start": 514.0, "end": 547.0}, {"text": "  Und dann im naechsten Layer machen wir das wieder fuer diese unterteilten Bloecke, indem wir die geraden Index nach vorne sortieren und die ungeraden nach hinten.  Das selbe machen wir dann auch hier.  Und in dem Schritt sind schon immer die geraden und die ungeraden Index richtig sortiert, weil auch diese Bloecke nicht mehr so lang sind.", "start": 547.0, "end": 572.0}, {"text": "  Um diese Umordnung vorzunehmen, koennen wir auch die Erkenntnis nutzen, dass wir zur selben Reihenfolge hier hinten gelangen.  Wenn wir einfach die Areas Indices als die naeherge Zahlen schreiben hier, dann deren Reihenfolge umdrehen.  Hier wird die 0, 0, 1 zu 1, 1 zu 0 und daraus wieder eine Dezimalzahl bilden.", "start": 572.0, "end": 602.0}, {"text": "  Das ist zum einen viel geschickter und geht auch schneller als diese Sortiererei hier oben.  Nach dem Umsortieren koennen wir die folgende Transformation durchfuehren.  Wir gehen das mal langsam durch.  Also diese Elemente werden immer mit der entsprechenden Einheitswurzel hier multipliziert.  Auch diese und diese und diese und diese.", "start": 603.0, "end": 636.0}, {"text": "  Ausserdem wird an diesen Stellen hier immer noch das Produkt mit minus 1 multipliziert.  Also hier wird dann Omega 2 0 mal Z6 gerechnet und hier minus Omega 2 0 Z6 an dieser Stelle.  Das heisst hier hinten wird eigentlich immer dieses Produkt abgezogen.  Den ganzen Ablauf koennen wir nun in drei ineinander geschachteten Vorschleifen durchfuehren.", "start": 636.0, "end": 668.0}, {"text": "  Indem wir jetzt mit der ersten Vorschleife ueber diese Layer hier etariieren.  Mit der naechsten Vorschleife etariieren wir dann ueber diese Teil Areas, die hier so eingekastet sind.  Das waeren auf der Ebene 4, auf der Ebene nur noch 2 und auf der Ebene 1.  Und in der letzten Schleife etariieren wir ueber die Elemente in diesen Teil Areas.  Also dort drin, hier drin und auch dann in diesem.", "start": 668.0, "end": 712.0}, {"text": "  Wichtig ist noch zu erwaehnen, dass diese Unterteilungen hier bei einer spaeteren Implementierung rein fiktiv sind.  Das heisst in jedem Layer liegt uns ein Array der Laenge N gleich 8 vor.  Und auf diesem Array fuehren wir halt diese Operationen aus.  Ausserdem kann das ganze Inplace geschehen.  Das heisst wir brauchen nicht immer noch ein zusaetzliches Array, um die Ergebnisse dort drin abzuspeichern.", "start": 712.0, "end": 738.0}, {"text": "  Da muss man sich aber ein bisschen geschickt anstellen.  Das kann man naemlich machen, indem man hier diese Produkte hinten ausrechnet, abspeichert und dann in einem Integrationsschritt immer beide Werte hier bestimmt.", "start": 738.0, "end": 762.0}, {"text": " Das heisst hier unten wuerde das bedeuten, dass wir das Produkt von diesem Element mit dieser Einholzwurzel berechnen  und dann in einem Integrationsschritt diesen Wert und auch diesen Wert berechnen.  Im naechsten Integrationsschritt wuerden wir dann diesen und diesen berechnen und so weiter.  An diesem Schema kann man sich auch gut klarmachen, wie man zu einer Laufzeit von o von nLockn kommt.", "start": 762.0, "end": 787.0}, {"text": "  Dazu stellen wir fest, dass wir in jedem Layer nach wie vor in Rechnungen machen muessen.  Also 8 Stueck in diesem Fall.  Grotz dieser gedanklichen Unterteilungen hier die Anzahl der Punkte, die wir ausrechnen muessen, bleibt immer gleich.  Das heisst wir haben Pro-Schritt 8 Rechnungen und wir haben 3 Layer, in denen wir 8 Rechnungen durchfuehren muessen.", "start": 787.0, "end": 832.0}, {"text": "  Diese 3 kann man auch berechnen als Logarhythmus zur Basis 2 von 8 mal 8.  Somit sieht man, wie man zu einer Laufzeit von o von nLockn kommt, denn wir haben hier ja hengleich 8 gewaehlt.  Wir probieren unseren FFT-Algorithmus nur noch an einem Beispiel aus.  Dazu betrachten wir diesen Signalvektor.", "start": 833.0, "end": 866.0}, {"text": "  Und von unserem Schema muessen wir dafuer, da wir nun die Laenge 4 haben, hier einen Teilaufschnitt betrachten.  Zunaechst muessen wir aber natuerlich unser Signal wieder umordnen.  Das heisst wir sortieren die Elemente mit geraden Index nach vorne, hier die 4 und hier die 3.  Und die mit ungeraden Index nach hinten, hier die 2 und hier die 1.", "start": 866.0, "end": 906.0}, {"text": "  Im naechsten Schritt benoetigen wir nun die 2. Einheitswurzel, Omega 2 dies gleich minus 1 und hoch 0, ergibt es 1.  Wir befinden uns an der Stelle jetzt im 0. Layer.  Das heisst hier kommen diese Eintraege in unserem Schema waren einzeln.  Und jetzt sortieren wir oder berechnen wir uns diese Elemente in unseren Bloecken.  Das heisst das hier ist nachher ein Block und das hier ist nachher ein Block.", "start": 906.0, "end": 941.0}, {"text": "  Um jetzt unser Schema das vorgibt, verrechnen wir die 2 vorderen Werte miteinander hier und die 2 hinteren miteinander hier.  Wobei der hinteren Wert, also diese 3, immer mit dieser Einheitswurzel oder mit dieser Einheitswurzel mit exponent 0 am Ende dieser 1 hier multipliziert wird und an der Stelle addiert und hier subtrahiert wird.", "start": 941.0, "end": 970.0}, {"text": "  Dasselbe passiert dann hier unten auch, nur mit 2 und der 1. Und die 1 wird dann hier wieder damit multipliziert, hier addiert und hier subtrahiert.  Und das Ergebnis sehen wir dann hier in diesem Vektor.  Fuer den naechsten Schritt benoetigen wir nun die 4. Einheitswurzel, die gleich i ist.  Wir befinden uns jetzt im ersten Layer an der Stelle und wir kommen von diesem Nullten.", "start": 970.0, "end": 998.0}, {"text": "  Dieses Nullte hatte 2 Bloecke, einmal den hier oben und einmal den hier unten.  Und jetzt fuehren wir wie in unserem Schema diese ueberkreuzweise Berechnung aus, indem wir die 2 hierhin fuer diesen Eintrag berechnen  und gleichzeitig fuer den hier und auch die 2 Werte, den hier und den hier, um diesen Eintrag zu berechnen und auch hier unten wieder beide, um diesen Eintrag zu berechnen.", "start": 998.0, "end": 1043.0}, {"text": "  Um diesen Eintrag und diesen Eintrag zu berechnen, nehmen wir die Einheitswurzel wieder mit exponent Null, das heisst sie ergibt 1  und wir addieren hier wieder dieses Produkt aus diesem Wert mit der Einheitswurzel und hier subtrahieren wir diesen Wert.", "start": 1043.0, "end": 1073.0}, {"text": " Fuer den zweiten Eintrag sowie fuer diesen Eintrag hier multiplizieren wir hier diese 1 mit der Einheitswurzel mit exponent 1, also i,  addieren dieses Produkt hier und subtrahieren dieses Produkt hier.  Und wenn wir das dann ausrechnen, bekommen wir diesen Vektor und haben damit den letzten Schritt gemacht und die FFT fuer unser Ausgangs-Signal berechnet.", "start": 1073.0, "end": 1094.0}, {"text": "  Damit sind wir sozusagen mit dem Pflichtteil zur FFT durch.  Interessierte koennen gerne noch das Zusatzvideo anschauen. Also macht's gut.", "start": 1094.0, "end": 1101.0}]}]