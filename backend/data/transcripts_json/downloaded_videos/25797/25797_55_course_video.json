[{"lecture": "25797_55_course_video", "Timestamps": [{"text": "  Hallo und jetzt noch einen kurzen Blick auf Aufgabe 4.  Es geht um Strichfigur Animation.  Die Idee ist, dass wir fuer jedes Koerperglied dieser Strichfigur eine gewisse Position zu festen Zeitpunkten angeben.  Diese Position zusammen bilden dann einen Zustand.  Den Zustand fassen wir als ein Frame auf und wir rein diese Frames aneinander, um eine Animation zu erzeugen.", "start": 0.0, "end": 43.0}, {"text": "  Die Sache ist, dass wir mindestens 20 Frames pro Sekunden brauchen, um den Eindruck von kontinuierlicher Bewegung zu vermitteln.  In der traditionellen Animation hat man, sagen wir fuer jede Sekunde,  einen Schluesselbild, ein sogenanntes Keyframe, gezeichnet.  Diese Keyframes enthalten dann die wesentlichen Aspekte der Bewegung.", "start": 44.0, "end": 76.0}, {"text": "  Die nebensechliche Aufgabe besteht darin, die restlichen Frames danach zu zeichnen.  Dies nennt sich Tweaning.  Wir wollen 20 Frames pro Sekunde.  Die Frage ist, koennen wir anstatt alle 20 Frames explizit angeben zu muessen,  nur die Keyframes benutzen und die restlichen automatisch generieren.  Die Loesung besteht in Interpolation.", "start": 76.0, "end": 114.0}, {"text": "  Also, gegeben diese wenigen Keyframes, finden wir interpolierende Funktionen zwischen jedem paar von Keyframes  und lassen die restlichen Frames durch die interpolierende Funktion ausgeben.  Das moechten wir mit kubischer Splinientipolation implementieren, und zwar mit unterschiedlichen Randbedingungen.", "start": 114.0, "end": 139.0}, {"text": "  Jetzt ein Beispiel fuer eine solche Implementierung, oder zumindest wie es nach einer Implementierung dann aussieht.  Okay, und zuerst mal mit natuerlichen Randbedingungen.  Da haben wir unsere Strichfigur mit ganz schoenen glaten Bewegungen.  Und auf der rechten Seite die interpolierenden Funktionen, je nach Farbe, entsprechend einen gewissen Koerperglied.", "start": 139.0, "end": 169.0}, {"text": "  Und jetzt noch ein Beispiel fuer die periodischen Randbedingungen.  Und wieder sanfte, smooth, glatte interpolierende Bewegungen.  Hallo, in diesem Video schauen wir uns an ein paar Beispielen von Interpolationsanwendungen.  Zuerst die Funktion plot von matplotlib.  Wir wollen eine Sinuskurve generieren.  Dafuer nehmen wir zufaellige x Werte zwischen 0 und 2p.", "start": 171.0, "end": 209.0}, {"text": "  Und uebergeben sie dann unsere Sinusfunktion.  Und lassen sie dann plotten.  Mit 10 zufaelligen Werten wird eine solche Kurve dargestellt.  Wir merken, dass zwischen jedem 2 Punkten es wird linear interpoliert.  Das heisst nur geraden.  Wir lassen es wieder laufen.  Und jetzt sieht unsere Kurve nicht mehr so sinusartig aus.  Und es liegt daran, dass wir nur 10 Punkte benutzen.", "start": 209.0, "end": 254.0}, {"text": "  Wenn wir das erhoehen, sagen wir 100, dann soll es nicht wundern, dass wir eine ganz schoene Sinuskurve erhalten.  Und obwohl wir nur linear interpolieren, haben wir so viele Punkte, dass die geraden winzig werden.  Und daher den Eindruck von Kontinuierlichkeit vermitteln.  Das naechste Beispiel handelt von digitaler Fotografie.  Wir wollen eine solche Szene durch ein Kamera aufnehmen.", "start": 254.0, "end": 290.0}, {"text": "  Und Digitalkameras benutzen zur Aufzeichnung von Bilddaten nur einen Bildsensor.  Dieser Sensor kann nur Lichtintensitaet aufnehmen.  Das heisst Helligkeitwerte.  Und liefert somit ohne weiteres ein schwarz-weisses Bild von dieser Form.  Nun, um Farbinformationen zu erhalten, werden Sensoren, Entschuldigung, werden Filter,  und wird ein Filter vor dem Kamerasensor aufgebracht.", "start": 290.0, "end": 325.0}, {"text": "  Dieser Filter hat eine Arrayform, wie hier gezeigt.  Und wenn Sie diese Muster ansprechen, heissen Sie Bayer Filter.  Die Idee hinter diesen Filtern ist, dass jede Zelle nur gewisse Wellenlaenge durchlaesst.  Das heisst, und entsprechend diese Farben hier.  Das heisst, ein solcher Bildpunkt auf dem Filter wird nur blaues Licht durchlassen.", "start": 325.0, "end": 360.0}, {"text": "  Und der Sensor wird danach nur ein Helligkeitswert ueber dieses blaue Licht enthalten.  Wenn wir zum Beispiel diese Zellen untersuchen,  wenn wir nur Informationen ueber rote Farbe auffinden,  endlich hier nur ueber blau und in den restlichen ueber gruen.  Das resultierende Bild, nachdem man ein Filter aufgebracht hat, sieht dann so aus.", "start": 361.0, "end": 394.0}, {"text": "  Und wir merken, dass jeder Pixel lediglich Informationen ueber eine Farbkomponente enthaelt.  Es ergibt ein mosaikartiges Bild.  Und das ist noch nicht realitaetstreu genug fuer uns.  Denn wir wollen, dass jeder Pixel Informationen ueber alle drei Farben enthaelt.  Und um dies zu loesen, dann benutzen wir unsere liebe Interpolation.", "start": 394.0, "end": 439.0}, {"text": " Ein naiver oder einfacher Ansatz waere, zum Beispiel,  wenn wir dieser Pixel, dieser blaue Pixel auch mit Informationen ueber rote und gruen befuellen wollen,  dann koennen wir die benachbarten Pixeln betrachten  und fuer rote den Mittelwert von diesen vier Pixel nehmen und das sein beziehen.", "start": 439.0, "end": 460.0}, {"text": " Und eigentlich fuer gruen koennen wir diese vier benachbarten gruenen Pixel nehmen  und den gruenen Wert daraus berechnen.  Es gibt raffiniertere Verfahren, die auf Interpolation beruhen,  mit kubischen Splines und Hermite-Interpolation,  um diese Farbwerte aus der Umgebung eines einzelnen Pixels zu bestimmen.", "start": 460.0, "end": 502.0}, {"text": " Dieses Verfahren nennt sich die Moseaking, also D-Mosaiken,  aus einem Mosaik rauskommen und fuehrt auf ein solches Ergebnis.  Das sind nun Bilder mit einer Aufloesung von 120 mal 80 Pixel  und sehen schon ganz gut aus dafuer.  So funktioniert der Algorithmus, der Hand in Hand geht mit Bayer-Filtern.  Interpolation liegt die Moseaking zugrunde.  Ein letztes Beispiel mit Spielen.", "start": 502.0, "end": 544.0}, {"text": "  Wir haben hier auf der linken Seite, lass mal oben gehen,  auf der linken Seite eine Animation mit 60 Frames pro Sekunde.  Und wir wollen auf einem anderen Rechner durch ein Netzwerk verbunden  diese gleiche Animation simulieren.  Ein naiver Ansatz waere das Netzwerk zu ueberlasten  und einfach jede diese 60 Frames an den anderen Rechner zu schicken.", "start": 544.0, "end": 576.0}, {"text": "  Nun, Netzwerke sind nicht besonders zuverlaessig.  Man kann nicht erwarten, dass alle 60 Pakete zum einen ankommen,  zum anderen rechtzeitig und in der richtigen Reihenfolge,  zumindest nicht fuer real-time, echt zeigt Anwendungen.  Eine Loesung koennte darin bestehen, weniger Frames pro Sekunde zu schicken  und dabei nur Snapshots, zehn solche Snapshots zu benutzen,  anstatt alle 60 Frames.", "start": 576.0, "end": 621.0}, {"text": "  Und dabei wird die Bandbreite verringert  und hier koennen wir erwarten, dass diese zehn Snapshots pro Sekunde gute ankommen.  Allerdings sieht unsere Simulation immer noch nicht gut aus,  denn die Bewegung ist nicht glatt  und wir bekommen nicht den Eindruck von Kontinuierlichkeit.  Und die Loesung ist wieder, Interpolation natuerlich.", "start": 621.0, "end": 655.0}, {"text": "  Zunaechst koennen wir lineare interpolieren zwischen jeden zwei Snapshots  und erhalten dabei eine solche Simulation, die schon viel glatter aussieht,  ohne die Bandbreite auszulassen  und noch besser vielleicht mit Hermite Interpolation  und dabei erhalten wir diese Simulation.  Das sind drei Beispiele zu Interpolationsanwendungen  und es gibt viele mehr.", "start": 655.0, "end": 685.0}]}]