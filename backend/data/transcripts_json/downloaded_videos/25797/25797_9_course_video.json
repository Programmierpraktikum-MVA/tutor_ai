[{"lecture": "25797_9_course_video", "Timestamps": [{"text": "  In diesem Video soll es darum gehen, wie man die lineare Regression mit Polinomen in Python implementieren kann.  Das ist zugegebenermassen gar nicht so schwer und auch nicht wirklich spannend.  Das Spannste daran ist, wie wir uns diese Matrix aufstellen koennen.  Damit ist die Matrix gemeint, welche die X-Werte in allen Potenzen enthaelt.  Dazu haben wir eine Funktion, die heisst phi.", "start": 0.0, "end": 28.0}, {"text": "  Die bekommt einen ersten Parameter x und x soll der Vektor sein,  der alle X-Werte enthaelt und der Polinomengrad.  Wir allocieren uns eine Matrix M und diese enthaelt so viele Zeilen wie X-Werte enthaelt.  Also fuer jeden X-Wert eine Zeile und dann brauchen wir D plus 1 viele Speiten.  Denn in jeder Speite sollen ja die X-Werte in einer Potent stehen.", "start": 28.0, "end": 59.0}, {"text": "  Und da wir alle Potenzen von 0 bis einschliesslich D brauchen, brauchen wir dann D plus 1 viele Speiten.  Und jetzt koennen wir das Ganze immer spaltenweise berechnen,  wetterieren dabei ueber alle Speiten und dann rechnen wir X hoch i.  Diese zwei Sternen ist der Potenzoperator.  Dabei wird natuerlich jedes Element aus dem X-Aray elementweise hoch i genommen.", "start": 60.0, "end": 89.0}, {"text": "  Und dann muessen wir nichts anderes tun, als die Speite durch das Ergebnis dieser Operation zu ersetzen.  Auf die Speite greifen wir zu, indem wir diesen Doppelpunkt benutzen,  dann Komma und dann i und dadurch ersetzen wir die itisch-Speite durch unser potenzieites Array.  Und die Matrix, die wir uns dadurch aufbauen, sieht dann genauso aus wie wir sie kennen.", "start": 90.0, "end": 110.0}, {"text": "  Das Ganze geht auch zugegebenermassen sehr viel kuerzer.  Dazu muessen wir uns als allererstes ein Array erstellen,  welches alle Werte von 0 bis einschliesslich Deck enthaelt.  Deshalb muessen wir hier, wenn wir Arrange benutzen, Deck plus 1 als Parameter angeben.  Und dann muessen wir die Dimension unserer beiden Arrays, also X und D, erweitern, und zwar mit diesem Nann.", "start": 111.0, "end": 139.0}, {"text": "  Und dann koennen wir dann mithilfe von NumPy's Broadcasting diesen Potenzoperator dazu verwenden,  um uns dann in diese ein Zeile die Matrix zu erstellen.  Als unsere X-Werte nutzen wir dann 100 Punkte zwischen 0 und 3, einschliesslich beider Werte,  und die sollen gleich verteilt sein, deshalb nutzen wir dann die Linespace-Funktionen.", "start": 140.0, "end": 162.0}, {"text": "  Und unsere zu approximierende Funktion soll einfach der Cosinus ein.  Hier sehen wir den Cosinus zwischen 0 und 3, nicht gerade sehr spannend.  Und den moechten wir jetzt mit zwei Polinomen, einmal mit einem Polinom vom Grad 1, also einer geraden,  und einer kubischen Funktion, also einem Polinom vom Grad 3 approximieren.  Das machen wir hier, wir bauen uns zuerst unsere Matrizen auf.", "start": 163.0, "end": 186.0}, {"text": "  Wir sagen X1 gleich V von X,1.  Das transformiert dann jeden Punkt in die Nullte-Potenz und die erste Potenz,  und gibt uns dann die Matrix zurueck, und dann machen wir das gleiche nochmal mit Grad 3.  Das gibt uns dann eine etwas groessere Matrix aus.", "start": 187.0, "end": 209.0}, {"text": " Und jetzt wollen wir uns hier durch diesen kleinen Print mal die ersten fuenf Zeilen unserer Matrix fuer die gerade anschauen,  um zu ueberpruefen, ob das eventuell falsch ist.  Und hier links sehen wir 1, das ist normal, denn irgendwas hoch 0 ist 1, in dem Fall ist auch 0 hoch 0 1, deshalb nicht wundern.  Und hier haben wir die gleichverhalten X Werte.  Scheint richtig zu sein.", "start": 210.0, "end": 227.0}, {"text": "  Und was muessen wir tun?  Jetzt muessen wir natuerlich den Vektor mit den Gewichten bestimmen, das heisst, wir brauchen die Koepizenten vor den Polinomen-Potenzen,  also wie viel mal X plus wie viel mal X Quadrat usw.  Und das kriegen wir raus, indem wir die normalen Gleichung loesen.  Ich nutze hier keine Cholesky-Zerlegung, sondern nutze einfach direkt die Solve-Methode.", "start": 228.0, "end": 248.0}, {"text": "  Hier haben wir die normalen Gleichung.  Ich muttibeziehe die Transponierte von unserer Matrix an die Matrix ran und auf der rechten Seite die Transponierte der Matrix an den Vektor.  Und das sind dann hier unsere Koepizenten, die sind von kleinem Grad nach grossem Grad geordnet.  Das heisst, unsere Grade hat dann die Form minus 0,79X plus 1,23.", "start": 249.0, "end": 284.0}, {"text": "  Und unsere kubische Funktion ist dann 0,15X hoch 3 minus 0,69X Quadrat plus 0,09X und plus 0,99.  Jetzt haben wir natuerlich Solve benutzt, um die normalen Gleichung zu loesen,  aber die normalen Gleichung scheint so wichtig zu sein, dass es extra eine Methode dafuer gibt in NumPy  und die heisst dann Lease Squares, also LSTSQ.  Und diese koennt ihr auch nutzen, um die normalen Gleichung zu loesen.", "start": 287.0, "end": 311.0}, {"text": "  Diese gibt euch neben dem Loesungsvektor auch noch die Residuen aus.  Und jetzt moechten wir natuerlich, wir haben ja den Vektor mit den Gewichten, also den Loesungsvektor.  Und jetzt moechten wir die Y-Werte bestimmen.", "start": 313.0, "end": 334.0}, {"text": " Und was wir da tun muessen, ist einmal die transformierte Matrix, also die Matrix, die die X-Werte in allen Potenzen enthaelt,  einmal an unseren Gewichte-Vektor anzumultiplizieren und dadurch erhalten wir die Y-Werte.  Und dazu habe ich auch noch den quadratischen Fehler berechnet.  Das geht so.  Einmal die Differenz bilden, dann jeden Wert quadrieren und davon die Summe.", "start": 335.0, "end": 346.0}, {"text": "  Das ist genau die Summe der Quadrate.  Und jetzt wollen wir mal anschauen, wie gut die Apoximation ist.  Diese Punkte, diese roten Punkte, das ist natuerlich unsere Posinusfunktion.  Und die gerade ist dann die Ausgleichsgerade.  Und hier betraegt der quadratische Fehler ungefaehr 0,63.  Schauen wir uns das gleiche nochmal fuer die kubische Funktion an.", "start": 347.0, "end": 369.0}, {"text": "  Man sieht hier, die Funktion ist schon so ziemlich drauf.  Und wenn man sich den quadratischen Fehler anschaut, der ist dann 0,00065.  Und der ist hier schon sehr niedrig.  Das heisst, mit Grad 3 koennen wir den Cosinus zwischen 0 und 3 sehr, sehr gut approximieren.", "start": 370.0, "end": 394.0}, {"text": " Und das Ganze, was ich hier bisher gemacht habe mit den Polinomen,  koennt ihr auch mithilfe einer Numpy-Funktion machen, und zwar der Polifit-Funktion.  Da koennt ihr die x-Werte, die y-Werte und den Grad als Parameter eingeben.  Und davon koennt ihr euch dann ein Poli1-Stay-Objekt erstellen.  Und mit Hilfe dieses Poli1-Stay-Objektes koennt ihr dann die x-Werte eingeben.", "start": 395.0, "end": 416.0}, {"text": "  Also ihr koennt dann f von einem Numpy-Area machen, wo ganz viele x-Werte sind.  Und ihr bekommt fuer jeden dieser Werte dann den zugehoerigen y-Wert.  Das Ganze wuerde ich euch aber nur zum Rumspielen empfehlen,  falls ihr wirklich irgendwas Taugliches entwickeln wollt, also in Richtung Machine Learning,  dann nutzt lieber eine richtige Library, wie zum Beispiel Scikit-Learn.", "start": 417.0, "end": 440.0}, {"text": "  In diesem Video gibt es fuer euch zwei Aufgaben zu loesen.  Die erste handelt von linearer Regression.  Wir haben drei Messpunkte gegeben, 1, 1, 2, 2 und 3, 2.  Der Linke der Werte ist dann der x-Wert und der rechte der y-Wert.  Und wir sollen hier zwei Polinome finden, f und g, welche die Messwerte approximieren.  f soll dabei eine gerade sein und g eine quadratische Funktion.", "start": 441.0, "end": 470.0}, {"text": "  Unsere beiden Funktionen muessen also so aussehen, dass f und x gleich a mal x plus b ist.  Und g von x soll a mal x\u00b2 plus bx plus c sein.  Und eure Aufgaben lauten, ihr sollt fuer beide Funktionen ein zu loesenes LGS aufstellen, es gibt mehrere Moeglichkeiten.  Dieses LGS hat vielleicht keine Loesung.  Und dann sollt ihr mit Hilfe einer geeigneten Methode die Funktion f und g konkret bestimmen.", "start": 471.0, "end": 498.0}, {"text": "  Also ihr solltet die Parameter a, b und c eventuell bestimmen.  Haltet das Video am besten an, es gibt sofort die Loesung.  Okay.  Als allererstes muessen wir uns diese, ich nenne sie mal hier Systemmatrix aufbauen.  Fuer die gerade brauchen wir dann links alle unsere x-Werte hoch 0, das ist dann einfach eine Spalte von 1.", "start": 499.0, "end": 528.0}, {"text": "  Und dann rechts einfach unsere x-Werte hoch 1, das sind genau unsere x-Werte.  Und dann sieht die Systemmatrix fuer quadratische Funktionen wie folgt aus.  Wir nehmen die Systemmatrix fuer eine gerade und fuegen noch die x\u00b2-Termine hinzu.  Das solltet ihr wahrscheinlich aus den Videos kennen.  Konkret sieht dann unser LGS fuer die gerade so aus.", "start": 529.0, "end": 555.0}, {"text": "  Wir haben eine Matrix, die heisst normalweise x, die enthaelt in der linken Spalte nur 1  und in der rechten Spalte nur die 3x-Werte, 1, 2 und 3.  Hier sind unsere beiden zu bestimmten Parameter.  Und hier ist es halt wichtig, unsere Funktion soll a mal x plus b sein.  Das heisst b muss oben stehen, wenn die 1 hier links stehen  und a muss unten stehen, wenn die x-Werte hier rechts stehen.", "start": 555.0, "end": 583.0}, {"text": "  Das ist ein moeglicher Fall, eine moegliche Matrix.  Ihr koenntet die beiden Spalten auch vertauschen.  Dann muesstet ihr aber auch den Loesungsvektor vertauschen.  Der muesste a oben stehen und b unten.  Auf der rechten Seite haben wir dann einfach die y-Werte.  So, dieses Ergaets hat keine Loesung.  Deshalb nutzen wir die normalen Gleichung.", "start": 584.0, "end": 607.0}, {"text": "  Das heisst, wir multiplizieren unsere Matrix transponiert auf beiden Seiten von links.  Wir halten dadurch dieses neue lineare Gleichungssystem.  Und dieses hat dann eine Loesung.  Die habe ich auch schon mal im Vorhinein berechnet.  Das ist dann 2,3 und 1,3.  Das heisst, die Funktion sieht dann so aus.  f und x ist gleich 1,5x plus 2,3.  Denn wir haben ja gesagt, b ist oben.", "start": 608.0, "end": 640.0}, {"text": "  Das heisst, 2,3, b ist hier und 1,5 ist hier.  1,5 ist dann hier.  Schauen wir uns das Ganze noch mal grafisch an.  Hier sind unsere drei Messpunkte.  Und hier ist unsere Gerade, die die Punkte approximiert.  Jetzt solltet ihr das Ganze fuer die quadratische Funktion machen.  Das LGS sieht dann wie hier aus.  Wir haben eigentlich genau die gleiche Matrix.", "start": 643.0, "end": 670.0}, {"text": "  Die ersten beiden Spalten, wie fuer die Gerade.  Nur kommt hier noch die x-Werte zum Quadrat hinzu.  2\u00b2 ist 4, 3\u00b2 ist 9 und 1\u00b2 ist 1.  Hinzu kommt ein dritter Parameter,  und zwar c.  c soll oben stehen, weil wir die Einsen hier links haben.  Deshalb steht c hier oben.  2,5x\u00b2 plus bx plus c ist.  Das b steht in der Mitte,  weil unsere Spalte mit den x-Werten in der Mitte steht.", "start": 671.0, "end": 704.0}, {"text": "  Unser a steht unten,  weil die Spalte mit den Quadraten rechts steht.  Reihenfolge ist ganz wichtig zu beachten.  Und rechts wieder einfach nur die y-Werte.  Dieses LGS hat aber eine Loesung.  Das ist minus 1 fuer c, 2,5 fuer b und minus 0,5 fuer a.  Aber was passiert, wenn wir jetzt die normalen Gleichung benutzen?  Das machen wir mal.", "start": 705.0, "end": 732.0}, {"text": "  Wir multiplizieren die Transponierte unserer Matrix auf beiden Seiten von links,  kriegen ein neues LGS,  und dann ist unsere Loesung genau die gleiche wieder vor.  Das koennen wir auch so festhalten,  dass wenn unser LGS eine Loesung hat,  und wir benutzen dann die normalen Gleichung drauf,  dann veraendert sich die Loesung nicht.  Jetzt schauen wir uns als erstes mal die genaue Funktion an.", "start": 733.0, "end": 760.0}, {"text": "  Das ist dann minus 0,5x\u00b2 plus 2,5x minus 1.  Und wenn wir uns dann den Funktionsgrafen dazu betrachten,  dann sehen wir, dass es eine Interpolation ist.  Das heisst, wir treffen alle Punkte genau.  Das kommt dadurch zustande, dass wir genau drei Messpunkte haben,  und unser Polinom hat gerade zwei, das heisst, wir haben drei Parameter.", "start": 763.0, "end": 790.0}, {"text": " Und unser LGS hat damit eine 3 x 3 Matrix,  also wir haben drei Gleichungen und drei zu bestimmte Parameter.  Und da unser Matrix nicht singulaer ist, haben wir hier genau eine Loesung,  und somit treffen wir alle Punkte genau.  Als naechstes sollte die Cholesky-Zerlegung fuer zwei 4 x 4 Matrizen berechnen.", "start": 791.0, "end": 808.0}, {"text": " Im Video wurde das fuer eine 3 x 3 Matrix gezeigt,  aber meiner Meinung nach sieht man erst richtig, was da passiert,  wenn man sich 4 x 4 Matrizen anschaut.  Ihr habt hier zwei Matrizen, A und B.  Ihr muesst nicht ueberpruefen, ob die positiv definiert sind.  Ihr koenntet das gerne tun.  Die sind positiv definiert,  und jetzt sollte die Cholesky-Zerlegung dafuer berechnen.", "start": 809.0, "end": 828.0}, {"text": "  Wir stellen fest, dass A eine Diagonalmatrix ist.  Hier ist es besonders leicht,  und bei B ist es ein bisschen komplizierter.  Haltet am besten jetzt das Video an, versucht euer Glueck.  Okay, ich hoffe, ihr habt es gemacht.  Fangen wir an.  Fuer A ist das besonders leicht,  denn das einzige, was wir tun muessen,  ist die Wurzel aller Diagonalelemente zu nehmen.", "start": 829.0, "end": 855.0}, {"text": " Hier haben wir die Wurzeln,  und die schreiben wir dann einfach hier auf die Diagonale drauf.  Nichts kompliziert ist.  2 ist ja Wurzel 4, 3 ist Wurzel 9 und so weiter.  Jetzt wollen wir das Ganze fuer die  nicht Diagonalmatrix durchgehen.  Zuerst berechnen wir das Element um links,  das ist wieder besonders leicht,  einfach die Wurzel aus dem Element  der Matrix an der gleichen Position.", "start": 856.0, "end": 881.0}, {"text": "  Das Element darunter, und eigentlich alle Elemente  unter dem Element um links sind leicht.  Wir nehmen 1 geteilt durch das Diagonalelement,  also durch die 2,  und rechnen das mal dem Element in der Originalmatrix,  und das ist hier 1.  Jetzt kommt das naechste Diagonalelement.", "start": 882.0, "end": 907.0}, {"text": " Hier ist es genauso leicht,  wir nehmen wieder das Element an der gleichen Position,  zu berechnen alle links von der Position  berechneten Elemente, das heisst diese 1,  und zwar alle zum Quadrat,  1 Quadrat ist in dem Fall aber wieder 1,  ziehen davon die Wurzel,  und das naechste Element ist dann 3.", "start": 908.0, "end": 929.0}, {"text": " Jetzt haben wir wieder ein Element ganz links,  das ist wieder leicht, 1 geteilt durch das Diagonalelement,  also 1 geteilt durch 2,  und das ist wieder mal die Zahl in der Originalmatrix,  das ist wieder eine 2,  das heisst unser Ergebnis ist wieder eine 1.", "start": 930.0, "end": 950.0}, {"text": " Jetzt wird das wieder ein bisschen spannender,  jetzt sind wir nicht mehr ganz links,  und wir haben sogar ein neues Diagonalelement,  also wir nehmen 1 geteilt durch das Diagonalelement,  das ist in dem Fall die 3,  also das in der gleichen Spalte.  Jetzt nehmen wir das ganze Mal das Element  in der Originalmatrix, die 10,  und jetzt weil wir in der 3. Zeile  und in der 2.", "start": 951.0, "end": 968.0}, {"text": "Spalte sind,  muessen wir dann alle Elemente,  die sich links von unserem aktuell zu berechnenden Element befinden,  also links von der 3,  in der 3. und in der 2.", "start": 969.0, "end": 989.0}, {"text": "Zeile miteinander multiplizieren,  und zwar immer genau die, die uebereinander stehen,  das sind in dem Fall diese beiden 1en hier,  und die muessen wir dann abziehen von der 10,  und dann natuerlich mit 1 Drittel multiplizieren,  und dann haben wir unsere 3.", "start": 992.0, "end": 1002.0}, {"text": " Als naechstes kommt wieder ein Diagonalelement,  das berechnen wir wie immer,  wir nehmen das Element aus der Originalmatrix, die 11,  ziehen alles was links davon bereits berechnet wurde zum Quadrat ab,  und ziehen davon die Wurzel,  und dann haben wir unser neues Diagonalelement.  Jetzt sind wir in der 4.", "start": 1003.0, "end": 1018.0}, {"text": "Zeile,  wir wollen das Element wieder ganz links berechnen,  das ist dann wieder 1 geteilt durch das Diagonalelement,  mal das Element an der gleichen Position in der Originalmatrix,  und hier waere natuerlich wieder was abzuziehen,  aber da wir ganz links sind,  muessen wir hier nichts abziehen,  und deshalb ist die Loesung 4.", "start": 1018.0, "end": 1041.0}, {"text": " Okay, jetzt wird es wieder ein bisschen spannender,  wir haben wieder unser Diagonalelement,  ist die 3, deshalb 1 Drittel,  wieder das Element an der gleichen Position in der Originalmatrix,  das ist die 7,  und jetzt, da wir in Zeile 4 und Spalte 2 sind,  muessen wir wieder die Elemente jeweils links davon aus der 2. Zeile  und der 4.", "start": 1042.0, "end": 1065.0}, {"text": "Zeile miteinander multiplizieren,  und das waeren hier in dem Fall die 1 und die 4,  die multiplizieren wir hier,  und so berechieren sie von der 7,  und rechnen das Ganze mal ein Drittel,  und das ist dann 1.  Und wahrscheinlich die spannendste Rechnung,  und da sehen wir auch, was wir eigentlich zu tun haben.", "start": 1066.0, "end": 1086.0}, {"text": " Also wir befinden uns jetzt an der Position 4, 3,  wir nehmen wieder das Diagonalelement,  das ist diese 1 hier,  wir dividieren 1 durch das Diagonalelement, wie immer,  jetzt nehmen wir wieder das Element aus der Originalmatrix,  das an der gleichen Position steht,  minus, und da wir jetzt in der 4. Zeile  sind, betrachten wir die 3. Zeile und die 3.", "start": 1087.0, "end": 1110.0}, {"text": "Spalte,  alle Elemente links von dieser 2 hier, die wir berechnen wollen,  davon multiplizieren wir alle Elemente, die uebereinander sind,  also die 4 mit der 1 und die 3 mit der 1,  ziehen sie von unserem Originalelement, also den 9 ab,  und rechnen das mal 1, geteilt durch das Diagonalelement,  und da kommt 2 raus.", "start": 1111.0, "end": 1138.0}, {"text": " Und was wir hier eigentlich tun, ist nichts anderes,  als das Skalaprodukt bilden,  also vom Zeilenvektor, der sich links von dem Element  in der Zeile, wie in der Spalte des Elementes befindet,  und mit dem aus der gleichen Zeile,  und zwar auch wiederum links.", "start": 1139.0, "end": 1161.0}, {"text": " Und zum Schluss kommt wieder das Diagonalelement,  wir nehmen wieder die Originalezahl,  minus alles, was links davon steht, zum Quadrat,  ziehen davon die Wurzel, und die Loesung ist 1.", "start": 1162.0, "end": 1165.0}]}]