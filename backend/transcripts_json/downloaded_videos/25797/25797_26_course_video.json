[{"lecture": "25797_26_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir weiter machen mit einer Wiederholung der Linien an Eiegebre,  und das ganze direkt mit einem Ampereienverbindungen bringen.  Der relativ viele Konzepte, die wir uns im Semester anschauen werden, basieren auf Liniere  Eiegebre und auch ein bisschen auf der Analysis, damit wir das verstehen koennen, weil wir  halt einmal die Grunddehnen Konzepte wiederholen.", "start": 0.0, "end": 26.400000000000002}, {"text": "  Und wichtig ist vor allem fuer das wissenschaftliche Rechnen, das sind geometrisches Verstaendnisaufbau.  Wir wollen uns unter der Mathematik etwas vorstellen koennen und nicht nur wissen, wie  die Konzepte ineinandergreifen, sondern wir wollen wirklich verstehen, was dann da geometrisch passiert.", "start": 26.799999999999997, "end": 45.599999999999994}, {"text": " Zusaetzlich zu den Tutorien gibt es dazu den Capital Script, wo auch nochmal die wichtigsten  Punkte aufgeschrieben sind.  Und wir haben noch weitere Materialien auf die Isis-Late verlinkt.  Und da empfiehmen wir uns euch zum Beispiel die Videos von FreeBlue1Round.", "start": 45.599999999999994, "end": 64.12}, {"text": " Da gibt es eine Fahre WSens of Linear Eiegebre und die koennt ihr euch nochmal anschauen,  da werden die wichtigsten Sachen nochmal sehr anschauliche erklaert.  Der Nampal wird uns helfen, die mathematischen Konzepte im Palten umzusetzen.  Wir wollen halt Nampal direkt mit den Lina Grundwissen verknuepfen.  So an der Stelle moechte ich euch die Frage stellen, was im Vector ist.", "start": 67.12, "end": 83.08}, {"text": "  Ich wuerde euch empfehlen das Video kurz anzuhalten und mal darueber nachzudenken.  Wenn ihr eine Antwort gefunden habt, koennt ihr das Video weiter abschauen.  Eine moegliche Antwort ist, dass ein Vector eine Anenandereiung von mehreren Zahlen mit  einer Klammer drum ist.  Das ist relativ ungarnspachlich ausgedrueckt und ist grundsaetzlich auch erstmal nicht  falsch.", "start": 83.92, "end": 104.16}, {"text": "  Wir kommen da gleich nochmal darauf zurueck.  Die spannende Frage, die wir uns jetzt aber um wie stellen wollen, ist, was das ganze  Geometrisch bedeutet.  Eine weitere Antwort waere jetzt hier, ein Vector repraesentiert und wie eine bestimmte  Linie im Raum.  Das ist erstmal falsch.", "start": 104.16, "end": 129.68}, {"text": " Ein Vector ist eben keine Gerade, die unnettlich fortgesetzt ist weiter im Raum, sondern ein  Vector ist ein geometrisches Objekt mit bestimmten Eigenschaften.  Zwar gibt ein Vector eine bestimmte Richtung an bzw. zeigt in eine bestimmte Richtung  Ausgehend von koordinaten Ursprungen.  Ein Vector hat eine bestimmte Laenge.", "start": 129.68, "end": 145.6}, {"text": "  Heisst, es ist keine unendlich fortgesetzt gerade in dieser bestimmten Richtung, sondern  ein Vector hat eine bestimmte Laenge und zeigt eben in eine bestimmte Richtung.  Wir schreiben fuer so ein Vector, dass der Element von einem Vectorraum mit N eintraegen  ist, in dem Fall der Vectorraum ueber den gleichen Zahlen.", "start": 145.6, "end": 166.48000000000002}, {"text": "  Also gut koennen wir auch die komplexen Zahlen verwenden und zum Vector koennen wir dann  auch zwei Arten betrachten.  Moecht man mit der zweiten Variante hier anfangen, die algebraische Betrachtung.", "start": 166.48000000000002, "end": 186.52}, {"text": " Die algebraische Betrachtung ist umgegensprachlich gesagt eben einfach diese Anordnung von Zahlen,  das geordnete Zahntupel von zum Beispiel reellen oder komplexen Zahlen mit eben dieser Klammer  drum, was das dann halt zu einem Tupel macht.  Und diese Praesentationen nennen wir eben Koordinatenrepraesentationen und diese einen  zu einem Wert und Sprechenheit einer Koordinaten.", "start": 186.84, "end": 202.0}, {"text": "  Diese Darstellung, dieses algebraische Verstaendnis, quasi die Repraesentationen, mit der wir aus  dem Computer arbeiten.  Heisst, NumPyArrays, mit die wir gleich sehen werden, sind nichts anderes als eben, weil  sie dann einfach algebraisch simpel aufgestimmender Vector.  Das Verstaendnis dahinter, was ja sehr viel wichtiger fuer uns ist, ist die geometrische  Veranschaulichung.", "start": 202.0, "end": 223.32000000000002}, {"text": "  Da koennen wir so im Vector aufpassen, dass eine Linearkombination aus dem Basisvektor  mit den Gewichten, die den entsprechenden Eintraegen des Vectors entsprechen.  Heisst, V setzt sich zusammen aus den ersten Eintrag V1, bei den ersten Einheitsvektor.  Heisst, V1 bei den ersten Einheitsvektor heisst, im ersten Eintrag steht V1, der  Rest Nullen.", "start": 223.32000000000002, "end": 246.64000000000001}, {"text": "  Plus V2 bei den zweiten Einheitsvektor, den zweiten Basisvektor, das an der zweiten  Stelle steht V2, der Rest ist gefuehlt mit Nullen und so weiter.  Wenn wir das zusammen summieren, dann ist relativ klar, dass sich daraus der Vector  vergibt.", "start": 246.64000000000001, "end": 268.32}, {"text": " Und verstehen koennen wir das Ganze, als wir gehen um V1 entlang der ersten Koordinaten  Achso, also des ersten Basisvektors, gehen um V2 entlang des zweiten Basisvektors, bzw.  der zweiten Koordinaten Achso und so weiter.  Dazu kommt wahrscheinlich gleich nochmal das Gizze.", "start": 268.32, "end": 283.48}, {"text": " Und da ist relativ wichtig, zwischen mir einen Anschauen zu unterscheiden, also zwischen  der geometrischen und der algebraischen Auffassung.", "start": 283.48, "end": 302.15999999999997}, {"text": " Wir denken quasi in dieser geometrischen Darstellung, also wir muessen bei dem Vector  eben dieses immer die geometrische Objekt in eine bestimmte Richtung mit einer bestimmten  Laenge zeigt, uns vorstellen, was eben quasi einzelne Eintraege hat, die der Bewegung  entlang einer bestimmten Koordinaten Achso entsprechen.", "start": 302.15999999999997, "end": 309.44}, {"text": "  Wenn wir aber implementieren und arbeiten, normalisch, dann arbeiten wir eben mit den  Koordinaten.  Hier eben die versprochenen Skizze.  Wir haben die beiden Koordinaten Achsen, da gestellt hier durch die Einheitsbasisvektoren  E1 und E2.", "start": 309.44, "end": 333.0}, {"text": " Und dem Vector 2,1, den ich hier im Blau gezeichnet habe, koennen wir eben schreiben, als 2 mal  1 0, nur 2 mal entlang dieser ersten Koordinaten Achse plus 1 mal entlang der zweiten Koordinaten  Achse, eben diese beiden Bewegungen zusammenfassen, also 2 nach rechts, 1 nach oben oder 2 entlang  der ersten Achse, 1 entlang der zweiten Achse.  Die Bewegung zusammen entsteht eben dieser Vector 2,1.", "start": 333.0, "end": 352.08}, {"text": "  Aber jetzt wie versprochen, wenn wir das direkt mit NumPy verknuepfen, dafuer muessen wir erst  mal NumPy importieren.  Also wir sagen import numpy smp.  Dafuer muesste numpy erst mal installieren mit pip install numpy und genau import numpy  importieren wir quasi diese Bibliothek.  Mit es geben wir einen Spitznamen, also quasi einen Namen, mit dem wir dann kurz arbeiten  koennen.", "start": 352.08, "end": 373.71999999999997}, {"text": "  Und da schreiben wir mp hin, das relativ ueblich.  Dann koennen wir mp.ary schreiben, anstatt von numpy.ary.  Schreiben uns, spannen uns also ein bisschen schreibbar.  Genau.  So, dann haben wir hier die ersten simplen Vektoren und zwar koennen wir ganz einfach sagen,  ah ist gleich mp.ary, das ist eine Funktion.  Die Funktion bekommt und ein etrierebares Objekt, zum Beispiel eben eine Liste.", "start": 373.71999999999997, "end": 398.44}, {"text": "  Hier mit den Eintraegen 123.  Und die Funktion mp.ary baut uns jetzt halt ein numpy.ary Objekt daraus.  Den wir dann hier unten, das sieht jetzt erstmal nicht anders aus als Liste, aber eben diese  numpy Repraesentation nochmal andere Rechenoperationen und so weiter mitbringt als eine normale  Liste.", "start": 398.44, "end": 425.68}, {"text": " Und ja, das relativ, da denke ich, hier kann man dann halt auch hintereinander verschachtete  Liste eingeben und so weiter, dann wuerde man mal trotzdem bekommen.  Zusaetzlich stellt numpy die Verschindung von Zonen bereit, wie wir halt andere Vektoren  konstruieren koennen.", "start": 425.68, "end": 440.52}, {"text": " Also hier haben wir den Vektor ja explizit konstruiert, das heisst wir haben explizit  die Werte reingeschrieben, die weitere Operationen, zum Beispiel siebus like, heisst a hat ja  ein bestimmtes Format, a ist jetzt ein Vektor aus den natuerlichen Zahlen hoch drei.  Also wir haben drei Eintraege natuerlicher Zahlen, das haben wir mp.", "start": 440.52, "end": 460.16}, {"text": "ivus like, a und  dann kreben wir ein Vektor mit eben nullen, zeroes mit genau drei Eintraegen aus.  Also gibt es die Funktion numpy random, also numpy random ist erstmal ein Modul von numpy  und da drin steckt die Funktion random und die gibt uns ein Vektor mit drei Eintraegen  zurueck und da stehen dann eben zufaellige Werte drin.", "start": 460.16, "end": 481.56}, {"text": "  Ja, eine weitere Variante, die wir verwenden koennen, um zum Beispiel ein Vektor mit nur  einzelnen zu schreiben, ist mp.runs.  Hier gibt es das verschiedene Varianten, wenn man das aufrufen kann grundsaetzlich, wenn  ich kann ich mit numpy runs auch mal Matritzen oder Tensoren komplett aus einzelnen erstellen  und ich muss dafuer den Shape angeben.", "start": 481.56, "end": 503.4}, {"text": "  Also welches Format dieses Array, der Vektor, die Matrix oder der Tensor haben soll, das  heisst hier vier mal vier, einfach vier, das einfache Tupe mit Eintrag und vier, das  spricht quasi ein Vektor mit vier Eintraegen, ich bin jetzt hier drei reinschreiben oder  zwei, dann wuerde ich eine vier mal zwei Matrix bekommen, ich koennte hier vier mal zwei mal", "start": 503.52, "end": 520.92}, {"text": " drei reinschreiben, dann kriege ich eben eine vier mal zwei mal drei, einen vier mal zwei  mal drei Tensor.  Genau, genauso gut, wenn ich nur einen Vektor haben will, dann kann ich auch einfach direkt  anstatt von dem Tupe mit dem Shape eben einfach direkt die vier hier reinschreiben,  dann kriege ich auch einfach direkt den Vektor mit vier Eintraegen komplett alles einschreiben.", "start": 520.92, "end": 545.28}, {"text": "  Achtung, man koennte jetzt meinen, dass eine vier mal eins Matrix ja quasi genau ein Vektor  mit vier Eintraegen ist, mathematisch kann man das so interpretieren, wenn wir aber dann  halt numerisch Rechenoperationen implementieren wollen, dann macht das fuer Namper sehr wohl  einen Unterschied, ob wir einfach einen Vektor mit vier Eintraegen haben oder quasi eine  vier mal eins Matrix.", "start": 545.28, "end": 566.6800000000001}, {"text": "  Hier sehen wir das, hier koennen wir halt einen Spalten Vektor quasi mit raus, vier mal eins,  wuerden wir als mal vier schreiben, haetten wir halt einen Zeilen Vektor, ist aber dann  immer noch ein Unterschied zu eben den einfachen Vektor mit einfachen, eckigen Klammern.  Also die Operationen von Namper werden dann halt auf dem Objekt D nicht die gleichen  WC1 oder C2.", "start": 566.6800000000001, "end": 591.56}, {"text": "  Bei einem Hinweis hier, bei den Listen haben wir vorhin gesehen, dass man in eine Liste  unterschiedliche Datentypen schreiben kann, also Integers, Floats, Swings und so weiter.  Das funktioniert bei NumPyArrays nicht mehr, NumPyArrays sind an einen Typ gebunden, also  genauso wie Arrays in der Programmiersprache C.", "start": 591.56, "end": 610.96}, {"text": "  Sobald ich jetzt hier, neben den beiden Integers, einen Float reinschreibe, ist der Datentyp  Float.  Hier habe ich nur Integer drin stehen, das heisst der Datentyp ist Integer.  Und genauso kann ich aber den Datentyp aber auch explizit angeben, das heisst hier uebergebe  ich das Keyword Argument oder den Keyword Parameter Komplex und dadurch habe ich dann  hier eine komplexe Zahl stehen.", "start": 610.96, "end": 634.2800000000001}, {"text": "  Ganz interessant ist, Python hat nativ den Datentyp Komplex.  Das heisst hier kann ich einfach dieses Schluesselwort Komplex reinschreiben, genauso gut koennte  man halt auch MP Komplex schreiben, aber dadurch, dass Python den Datentyp schon nativ mitbringt,  geht das halt auch so.  Genau.  So, und dieser Datentyp geht halt fuer alle Elemente in diesem Erray.", "start": 634.2800000000001, "end": 656.36}, {"text": "  Dann wollen wir weitermachen mit Operationen auf Vektoren.  Erst mal ganz einfache Operationen, die man mit einem Vektor machen kann, man kann einen  Vektor addieren.  Als wenn ich zwei Vektoren mit derselben Anzahl an Eintraegen habe, dann kann ich den  aufeinander addieren.  Ich kann den Vektor Elementweise multiplizieren.", "start": 656.36, "end": 676.84}, {"text": "  Ich kann Elementweise dividieren, dann zwei Vektoren subtrahieren voneinander.  Ich kann die Elemente verdoppeln.  Ist relativ cool.  Wenn ich einfach schreibe A mal 2, dann wird dieses Mal 2 auf die Elemente 1 angewendet  von den Amperei.  Und genauso kann ich einen Vektor negieren.  Und dematisch ist das Ganze nicht weiter interessant.", "start": 676.84, "end": 698.64}, {"text": "  Die interessanter sind dann andere Operationen, die gleich kommen.  Erst mal noch mal ein anderer Hinweis, was man noch mit einem Amperei machen kann, was  uns so wichtig sein kann.  Wenn man zum Beispiel die groessten Elemente finden will, dann gibt es halt noch Funktionen.  Das ist ein Amperei, aber ist wieder ein Objekt, was bestimmte Funktionen mitbringt.", "start": 698.64, "end": 714.88}, {"text": "  Eine Funktion waere zum Beispiel ARC Max.  Mit ARC Max kriege ich quasi den Index von den Element, das in dem Erray am groessten  Element ist.  Eben war das Erray.  Erray, was wir definiert haben, war hier 1, 2, 3 vorhin.  Und das heisst, die letzte Stelle an Index 2 ist das groesste Element.  Und genauso kann ich mir direkt das groesste Element raussuchen mit ARC Max, da dann eben  die drei.", "start": 714.88, "end": 747.88}, {"text": "  Was ich auch machen kann, ist, wir den ganzen Vektor summieren.  Also 1 plus 2 plus 3 ist eben 6.  Und dann auch den Absolutbetrag von dem Vektor neben.  Hier negier ich den, dann habe ich minus 1, minus 2, minus 3.  Wenn ich dann den Absolutbetrag nehme, habe ich eben wieder den urspruenglichen Vektor  1, 2, 3.  Das wieder relativ wichtig sein wird sind Slicing und Indexing Operations.", "start": 747.88, "end": 775.6}, {"text": "  Heisst, ich kann auf den ersten Eintrag, der gemein auf den Iten-Eintrag zugreifen,  einfach wieder durch eckige Klammern.  Heisst, hier A0 ist quasi die 1, der erste Eintrag.  Und ich kann eben dieses Slicing-Operation verwenden.  Die werden angegeben durch den Doppelpunkt.  Das heisst, hier sage ich, ich will Element 0 bis ausschliesslich Element 1.", "start": 775.6, "end": 796.64}, {"text": "  Das heisst, ich kriege Element 0, Element 1 nicht mehr, wuerde ich hier eine 2 hinschreiben.  Wuerde ich Element 0 und Element 1 bekommen, aber eben nicht mehr Element 2.  Was ich auch machen kann, ist hier mit minus zu arbeiten.  Minus ist quasi der Index von hinten.  Heisst, minus 1 ist von hinten gezaehlt das erste Element.", "start": 796.64, "end": 819.24}, {"text": "  Das heisst, hier moechte ich alle haben von den 0ten Element bis zum minus 1ten Element.  Das ist das letzte Element, die 3 nicht mehr.  Daher koennte ich hier schreiben bis minus 2, dann wuerde ich eben nur noch die 1 bekommen.  Das 0te Element, wo die letzten beiden Elemente nicht mehr.  Mal kurz rueckgaengig dann.  Letztlich, das eben schon einmal angeteasert.", "start": 819.24, "end": 842.04}, {"text": "  Mathematisch sind die Operationen jetzt nicht so interessant.  Da sind andere Operationen sehr viel interessanter.  Zum Beispiel das Skalarprodukt.  Habe ich jetzt geschrieben A mal B und damit meinen wir in der Regel nicht die Elementweise,  Multiplikationen, sondern das Skalarprodukt, auch genannt DotProduct.  Das kann man halt schreiben.", "start": 842.04, "end": 865.6}, {"text": "  Zum einen in diesen eckigen Klammern hier, also Skalarprodukt zwischen A und B.  Das ist wahrscheinlich die Schreibweise, die hier aus der Linie an Algebra kennt.  Auch gelaeufig ist eben halt wirklich dieses Stop-Product mit den Dot oder eben auch A Transponiert B.  Und das bietet ab von 2 Vektoren aus einem enddimensionalen Vektorraum auf eine reale Zahl.", "start": 865.6, "end": 890.04}, {"text": "  Genau, was wir im Wedentlichen machen, ist die Summe neben von dem Vektor-Weisen-Produkt,  Element-Weisen-Produkt, heisst erstes Element mal erstes Element plus weiteres Element als weiteres Element und so weiter.  Wie eben schon gesagt, koennen wir das Ganze auch schreiben und das A Transponiert mal B.  Dann haben wir aus den Spaltenvektoren, wird durch das Rund Sponieren, ein Zeim-Vektor.", "start": 890.04, "end": 911.12}, {"text": "  Zeim-Vektor mal Spalten-Vektor ist dann eben genau diese Summe ueber den Produkten.  Ja, geometrisch koennen wir das Skalarprodukt verstehen, als ein Mass fuer die Aehnlichkeit der Laenge und das Winkel zwischen dem Bein-Vektor.", "start": 912.5600000000001, "end": 932.12}, {"text": " Oder auch anders geschrieben, das Skalarprodukt entspricht den Cosin-Nos von dem Winkel zwischen den Bein-Vektoren,  mal die Laenge von dem Ein-Vektor, mal die Laenge von dem anderen Vektor.  Aber wenn der Winkel jetzt genau 0 ist, die Bein-Vektoren also genau parallel zueinander verlaufen,  dann habe ich den Cosin-Nos von 0, das ist genau 1, dann wird das Skalarprodukt also gross.", "start": 932.12, "end": 950.76}, {"text": "  Wenn ich den Cosin-Nos von 90 Grad habe, dann also Cosin-Nos von Pi halbe, dann ist der Cosin-Nos genau 0.  Erstes Skalarprodukt wird dann 0 und ganz klein.  Das habe ich hier nochmal anders dargestellt, also wir haben hier den Vektor U und den Vektor V  und der Winkel Alpha ist halt eingeschlossen zwischen dem Bein-Vektoren.", "start": 952.04, "end": 971.88}, {"text": "  Das Skalarprodukt zwischen UnV entspricht dann genau den Cosin-Nos von Alpha, mal V, mal U, also mal die Laenge V, mal die Laenge U.  Aber was relativ wichtig sein wird fuer ein paar Themen ist, dass man das Skalarprodukt verstehen kann als eine Projektion von einem Vektor auf den anderen.", "start": 973.88, "end": 990.04}, {"text": "  Das heisst, wenn ich hier den Vektor V habe und mit dem mal verlaengern, der ist das Skalarprodukt von V und U-Naeme,  dann kann ich mir das vorstellen, als wenn ich den Vektor U auf den Vektor V jetzt hier rauf projizieren wuerde.  Also ich verlaenge hier V und es klappt jetzt quasi U gerade runter, so dass das halt hier autogonal auf den V steht.", "start": 990.04, "end": 1010.04}, {"text": "  Gerade runter, dann kriege ich quasi die Laenge von hier bis zu dem Anfang.  Das wollen wir jetzt einmal kurz mathematisch begruenden, dass das so ist.  Kurzer Hinweis, vorab nochmal genauso gut koennte ich das halt auch verstehen, dass wuerde ich V auf U projizieren.  Wir betrachten das jetzt aber mal so rum, dass sie eben U auf V projizieren.", "start": 1010.04, "end": 1029.24}, {"text": "  Ein erster Hinweis, dass es tatsaechlich so sein koennte, dass sie diese Laenge bekommen.  Stellen wir uns vor, V ist der Einheitsvektor, das habe ich genauso hier jetzt schon hingeschrieben.  Dieser Vektor ist quasi einfach 1,0, also entspricht einfach genau den Einheitsvektor.  Jetzt sieht ein Einheitsvektor im Skalaprodukt mit U nehmen, habe ich ja 1 mal U1 plus 0 mal U2.", "start": 1029.24, "end": 1052.44}, {"text": "  Als ich kriege genau U1 rauf, habe ich hier oben mal geschrieben, U1 ist gleich U mal 1.  Und dieser erste Eintrag U1 entspricht ja genau der Laenge entlang dieser Koordinatenachse.  Jetzt haben wir quasi genau diese geometrische Interpretationen von dem Vektor U.  U1 ist quasi genau die Laenge, die ich in diese Richtung gehe.", "start": 1052.44, "end": 1071.88}, {"text": "  Es passt ja auch genau, dass genau diese Projizoren von U hier nach unten,  dann habe ich genau diese Laenge, die ich in diese Richtung das ersten Einheitsvektor gehe.", "start": 1071.88, "end": 1094.44}, {"text": " Genau, wenn ich jetzt V ein bisschen veraendern wuerde und dann das Skalaprodukt von V und U nehmen wuerde,  dann wuerde ich quasi genau die Laenge kriegen, die ich entlang von V geben muss,  damit ich dann genau an den Punkt ankomme, wenn ich U orthogonal auf den Vektor vorbeiziehen wuerde.", "start": 1096.04, "end": 1103.48}, {"text": " Hier habe ich das nochmal hingeschrieben, diese Identitaet, das Skalaprodukt des Kozynos I,  einfach mal die beiden Laengen.  Wenn ich jetzt denke, okay, V ist eben dieser erste Einheitsvektor, dann hat er genau Laenge 1.  So, das heisst, Kozynos mal 1 mal Laenge U ist genau Kozynos mal Laenge U.", "start": 1103.48, "end": 1124.1200000000001}, {"text": " Und wenn ich mir jetzt einmal diese trigonomeraetschische Gleichung hier angucke,  dann weiss ich, dass Kozynos von I, genau Ankhatete durch Hypotenuses.  Hypotenuse in einem rechtwindigen Dreieck ist die laengste Seite, die gegenueber von dem rechten Winkel liegt.", "start": 1124.1200000000001, "end": 1139.64}, {"text": " Und die Ankhatete ist die andere Seite, die nahe bei dem Winkel liegt,  die Gegenkartete, wer dann die, die wieder genau gegenueber von dem Winkel liegt.  So, hier habe ich Ankhatete durch Hypotenuse, das Kozynos von dem Winkel.  Jetzt gucke ich mal dieses Laenge U an.  Laenge U ist genau die Laenge von der Hypotenuse.  Deshalb habe ich hier Kozynos mal Laenge Hypotenuse stehen.", "start": 1140.6000000000001, "end": 1160.3600000000001}, {"text": "  Kozynos, wenn ich hier die Hypotenuse rueber multipliziere,  habe ich genau Kozynos mal Hypotenuse, das gleich Laenge Ankhatete.  Das Kozynos mit Laenge U ist genau die Laenge von dieser Projekten, von dieser Ankhatete.  Ich zeige quasi nochmal mathematisch, dass sie jetzt empirisch an dem Beispiel mit dem Skalaprodukt, mit dem ich einen Standardbasisfaktor gesehen habe.", "start": 1160.3600000000001, "end": 1187.6399999999999}, {"text": "  Ja, das Skalaprodukt ist eine lineare Operation.  Und jetzt moechte ich wieder eine Frage an euch geben, welche drei Eigenschaften muessen entgaten,  damit das Skalaprodukt wirklich linear ist.  In Lino habt ihr das so gemacht, ihr habt Skalaprodukte vorgegeben, also nicht das Standardskalaprodukt,  das was wir jetzt hier eben verwendet haben.", "start": 1187.6399999999999, "end": 1206.6000000000001}, {"text": "  Ihr habt andere Definitionen an das Skalaproduktes gegeben bekommen,  seit der Zeitung, dass wirklich ein Skalaprodukt ist.  Man musste die dann Zeitung, dass wirklich drei Eigenschaften erfuellt sind.  Und da bitte ich euch jetzt einmal euch zu erinnern, welche drei Eigenschaften das waren.  Genau, jetzt habt ihr hoffentlich einen Moment drueber nachgedacht.", "start": 1206.6000000000001, "end": 1230.04}, {"text": "  Das Skalaprodukt ist eine lineare Operation, das heisst, das Skalaprodukt ist symmetrisch.  Also um Skalaprodukt mit V ist genau das gleiche wie V mal U.  Es ist homogen.  Das heisst, wenn ich das Ergebnis in den Skalaprodukten in Skala alpha multipliziere,  das ist genau das gleiche, als wenn ich einen Vektor skaliere und dann das Skalaprodukt nehme.", "start": 1230.04, "end": 1255.0}, {"text": "  Also einfach mal das Skalaprodukt, das ist gleich einfach mal U zum Skalaprodukt mit V.  Und es ist additiv.  Das heisst, wenn ich das Skalaprodukt von U mit V plus V nehme,  das ist genau das gleiche, als wenn ich das Skalaprodukt zwischen U und V nehme, plus das Skalaprodukt zwischen U und V.", "start": 1255.0, "end": 1277.96}, {"text": "  Eine letzte Operation oder Vektoroperation, die wir in diesem Video abdecken wollen, ist die Vektornorm.  Da haben wir eben schon, glaube ich, implizit an der Verwendung, genau fuer die Laenge eines Vektors,  das Skalaprodukt, also die Vektornorm bildet ab einen Vektor auf seine Laenge.", "start": 1277.96, "end": 1293.8000000000002}, {"text": "  Also einen beliebigen Vektor mit beliebigen Dimensionen, abgebildet auf eine reale Zahl, die der Laenge entspricht.  Ganze koennen wir auch schreiben, dass die Wurzel von dem Vektor zum Skalaprodukt mit sich selbst oder anders gesagt einfach die Wurzel aus der Summe ueber den Quadraten der einzelnen Eintraeger.", "start": 1294.12, "end": 1319.56}, {"text": "  Ja, jetzt wollen wir uns nochmal halt anschauen, wie wir das Ganze in Numper einkaufen wollen, umsetzen koennen.  Und dafuer haben wir hier erstmal eine naive Implementation.  Als Doppel die Funktion implementiert ist das Skalaprodukt zwischen dem Vektor A und dem Vektor B.  Mit sich das Skalaprodukt ausrechnen kann, muss erstmal gaten, dass A und B dieselbe Dimensionen haben.", "start": 1319.56, "end": 1339.9599999999998}, {"text": "  Mit NumperAway.Shape kriege ich die Dimensionen von einem Away,  da pruefe ich, ob der Shape von A genau derselbe ist wie der Shape von B, sprich ob beide genau dieselben Dimensionen hat.  Naemlich mit einer Variabe C, die am Ende zurueckgebe, hier will ich also das Skalaprodukt aufseh'n mir.  Im Wesentlichen etiriere ich jetzt einfach ueber die einzelnen Eintraege.", "start": 1339.9599999999998, "end": 1363.08}, {"text": "  Also mit A und Zahl kriege ich die Anzahl der Eintraege in dem Vektor und da etiriere ich rueber mit dieser Vorschleife.  Dann summiere ich auf C einfach auf A von I, also in den Iteneintrag von A, bei den Iteneintrag von B.  Das summiere ich auf und dann kriege ich am Ende das Skalaprodukt.", "start": 1364.28, "end": 1386.52}, {"text": "  Hier als Beispiel habe ich einmal den Vektor A, 1, 2, 3 und den Vektor B, der unten zufass-Vektor ist und hier nehme ich das Skalaprodukt.  Diese Implementation ist eben naiv und nicht sehr effizient, weil Vorschleifen mit Numper in der Regel sehr langsam sind.", "start": 1388.52, "end": 1405.64}, {"text": "  Also wenn ich so eine simple Vorschleife habe, dann gibt es in der Regel dafuer eine Numper-Operation, die genau das Gleiche umsetzt, nur sehr viel schneller.  Und schneller deswegen, weil eben diese Schleife langsam ist.  Und was Numper macht, Numper macht im Wesentlichen quasi fast das Gleiche im Hintergrund, greift aber auf eine schnellere C Implementation zurueck.", "start": 1407.16, "end": 1423.8000000000002}, {"text": "  Das heisst Numper ist im Untergrund teilweise mit C implementiert.  Und wir steuern quasi diese C-Operationen, die das Ganze schnell macht, einfach nur zuegig an.  Ich numpele.  Genau, hier habe ich jetzt noch ein bisschen Python hinterrund versteckt und zwar habe ich hier eine Error-Handling, also ein Error-Handling mit eingebaut.  Das heisst, ich sage Try, dann ein Codeblock.", "start": 1424.76, "end": 1453.32}, {"text": "  Ihr probiert wer und eine kritische Operation und erwartet, dass eventuell ein Fehler-Value-Ewer zurueckkommen koennte.  Dem bezeichne ich als Fehler E.  Wenn der Auftritt moechte ich den Ausgeben mit Fint E.  Und wenn wir hoffen natuerlich, dass nichts passiert und wenn nichts passiert, gebe ich den Wert von dieser Operation zurueck und diese Operation A.B.", "start": 1453.32, "end": 1477.8000000000002}, {"text": "  Das ist quasi genau das Galaprodukt, also genau das Dot-Produkt zwischen A und B.  Also ist deswegen eine kritische Operation, weil es eben sein kann, dass A und B in unterschiedlichsten Shape haben.  Also dass A und Vektor mit 4 Antraegen ist, dass B und Vektor mit 3 Antraegen ist.  Dann wuerde das Ganze nicht funktionieren, wir wuerden Value-Ewer bekommen.", "start": 1477.8000000000002, "end": 1499.88}, {"text": "  Deswegen, halt vorsichtsaalbar koennte man hier eben dieses Ewer-Handling drum herum schalten.  Dann gibt es hier ein paar spezielle Faelle.  Also ich habe einmal den Vektor U, das ist der erste Einheitsvektor, der Vektor V1 ist der zweite Einheitsvektor.  V2 ist 20, V3 ist 1, 1.  Dann haben wir eben die Vektor-Operation der Linernorm gesehen, als mit NumPylineIkeNorm.", "start": 1501.88, "end": 1525.88}, {"text": "  Dann wird die Vektornorm von deinem Vektor ausrechnen.  Die moechte ich jetzt hier benutzen und den Vektor V3 zu normalisieren.  Das wir wollen den Vektor V3 auf Einheitslaenge bringen.  Eine Reichlichkeit, indem ich schreibe V3,  gleich V3 geteilt durch mp-linearei-gebra.norm.v3.  So jetzt rechne ich hier V1 raus, U2, U3.  U.v1 ist genau 0, weil 1 mal 0 ist 0, plus 0 mal 1 wieder 0, also 0.", "start": 1525.88, "end": 1565.88}, {"text": "  Dann U.v2 ist 1 mal 2 plus 0 mal 0, also genau 2.  Und hier habe ich jetzt 1 mal diesen Vektor normiert, also den ersten Eintrag von dem normierten Vektor,  plus 0 mal den zweiten Eintrag von dem normierten Vektor, also genau 1 mal normiert.  Und deshalb gibt da 0,71 an der V.  So damit werden wir durch in diesem Video.  In dem naechsten Video geht es dann weiter mit Pinniern-Abbildung.", "start": 1565.88, "end": 1597.88}, {"text": "  Dafuer brauchen wir gleich diese Plottingfunktionen hier.  Ihr muesst ihr nicht verstehen, die ist einfach nur um ein paar Sachen gleich zu veranschaulichen.  Weiter geht es dann im naechsten Video.", "start": 1597.88, "end": 1608.88}]}]