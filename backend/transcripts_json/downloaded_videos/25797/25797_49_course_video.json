[{"lecture": "25797_49_course_video", "Timestamps": [{"text": "  Also fuer heute die schnelle Fourier-Transformation oder auch auf Englisch FFT fuer Fast Fourier-Transform.  Der wichtigste Teil dabei ist die Eigenschaft von den Elementen oder sind die Eigenschaften von den Elementen, die in der Fourier-Transformation drin stehen.", "start": 0.0, "end": 51.0}, {"text": "  Dafuer noch mal als Erinnerung, wir hatten gesagt fuer ein Element Klein X aus R hoch n ist die Fourier-Transformation die Multiplikation mit einer Matrix.", "start": 52.0, "end": 85.0}, {"text": " Typischerweise macht man es so, dass die Vorwaerts-Transformation eben diese Matrix ist, die die Eigenvektoren enthaelt, der zyklischen Transformation komplex konjugiert,  mal den Vektor, der das Signal enthaelt. Ich glaube ich habe letztes mal hier ein T hingeschrieben, das ist natuerlich relativ ungluecklich fuer eine komplexe Matrix, wenn man die Inverse von einer unitaeren Matrix sucht.", "start": 85.0, "end": 104.0}, {"text": "  Ich wollte die komplex konjugiert transponieren natuerlich. Also das ist die Vorwaerts-Transformation, hier steht eigentlich ein ordineres Matrix-Vektorprodukt, die Matrix ist quadratisch, X enthaelt n Elemente, also enthaelt auch gross Xn Elemente.", "start": 105.0, "end": 123.0}, {"text": "  Und dieses Omega nochmal zur Erinnerung, das sind diese Eigenvektoren eben hier komplex konjugiert transponiert von den zyklischen Matritzen, das heisst das ist immer die gleiche Matrix fuer ein festes n.  Okay.", "start": 124.0, "end": 146.0}, {"text": "  Und normalerweise, was kostet diese Operation, wenn dieses Xn Elemente enthaelt, dann bekomme ich den ersten Eintrag von diesem gross X, indem ich hier oben jedes dieser n Elemente aus X mit einem dieser Elemente in der Matrix multipliziere und auffaudiere.", "start": 147.0, "end": 171.0}, {"text": "  Das heisst der Aufwand fuer das erste Element in dem gross X ist o von n, n Operation. Wenn ich das einfach mache, habe ich n Multiplikationen und dann n-1 Additionen, also n fuer jedes Element klingt verdammt nach o von n Quadrat.  Also es sieht so aus, zunaechst mal, als ob wir hier einen Aufwand von o von n Quadrat haben fuer dieses Matrix-Produkt.", "start": 172.0, "end": 197.0}, {"text": "  Und diese ganze Geschichte, warum wir uns jetzt verzweifelt die Eigenvektoren und Eigenwerte angeschaut haben und so, da koennte man jetzt sagen aus der Mathematik her ist das irgendwie faszinierend, dass all diese Matritzen die gleichen Eigenvektoren haben, aber fuer uns als Informatiker ist das mehr eine Randnotiz.", "start": 198.0, "end": 206.0}, {"text": "  Und jetzt kommt sozusagen der wichtige Teil, naemlich, dass diese Operation fuer diese spezielle Matrix schneller geht.  Dazu muessen wir uns noch mal erinnern, was in dieser Matrix drin steht. In dieser Matrix stehen drin die Einheitswurzeln und die haben gewisse Eigenschaften.  Die koennten wir uns vielleicht so definieren. Machen wir hier mal einen k.", "start": 209.0, "end": 236.0}, {"text": "  Was war das? Das waren diese Dinge in der komplexen Zahlenebene.  Das war zum Beispiel so ein Element, das den Einheitskreis in Achtel unterteilt und dann waere das hier omega hoch 1, 8.  Hier habe ich dann 2 Achtel, hier habe ich dann 3 Achtel, omega Acht hoch 3.  Ganz allgemein habe ich also E hoch, sagen wir mal minus 2 Ip mal k durch N.", "start": 237.0, "end": 293.0}, {"text": "  Und wichtig jetzt, um hier was zu sehen, wir schreiben uns gleich diese Matritzen mal hin.  Vielleicht fange ich damit schon mal an.  Ich fange ich damit schon mal an. Wir schreiben uns mal hin.  Omega 2.  Ja, was steht da drin?  Da stand also drin, alle Omegas sind zur Basis 2.", "start": 293.0, "end": 351.0}, {"text": "  In der ersten Spalte stehen die, die einfach ueberall eine Null haben und in der zweiten Spalte stehen die, die beim ersten Element eine Null haben und dann beim zweiten Element eine 1 und so weiter.  Schreiben wir uns mal, weil man da vielleicht nicht so sieht, auch noch omega 4 hin.  Da steht dann omega 0.  Dann kommt dieses omega 1, Achtquatsch 0, 1, 2, 3.", "start": 351.0, "end": 390.0}, {"text": "  Und wie ging es weiter? Jetzt kam hier omega 0, omega hoch 2, omega hoch 4, omega hoch 6 und dann 0, omega hoch 3, omega hoch 6, omega hoch 9.  So waren die aufgebaut.  Die erste Spalte lauter null, dann null, 1, 2, 3 und so weiter, dann null, 2, 4, 6, dann null, 3, 6, 9, 12 und so weiter.  Und offensichtlich kann ich das genauso in den Zeilen lesen.  Das waren diese Matritzen.", "start": 390.0, "end": 418.0}, {"text": "  Da stehen also lauter Potenzen von diesen Zahlen drin.  Und was wir finden werden, das kann ich ja schon vorher verraten, ist, dass wir die Berechnung von dem Ding ausdruecken koennen, als 2-mal die Berechnung von dem Ding plus einfache Operation.  Also klassisches Teile und Herche.  So, deswegen ueberlegen wir uns jetzt hier ein paar Sachen, wie sich diese Dinger verhalten.", "start": 418.0, "end": 472.0}, {"text": "  Zum Beispiel, omega hoch 1 zur Basis von 2 ist das Gleiche wie in der Basis 4 welche Potenz?  2, genau.  Oder auch in der Basis 8 welche Potenz?  4.  Diese sind alles die gleichen Zahlen.  Fuer diese Zahl haben wir auch einen Namen, naemlich...  Vorschlaege, ja?  Von?  Von 1.  Von 1, und zwar welche?  Nee, es gibt 2.  Minus 1, genau.", "start": 473.0, "end": 527.0}, {"text": "  Ja, es gibt 2, 2 Wurzeln von 1, 2 reelle Wurzeln von 1, die 1 und die minus 1, und das ist die minus 1.  Ja, das Omega zur Basis 2 ist die Zahl hier auf dem Einheitskreis, die ich 2-mal rumgehen muss, um wieder vorne anzukommen.  Und es ist genau der Punkt hier, die minus 1.  Ja, genauso haben wir omega hoch 1.", "start": 528.0, "end": 565.0}, {"text": "  Wenn wir den Kreis vierteln, ist das Gleiche wie omega hoch 2, wenn wir den Kreis achteln und so weiter, und all, das ist i.  Ja?  Das haben wir i genannt.  Ja, das ist i, ist hier keine...  ...babygerechte Erklaerung von der Eignung von irgendwas, ja, sondern...  ...zahntet sich um die...  ...um das Zeichen fuer die Wurzel aus minus 1.  So.  Gut.", "start": 565.0, "end": 596.0}, {"text": "  Diese Regeln sind hoffentlich alle soweit einsichtig, ja?  Wenn hier die Basis und hier der Exponent das gleiche Verhaeltnis haben, dann sind das die gleichen Zahlen.  Und wir sehen das sofort hier.", "start": 596.0, "end": 624.0}, {"text": " Hier in der Beschreibung von Omega n ueber die Exponent-zialfunktion steht hier hinten k durch n, ja?  Wenn also k durch n den gleichen Wert hat hier, 1 durch 2, 2 durch 4, 4 durch 8, ist das immer die gleiche Zahl.  Ja?  Wir koennen miteinander in Verbindung bringen die Fourier-Transformation von zwei Elementen und die Fourier-Transformation von vier Elementen und von acht Elementen und so weiter.", "start": 624.0, "end": 638.0}, {"text": "  Ja?  Also die Eintraege, die in dieser Fourier-Matrix drin stehen fuer die Transformation von einem achter Vektor, die kann ich zum Teil interpretieren als Eintraege von der Matrix fuer den Vierer-Vektor.  Ja?  Das ist der Trick.  So.  Versuchen wir das mal, oder?  Ups, da.  Also entweder werde ich immer schwaecher oder diese Tafeln immer schwergegen, ja?  Oder beides.", "start": 638.0, "end": 692.0}, {"text": "  So, tragen wir hier mal ein, was wir wissen.  Also das Ding koennen wir uns ein bisschen anders hinschreiben.  Die drei Dinger hier, das sind einfach 1 und das ist eine minus 1.  So, gleiches machen wir da vorne.  Das sind alles 1.  So, das ist alles hier zur Basis 4.  Da haben wir also hier Omega hoch 1 zur Basis 4.  Das war i.  Dann haben wir hier zwei Eintraege Omega hoch 2 zur Basis 4.", "start": 692.0, "end": 761.0}, {"text": "  Das ist minus 1.  So, minus 1.  Als naechster Eintrag begegnet mir hier Omega hoch 3 zur Basis 4.  Ja, wie koennte ich das nennen?  Minus i.  Das sehe ich ein.  Omega hoch 4 zur Basis 4, Vorschlaege.  Ja, 1.  Omega hoch 6 zur Basis 4, Vorschlaege.  Ja, minus 1.  Und Omega hoch 9, ja.  Fast, fast genau i.  So, okay.  So weit so gut.", "start": 762.0, "end": 840.0}, {"text": " Sehen wir irgendwas?  Wer jetzt etwas sieht, der sieht wirklich sehr viel.  Es ist nicht einfach zu sehen.  Aber was ist unser Ziel?  Unser Ziel habe ich ja schon verraten.  Unser Ziel wird sein, zu sagen,  vielleicht muss ich nicht das,  vielleicht muss ich nicht Produkt damit bilden,  sondern vielleicht kann ich irgendwie Produkt damit ausdruecken,  durch Produkte damit.", "start": 840.0, "end": 863.0}, {"text": "  Das klassische Teil- und Herrscheprinzip,  wenn ich das irgendwie geschickt kann,  dann sehe ich eine Chance fuer einen reklusiven Algorithmus,  der irgendwie Sachen zusammenbaut,  aus den Loesungen fuer das halbe Problem.  Und solche Algorithmen haben oft, haben oft N-Lock N.  Ja, und da werden wir heute eben auch hinkommen.", "start": 863.0, "end": 891.0}, {"text": " Ich verrate einen Trick, den man wirklich,  ich mein immerhin habe ich noch nicht gesagt,  ich habe den Algorithmus gefunden, die schnelle Fourier-Transformation,  hatte ich glaube ich schon gesagt, gauss.  Also immerhin gauss, ja, okay.  Wenn man es also nicht sieht, muss man sich nicht schaemen.", "start": 891.0, "end": 915.0}, {"text": " Ich wuerde sagen, von den Sachen, die gauss gesehen hat,  haben wir alle zusammen keinen relevanten Teil gesehen.  Damit moechte ich niemandem auf die Fuesse treten,  das ist nicht unrealistisch.  So, der Trick ist folgender,  wir ordnen diese Matrix ein bisschen um.", "start": 915.0, "end": 944.0}, {"text": " Es ist offenbar nicht teuer,  statt den Vektor x0, x1, x2, x3 da drauf zu multiplizieren,  zu sagen, ich erlaube mir die Reihenfolge der Elemente zu vertauschen.  Ich schreibe hier erstmal die Gradelemente hin  und dann die Ungraden.  Dabei aendert sich auch am Ergebnis nichts.", "start": 944.0, "end": 967.0}, {"text": " Wenn ich hier spalten vertausche  und dafuer hier auch die Elemente vertausche,  aber an den Zeilen nichts mache, ist das Ergebnis voellig in Ordnung.  Ich muss mir nur merken, dass ich da Vertauschungen vorgenommen habe.  Also bezueglich dieser Reihenfolge passiert hier was?  Wir haben erst die erste Zeile,  dann haben wir die erste Spalte, dann die dritte Spalte,  die hier,  und dann die hier.", "start": 967.0, "end": 1031.0}, {"text": "  Ich habe mal Spalten getauscht,  mit der Idee zu sagen,  wenn ich spalten tausche,  dann bedeutet es nichts anderes,  als dass ich in dem Vektor, den ich da drauf multiplizieren muss,  Elemente tausche.", "start": 1031.0, "end": 1057.0}, {"text": " Und diese Tauschoperation, die ich hier durchgefuehrt habe,  jetzt wieder gedacht,  im Hinblick auf Effizienz,  diesen N-Vektor abzulaufen  und so wie wir das hier gemacht haben,  die gerade Elemente nach vorne zu schreiben  und die ungrade nach hinten,  ist offenbar eine O von N-Operation.", "start": 1057.0, "end": 1071.0}, {"text": " Besser als O von N werden wir nicht werden,  denn am Ende haben wir N-Elemente,  die daraus kommen,  die wollen wir allen Wert zuschreiben,  also die Operation wird mit Sicherheit nicht besser als O von N.  Also aus asymptotischer Sicht koennen wir uns erlauben,  jede lineare Operation da einzubauen,  ohne dass wir uns wehtun.", "start": 1071.0, "end": 1091.0}, {"text": " So, das habe ich gemacht  und jetzt sehe ich,  also jetzt glaube ich,  sieht jeder auf jeden Fall schon mal 2  von den kleineren Transformationen.  Also das ist doch jetzt offenbar,  auf jeden Fall hier vorne,  steht jetzt hier  und hier  genau das gleiche wie hier.  Also da steht jetzt Omega 2  und da steht auch Omega 2.  Hier hinten steht nicht Omega 2, aber fast.", "start": 1091.0, "end": 1125.0}, {"text": "  Ja, verdaechtig hier in diesem Block schon mal,  hier oben die 2 1, die sehen schon mal gut aus.  Wie kriege ich  dieses Ding hier  dazu so auszusehen?  Wenn ich das mit I multipliziere,  dann habe ich hier I, I, I, minus I.  Ganz so einfach ist es nicht, aber fast so ein.  1 I, genau, als? Ja?  Da oben?  Nein, ja, also  ich glaube nicht.", "start": 1125.0, "end": 1175.0}, {"text": " Also,  wir muessen die obere Zeile mit 1 multiplizieren  und die untere Zeile mit I.  Wie machen wir das?  Wir multiplizieren das mit einer Diagonalmatrix.  1 I.  Und hier unten glaube ich, ist jetzt dann auch klar,  was passiert.  Das ist einfach  Omega 2, auch 1 I  mit einem Minus davor.  Jetzt haben wir es.", "start": 1175.0, "end": 1207.0}, {"text": " Jetzt haben wir es zusammengebaut, wir koennen also sagen,  die Fourier-Transformation auf einem 4-elementigen Vektor  laesst sich wie folgt ausrechnen.  Wir sortieren den 4-elementigen Vektor um,  sodass hier die Grade-Elemente zuerst kommen  und dann die Ungraden.  Auf den Grade-Elementen machen wir folgendes.", "start": 1207.0, "end": 1232.0}, {"text": " Auf den Grade-Elementen addieren wir  die Fourier-Transformation von den Elementen  mit der Fourier-Transformation von diesen Elementen,  von den Ungraden-Elementen,  multipliziert mit dieser Diagonalmatrix.  Wichtig, wichtig, wichtig ist hierbei,  dass diese Matrix, die hier davor steht,  eine Diagonalmatrix ist.", "start": 1232.0, "end": 1257.0}, {"text": " Denn das Produkt mit der Diagonalmatrix,  wenn die N mal N Elemente enthaelt,  ist Produkt von Diagonalmatrix mit einem Vektor,  ist eine O von N-Operation.  Sie sind offenbar N-Multiplikationen.  Waehrend das Produkt mit einer vollbesetzten Matrix  eben quadratisch ist.", "start": 1257.0, "end": 1279.0}, {"text": " Das heisst, was wir geschafft haben,  ist, wir haben dieses Produkt mit einer vollbesetzten Matrix  ausgedrueckt, als Produkte mit einer halb so grossen  vollbesetzten Matrix, plus Operationen, die linear sind.  Und nicht quadratisch.  Das ist das, was Gauss irgendwie vor dem Fruehstueck gesehen hat.  Und sich dann wichtigen Dingen zugewendet hat.", "start": 1279.0, "end": 1311.0}, {"text": " Das Schoene ist, offensichtlich, diese Beobachtung,  die geht fuer alle Enden.  Das, was wir hier gemacht haben,  das ist nicht eine Beobachtung fuer die Matrix mit 4 Eintraegen  und fuer die mit 2 Eintraegen,  sondern das ist eine ganz allgemein fuer 2 N-Eintraege  und N-Eintraege.", "start": 1311.0, "end": 1334.0}, {"text": " Und das liegt eben an dieser Struktur,  die wir eben noch dastehen hatten,  mit diesem Omega hoch sowieso, Omega hoch sowieso.  Fuer diese ganzen Gradendizes, die kann ich alle nach vorne schreiben  und die Formen dann, die Gradendices,  formen zweimal die Matrix, die eins kleiner ist.  Wir schreiben es uns mal hin und dann erklaere ich noch, warum.  Ja, ich schreife sie gleich hin.", "start": 1334.0, "end": 1368.0}, {"text": "  Genau, ja, ja. Also, die wird dann komplizierter ist, klar, ne?  Wo habe ich sie hier getan?  Wichtig hier ist, ist eben, sind diese Beziehungen.", "start": 1384.0, "end": 1431.0}, {"text": " Ich finde, hier sieht man schoen dran,  dass die Gradzahligen rein, also die Zeilen,  die Spalten, die zu einem Gradenindex bekommen,  dass die genau die Basisformen, die ich bekomme,  wenn ich durch zwei Teile dieses N, ja?  Ich versuch das mal anzudeuten.  Ich habe also hier, ich schreibe jetzt mal hier unten 2 N hin, 0,  Omega 2 N 0, dann habe ich die naechste Spalte,  ja, da steht eben 1 2 N.", "start": 1431.0, "end": 1456.0}, {"text": "  Hier, also wieder 0 2 N, hier steht jetzt Omega hoch 2 2 N, ja?  Dann kommt hier wieder ein Element, hier steht Omega 0 2 N,  Omega 3 2 N, Omega 0 2 N, Omega hoch 4 2 N, ja?  Und wenn ich mir jetzt diese Spalte und diese Spalte und diese Spalte angucke,  dann sehe ich, ich kann die auch interpretieren als, also das ist das Gleiche wie,", "start": 1456.0, "end": 1491.0}, {"text": " Omega hoch 0 N, Omega hoch 1 N, Omega hoch 2 N und so weiter, ja?  Also einzusehen, dass die Gradzahligen Spalten,  wenn ich die einfach zusammenschiebe, genau die Basis geben,  fuer, fuer in Halbe ist fuer mich ziemlich klar, ja?  Und was passiert hier in der Laenge?  Also warum sehe ich oben einen Block und unten einen Block?  Naja, also da mache ich einfach mal Zahlen.", "start": 1491.0, "end": 1527.0}, {"text": "  Nehmen wir mal den hier, ich habe also 0 2, dann kommt 4  und so weiter, 6, ja?  Und wenn ich jetzt hier statt 2 N die Ns hinschreibe, ja?  Dann laeuft dieser Vektor eben nicht von 0 bis von, von ueber, also 0,  jetzt habe ich durch 2 geteilt.", "start": 1527.0, "end": 1569.0}, {"text": " Wenn ich jetzt durch 2 Teile, dann laeuft dieser Vektor hier,  der laeuft ja 0, 2, 4, 6, 8 und wenn der am Ende angekommen ist,  dann ist der 2 Mal durch N durchgelaufen, ja?  Der hier, 3 und so weiter, dieser Vektor hier,  fuer den bekomme ich genau alle Potenzen von 0 bis N minus 1, ja?  Und fuer den bekomme ich alle Verdoppelten.  Ja, das heisst der laeuft einmal bis 2 N und dann nochmal bis 2 N.", "start": 1569.0, "end": 1592.0}, {"text": "  Wenn ich jetzt alles durch N Teile, durch 2 Teile,  Entschuldigung, dann laeuft er eben einmal bis N und dann nochmal bis N.  Deswegen bekomme ich da vorne diese 2 Bloecke.  So, schreiben wir uns jetzt mal hin.  Also das war nur ein Beispiel hier.  Jetzt sagen wir, wir haben gegeben Omega N und koennen das schnell ausrechnen.", "start": 1592.0, "end": 1632.0}, {"text": " Und wir suchen jetzt das Produkt mit Omega 2 N, ja?  Und ich mache hier mal ein Strich hin, um mir zu merken,  dass ich hier am Ende nicht mit X0, X1, X2, X3 und so weiter multipliziere,  sondern mit X0, X2, X4 und so weiter und dann mit X1, X3, X5 und so weiter.  Ja, also ich sortiere mir das um und dann haben wir eben gesehen,  hier vorne taucht einfach 2 Mal Omega N auf.  Gut.", "start": 1632.0, "end": 1665.0}, {"text": "  Was ist jetzt mit diesen Ungradenindizes passiert?  Da mussten wir offenbar noch was korrigieren.  Also die tauchten hier hinten auch auf aus den gleichen Gruenden.  Nur muessen wir die jetzt geschickt alle immer eins weiter drehen.  Also die Beobachtung ist, die erste Zeile ist schon okay,  deswegen taucht in unserer Diagonalmatrix hier eine 1 auf.", "start": 1665.0, "end": 1693.0}, {"text": "  In der naechsten Zeile haben wir sozusagen einmal weiter gedreht,  das heisst hier steht Omega drin, ja?  Und zwar bezueglich 2 N.  Dann kommt Omega Quadrat bezueglich 2 N und so weiter.  Also auf dieser Diagonalen stehen einfach die Potenzen von Omega.  Es bleibt eine Diagonalmatrix, ich muss nur jede Zeile nach und nach immer 1 weiter drehen,  bezueglich der Basis 2 N.", "start": 1693.0, "end": 1725.0}, {"text": "  Ja, das erste Element ist okay, wie es ist.  Die naechste Zeile muss ich einen Tick drehen, die die naechste, die darauf folgende Zeile  muss ich zwei Ticks drehen und so weiter.  Ja, und hier unten ist genau das gleiche, Omega 2 N, Omega Quadrat 2 N und so weiter.  Okay.", "start": 1725.0, "end": 1757.0}, {"text": " Ja, und das ist der gesamte Trick, der schnellen Furiertransform,  ich schreibe es mal ordentlicher hin, das sieht ja nicht so schoen aus.  Also hier stehen Matritzen, 1, Omega 2 N, Omega Quadrat 2 N, mal Omega N.  Und hier minus 1, Omega 2 N, Omega Quadrat und so weiter, mal Omega N.  Ja.", "start": 1758.0, "end": 1803.0}, {"text": " Das heisst, was ist zu tun?  Wenn ich die Furiertransformation eines Vektors der Laenge 2 N haben moechte,  dann kann ich das so machen.  Ich sortiere mir alle geradezahligen, also alle Elemente mit geradezahligen Index nach vorne in den Vektor,  dann nehme ich alle Elemente mit ungradezahligen Index.", "start": 1803.0, "end": 1823.0}, {"text": "  Das ist eine Operation, die kann ich durch einmal ueber die Elemente fahren in Ohr von 2 N durchfuehren.  Ja.  Und dann passiert folgendes.  Fuer den Teil mit den geradezahligen Index muss ich mir eine Furiertransformation der Groesse N bestimmen.  Denn Omega N mal diese Indizes heisst nicht anders als Furiertransformation ausrechnen.", "start": 1823.0, "end": 1847.0}, {"text": "  Und das Gleiche mache ich mit den Ungraden, die kommen hier hinten drauf.  Das heisst, ich teile meinen Vektor auf in die gerade Elemente und die ungrade Elemente  und mache mit diesen beiden Teilmengen meine Furiertransformation.  Und dann muss ich das Ergebnis aus der ungrade Furiertransformation noch mit einer Diagonalmatrix multiplizieren.", "start": 1847.0, "end": 1874.0}, {"text": "  Das heisst, ich nehme jedes Element aus diesem Ergebnis-Vektor und multipliziere es auf das entsprechende Element hier.  Das ist eine Operation, die braucht N-Schritte.  Und dann addiere ich diese beiden Vektoren.  Das ist eine Operation, die braucht auch N-Schritte.  Einmal N oben, einmal N unten und dann bin ich fertig.", "start": 1874.0, "end": 1899.0}, {"text": " Das heisst, Furiertransformation der Groesse 2 N, was kostet die mich?  Ueberlegen wir es uns, vielleicht hier.  Mit diesem Trick von da drueben, was kostet die Furiertransformation?  Schreiben wir mal C fuer die Kosten der Furiertransformation der Groesse 2 N.  Die kostet auf den Ungrade-Elementen eine Furiertransformation der Groesse N  und auf den Grade-Elementen eine Furiertransformation der Groesse N.", "start": 1899.0, "end": 1930.0}, {"text": "  Also 2 mal die Kosten von Furiertransformation der Groesse N plus.  Das Umsortieren dieser Elemente kostet 2 N.  Das Multiplizieren mit der Diagonalmatrix kostet N, einmal hier, einmal da.  Das addieren dieser Elemente kostet N, eine kleine Konstante mal N.  Es ist nicht entscheidend fuer das Argument.  Hier nennen wir die kleine Konstante H.", "start": 1933.0, "end": 1970.0}, {"text": " Warum nicht?  Ich weiss, warum nicht, weil man es kaum von N unterscheiden kann.  Dann nennen wir sie, was war der Vorschlag?  Ein kleines K.  Ein kleines K mal N.  Gut.  Das ist jetzt eine Rekurenzgleichung, die einem bekannt vorkommen kann,  die man kennt aus der Algorithmik.  Da kann man jetzt schon schliessen, wer moechte, kann es sich so hinschreiben,  sagt, ich teile mal die Ns durch 2.", "start": 1970.0, "end": 2008.0}, {"text": "  Das ist dann hier N halbe plus eine kleine Konstante mal N.  Da wissen wir, dass es O von N lock N.  Ja, bitte.  Falls wir uns tatsaechlich Muehe geben wuerden und dieses K ausrechnen, dann ja.  Einmal geht dieser Teil der Graden auf die hier.  Und dann geht dieser Teil der Ungraden auf die hier.  Also es sind zwei Fourier-Transformationen der halben Groesse.", "start": 2008.0, "end": 2069.0}, {"text": "  Auch mit zwei unterschiedlichen Ergebnissen.  Genau.  Ja, und das Schoene ist, das funktioniert prima jetzt aus unserer Warte.  Bisher, also ich sage mal so bis zu Algorithmik und Datenstrukturen,  waren wir immer gluecklich, wenn wir N-Quadrat in N lock N umwandeln konnten.  Ein Grundverstaendnis aus dieser Veranstaltung sollte sein,  so schnell wie moeglich ist nicht immer so gut wie moeglich.", "start": 2069.0, "end": 2104.0}, {"text": "  Also zum Beispiel bei dem Gauss Algorithmus, der auch von Gauss ist,  aber nicht das, sondern das Ding zum Loesen von Lineal- and Gleichungssystemen,  haben wir gesehen, dass die zusaetzliche Aufwand eigentlich nicht sinnvoll vermieden werden kann.  Wir sollten auf jeden Fall die Elemente umordnen in der Matrix, das Pivoting,  um numerische Probleme zu vermeiden.", "start": 2104.0, "end": 2128.0}, {"text": "  Numeric ist ein wichtiges Argument an der Stelle und die zusaetzlichen Operationen sind notwendig.  Das ist sinnvoll, die zu investieren.  Hier ist alles gut.  Dieser Schritt von N-Quadrat nach N lock N buesst nichts ein, numerisch gesehen.  Der ist einfach nur schneller.  Gut, das ist die zentrale Botschaft.", "start": 2128.0, "end": 2158.0}, {"text": "  Was wunderschoen ist, in dieser Art und Weise laesst sich die schnelle Fourier-Transformation  rekursiv in ungefaehr vier Zeilen in Python implementieren.  Diese Elemente sind x von 0, 2,2, und diese Elemente hier sind 1,  2, 2, 2, in Python.", "start": 2158.0, "end": 2200.0}, {"text": " Wenn ich mir also eine Funktion definiere, die die FFT ausrechnet,  Dann ist mein erster Schritt, mir den Vektor und den Vektor zu holen  und einfach wieder in die Funktion reinzugeben.  Rekursion.  In der Praxis hoert man ab einer gewissen Groesse auf.", "start": 2200.0, "end": 2224.0}, {"text": " Also der einfachste Fall irgendwo aufzuhoeren ist, bei welcher Groesse,  bei welcher Matrixgroesse wird die Antwort trivial?  Noch trivialer als die vier.  Bei welcher Matrixgroesse muss ich gar nichts machen?  Wenn sie eins gross ist.  Wenn also N durch diesen Rekursionsprozess auf eins ist,  kann ich das, was die Funktion bekommt, einfach zurueckgeben.  Das ist die richtige Antwort.", "start": 2226.0, "end": 2245.0}, {"text": "  Denn ich muss mit einer Matrix multiplizieren, die nur Omega 0, 0 enthaelt  und das ist eins.  Aber klar, in der Praxis wuerde man vielleicht auch mit der 2x2 Matrix  einfach multiplizieren. Irgendwann wird es dann einfach.  Also in Python hole ich, das sind zwei Zeilen in den Python Code,  und dann kommt die Zeile, also ich rufe sozusagen meine Funktion  auf diesen Vektoren auf.", "start": 2245.0, "end": 2273.0}, {"text": "  Ich mache sowas wie def, fft von x, dann steht hier,  wir entwickeln jetzt hier Code gleich, dann steht also hier fft von  und hier steht auch fft von.  Und da muss ich nur noch dieses Produkt mit dieser Diagonalmatrix  implementieren.  Und das kann man eben Pythonic machen, wenn man sagt,  das Ding hier hinten ist ein Vektor, der heisst eben hier oben dieses Ding.", "start": 2274.0, "end": 2323.0}, {"text": "  So, plus x von 2 mal i mal p mal k durch n mal dieses Ding.  Und dann einfach 4k in range, irgendwas.  Und dann ist die fft fertig implementiert.  Wir haben es uns hier natuerlich ein bisschen leicht gemacht.  Ah, das ist eigentlich eine gute Frage, habe ich noch nie gestellt.", "start": 2323.0, "end": 2363.0}, {"text": " Das sieht jetzt furchtbar effizient aus,  aber was haben wir hier versteckt?  Das ist mal die allerwichtigste Einschraenkung, das meinte ich noch gar nicht mal.  Genau, wir haben eine fft implementiert fuer 2er-Potenzen.  Ist jetzt vielleicht, also wenn wir das auf dem Bild machen wollten  oder auf dem Musiksignal, koennte man sagen, das ist eine Einschraenkung.", "start": 2363.0, "end": 2392.0}, {"text": "  Das andere ist, wir haben hier Komplexitaet versteckt in diesen Operationen.  Das finde ich bei Python, was die Komplexitaet betrifft, oft haesslich.  Wir schreiben hier so einen einfachen Ausdruck hin  und Python macht im Hintergrund irgendwas.  Das ist ja keine Operation, die konstante Zeit braucht.  Sondern es ist eine Operation, die lineare Zeit braucht.", "start": 2392.0, "end": 2414.0}, {"text": "  Wir wissen eigentlich nicht genau, wie viel Zeit die braucht.  Aber gut, so, jetzt kommen wir noch zu folgendem.  Wir ueberlegen uns mal, was man tun muesste, wenn man das nicht rekursiv implementieren will.  Das ist naemlich ganz lustig.  Der entscheidende Teil, um sich zu ueberlegen, was man machen muss,  wenn man das nicht rekursiv implementieren will, ist, was passiert mit der Reihenfolge.", "start": 2414.0, "end": 2457.0}, {"text": "  Wenn ich diese ganzen Operationen hintereinander ausfuehren will,  dann muss ich immer diese Dinger hier umsortieren.  Ich sortiere die nicht nur einmal um, ich sortiere die im ersten Schritt um.  Dann bekomme ich hier umsortierte Dinger, die wende ich auf diese Teile in der Haldengroesse an.", "start": 2457.0, "end": 2481.0}, {"text": " Aber wenn ich jetzt Rekursionen mache, dann nehme ich wieder den Vektor  und fange an, den umsortieren und so weiter.  Jetzt kann man sich ueberlegen, wenn man sich das staendige umsortieren sparen will,  was da eigentlich passiert bei dieser Umsortierung.  Nehmen wir mal an, wir haben die Indices 1, 2, 3, 4, 5, 6, 7 und vielleicht noch 8.", "start": 2481.0, "end": 2516.0}, {"text": " Das ist das erste Schritt der Umsortierung, was macht das?  Wir haben vorne die, ich mache mal 0 basiert, oder?  Das ist irgendwie netter. Fangen wir mit der 0 an. Die 0 bleibt.  Dann kommt hier die 2, dann kommt die 4, dann bin ich 6.  Dann kommt die 1, dann kommt die 3, dann kommt die 5 und dann kommt die 7.  So, naechster Schritt. Jetzt machen wir was auf diesen Teilen.", "start": 2516.0, "end": 2554.0}, {"text": "  Jetzt muss man aufpassen, die Zahlen sehen natuerlich ein bisschen verwirrend aus.  Was wir jetzt natuerlich meinen ist, die naechste Fourier-Transformation bekommt diesen 4er-Vektor  und muss wieder die Umsortierung machen.  Bezogen auf die neuen Indices. Die neuen Indices sind ja 0, 1, 2, 3.  Wir haben da 0, 4, 2, 6, genau.  Und hinten 1, 5, 3, 7.  Okay.", "start": 2554.0, "end": 2607.0}, {"text": " Kann man den Muster irgendwas ansehen?  Ja.  Also 0 gleich gleich, 2 gleich gleich, 3 gleich, 7 gleich.  Ja.  Die 4 nach hinten geschoben, 6 nach hinten.  Ja, da kann man 6 nach hinten geschoben, die 6 nach hinten geschoben, die 3 nach hinten geschoben.  Okay. Bitte.  Ja, ist gut, wenn man naeher kann, die an der Stelle.  Wir schreiben uns das mal wie naeher hin.  Also hier steht 0, 0, 0.", "start": 2607.0, "end": 2646.0}, {"text": "  Hier steht 0, 0.  Also jetzt habe ich schon was vorweggenommen. Ich mache mal die 1 nach rechts hier.  Dann haben wir 0, 1, 0. 0, 1, 1.  1, 0, 0. 1, 0, 1.  1, 1, 0, 1, 1, 1.  So.  Jetzt schreiben wir die Dinger mal hier unten dran.  0, 0, 0. Die 4 war 1, 0, 0. Die 2 war, haben wir dann Fehler gemacht.  0, 1, 0. Nein. Die 6 ist 1, 1, 0.  Die 1 ist 0, 0, 1. Die 5.", "start": 2646.0, "end": 2698.0}, {"text": "  1, 0, 1. Die 3. 0, 1, 1. Und die 7. 1, 1, 1.  Ja, und was sieht man?  Wenn man jetzt diese Dinger hier vergleicht, die hier von oben nach unten, was haben wir getan?  Ja, wir haben die Reihenfolge der BITZ einfach umgedreht.  Ja, wenn ich diese Zahlen hier von hinten nach vorne lese, kommen die hier unten raus.  Aus 0, 0, 1 wird 1, 0, 0. Bei 0, 1, 0 aendert sich nichts, weil das symmetrisch ist.", "start": 2701.0, "end": 2741.0}, {"text": "  Aus 0, 1, 1 wurde 1, 1, 0. Die Reihenfolge der BITZ in diesen Indizes wurde vertauscht.  Das heisst, die richtige Operation, mit der wir die Indizierung sofort veraendern koennen,  ist in dem Index die Reihenfolge der BITZ zu veraendern.  Und deswegen heisst diese Operation auch auf Englisch BITRiversal.  Und diese Operation BITRiversal, die kann man auch linear implementieren.", "start": 2741.0, "end": 2781.0}, {"text": "  Also in linearer Zeit kann ich den Vektor so umsortieren,  dass die Indizes alle ihre BITR Reihenfolge vertauschen.", "start": 2781.0, "end": 2804.0}, {"text": " Und die Idee ist dann eben fuer die schnelle Furietransformation, ich mache das einmal am Anfang,  also ich mache alle Vertauschungen anstatt dass ich fuer den ersten Schritt eine Vertauschung mache,  dann Furietransformation, dann Wiedervertauschung mache, dann Furietransformation und so weiter.", "start": 2804.0, "end": 2818.0}, {"text": " Mache ich einmal am Anfang all diese Vertauschungen, das geht eben interessanterweise in O von N,  in N sogar, und dann arbeite ich diesen Algorithmus ab.  Und wenn ich die Sachen schon mal vertauscht habe, besteht einfach nur aus dem Zusammenfuegen von diesen kleineren Furietransformationen.  So, so einfach ist es eigentlich.", "start": 2818.0, "end": 2855.0}, {"text": " Was bleibt mir noch zu sagen dazu?  Das schon angesprochene Problem, dass wir das bisher nur fuer zwei Potenzen gemacht haben,  hat verschiedene Loesungen.  In vielen Faellen ist es ueblich bei den zweier Potenzen zu bleiben  und dann verschiedene Dinge zu tun, wenn man keine Zweier Potenz hat.", "start": 2856.0, "end": 2885.0}, {"text": " Wer hat Ideen, was man sinnvollerweise machen koennte, wenn man das mit einem Vektor zu tun hat,  der als Laenge keine Zweier Potenz hat.  Was koennten sinnvolle Dinge sein?  Man kann sich jetzt fuer die zweite Art und nur auf den Industrieiten halten,  und dann werden die Furietransformationen in der Langdauer von weiss ueberrechtet.", "start": 2885.0, "end": 2905.0}, {"text": "  Ja, das ist schon eine von den smarten Loesungen, auf die ich eigentlich spaeter kommen wollte.  Ich nehme den Faden mal auf und dann kommen wir zu dem Ding zurueck.  Die Frage ist, ob man allgemeiner diesen Trick, den wir hier gemacht haben, machen kann  und die Furietransformation nicht in zweimal zwei Bloecke aufteilt, sondern in n mal m Bloecke.", "start": 2905.0, "end": 2935.0}, {"text": "  Also ob es schnelle Furietransformationen fuer jede zusammengesetzte Laenge gibt.  Also ob ich jede Laenge nehmen kann und die in ihre Komponenten zerlegen,  also die Zahlen in ihre Faktoren zerlegen, in ihre Primfaktoren,  und gibt es dann eine Furietransformation, die eben ausnutzt,  dass die Zahl sich in Primfaktoren zerlegen laesst.  Und die Antwort ist ja.  Also das geht.", "start": 2935.0, "end": 2960.0}, {"text": "  Problem ist jetzt, jetzt habe ich also sagen wir mal,  einen Vektor, der als Laenge hat eine grosse Primzahl.  Dann bin ich sozusagen, dann laesst sich nichts holen einfach.  Was koennte ich jetzt tun?  Ja.  Also ich nehme das mal mit nullen auffuellen, ist eine Standardtechnik.  Also grundsaetzlich, ich mache den Vektor groesser bis zum naechsten Zweierpotenz  und ich muss ihn irgendwie auffuellen.", "start": 2960.0, "end": 3003.0}, {"text": "  Und die Frage ist, wie fuehle ich ihn auf?  Und null ist eine Technik, die man machen kann.  Es gibt aber in vielen Faellen eine plausiblerer Art und Weise, den aufzufuellen als mit null.  Ja, was koennte das sein?  Ja.  Also der Vorschlag ist, ich, das Signal hat irgendwo angefangen bei null  und ich packe das nochmal wieder dran.  Warum koennte das richtig sein?  Ja.", "start": 3003.0, "end": 3049.0}, {"text": "  Der Grundgedanke ist, wir haben es hier mit periodischen Signalen oft zu tun.  Und wenn das Signal periodisch ist, dann koennte es eben sinnvoll sein,  einfach zu sagen, was ich hier bekommen habe, ist die Periodenlaenge  und das Signal geht einfach so weiter.  Ja, es ist jetzt einfach abgeschnitten worden am Ende der Periode.", "start": 3049.0, "end": 3068.0}, {"text": " Ich fange sozusagen wieder bei null an, fuege das an  und ich mache das nicht.  Im Sinne der Periodizitaet aendere ich gar nichts an dem Signal.  Ich mache den Schritt nur, weil ich die Eigenschaft fuer eine schnellen Furiertransformation ausnutzen will.  Also wenn das Signal genau die Laenge des Signals, die Periodenlaenge ist,  dann ist es richtig, eigentlich den Anfang wieder dran zu setzen.", "start": 3068.0, "end": 3094.0}, {"text": "  Und dann macht mir die schnelle Furiertransformation in der groesseren Groesse auch nichts kaputt.  Das ist also eine andere Technik.  Aber wenn du es voll mit Perioden wieder dran haengst?  Naeaeaeaeh.  Wir koennen einfach so eine halbe Period machen.  Genau, also das sind die zwei Techniken, mit nullen oder eben die Periodizitaet ausnutzen.  Ich glaube an so, ja bitte.  Von wem ist der?  Ja.", "start": 3096.0, "end": 3196.0}, {"text": "  Also, verzeihend, aber das kann ich in der Groesse der Zeit jetzt nicht verifizieren im Kopf.  Wie wird es nennen?  Ich sage mal folgendes Allgemeines dazu, was glaube ich belastbar ist.  Es gibt tausend und eine Variante von diesen schnellen Furiertransformationen.  Das hier ist offensichtlich der Basisfall.", "start": 3196.0, "end": 3234.0}, {"text": " Und es gibt eine Reihe von Faellen, die auch vergleichsweise einfach sind,  zum Beispiel eben das Ganze in dreimal drei Bloecke aufzuteilen und und und.  Und es gibt sicher auch noch eine Menge Faelle, die raffinierter sind.  Ja, aber also ich glaube, ich kann das jetzt hier auf die Schnelle nicht einordnen.  Aber ich bestreite nicht die Existenz von anderen Klugenloesungen.", "start": 3234.0, "end": 3257.0}, {"text": "  Okay, gibt es weitere Fragen und Bemerkungen ansonsten? Ja.  Ja, oder was ist dann praktisch der Nutzen der Faelle erwarten?  Das ist ein signaler Laenders.  Der letzte Faelle kann man so einfach verruehren, aber nicht erhoben.  Ja.", "start": 3257.0, "end": 3279.0}, {"text": " Ich nehme an, man will vermutlich Furiertransformation machen,  und teile von der Weckhoerer rauskommen und verpraezitieren,  und ich wuerde eine Ausform von der Nivezurkampftrumpen.", "start": 3279.0, "end": 3298.0}, {"text": " Aber das Ergebnis von dem eigentlichen Signal,  ist der dann leicht, egal ob es in der Laedenruhe eigentlich kam oder ist es in einer kleinen Laede?  Das ist eine gute Bemerkung, weil das eben ein,  also ein, ich glaube, verbreitetes Missverstaendnis ausdrueckt.  Wenn wir einen Vektor der Laenge 7 haben,  dann ist es nicht egal, was wir als 8. Element einfuegen fuer unsere Furiertransformation.", "start": 3298.0, "end": 3310.0}, {"text": "  Ja, und nur wenn es das waere, wuerde es ja heissen,  dass wir bei der Ruecktransformation wieder das Gleiche bekommen.  Und es ist eben leider auch nicht egal,  bei der Ruecktransformation fuer die ersten 7 Elemente.  Also je nachdem, wenn wir sagen, wir machen einen Tiefpass,  wir wollen nur die tiefen Frequenzen,  dann ist es nicht egal, wie wir das 8.", "start": 3310.0, "end": 3332.0}, {"text": "Element auffuellen,  dafuer, was wir fuer die ersten 7 Elemente am Ende zurueckbekommen.  Und vielleicht kann man das schon gut sehen,  wenn wir uns vorstellen, dass dieses Produkt im Frequenzraum Faltung im Ortsraum waere.  Nehmen wir mal an, unsere Faltung ist,  Beispiel, wir haben einen Vektor,  1, 1, 1, und wir wollen den gerne Furiertransformieren.", "start": 3332.0, "end": 3365.0}, {"text": " Unsere Faltung im Ortsraum sieht so aus,  die hat so einen Kern, ein Halb, ein Halb.  Das ist unser Filterkern.  Das heisst, wir bekommen die neuen Elemente,  indem wir zwei Nachbarn nehmen, die jeweils mit einem Halb multiplizieren  und dann auffordieren.  Sehr dieser Vektor so aus, stuende hier eine 1,  dann waere das Ergebnis unserer Faltung offenbar 1, 1, 1, 1.", "start": 3365.0, "end": 3400.0}, {"text": " Stuende hier aber eine 0,  je nachdem, wie der Filter jetzt orientiert ist,  dann bekommen wir, nehmen wir mal an,  wir machen die zwei zum ersten Element, 1, die zwei zum naechsten Element,  1, die zwei zum dritten Element, ein Halb und ein Halb.  Und dann haben wir eben auch auf dem Ausschnitt,  der uns interessiert, unterschiedliche Ergebnisse.", "start": 3400.0, "end": 3446.0}, {"text": " Die Aussage ist allgemeiner,  dieses Auffuellen hat einen Einfluss.  Und nicht nur, und zwar auf die Elemente, die mich interessieren,  auf meinen urspruenglichen Vektor.  Ich veraendere diesen Vektor je nachdem, wie ich hier auffuelle.  Und mit 0 auffuellen ist was anderes, als mit 1 auffuellen.  Das ist die Aussage auch fuer den Teil, um den es mir geht.", "start": 3446.0, "end": 3472.0}, {"text": " Also es ist leider nicht egal,  sonst wuerde man immer mit 0 auffuellen und die Operationen sparen.  Okay, weitere Fragen?  Wenn nicht, dann sind wir wie angedeutet heute mit dem etwas kuerzeren Programm fertig.  Vielen Dank.", "start": 3473.0, "end": 3486.0}]}]