[{"lecture": "31624_97_course_video", "Timestamps": [{"text": "  Dieses Video gibt eine Einfuehrung zu Credit Algorithmen. Im vorigen Video wurde das Backtracking-Prinzip erlaeutert.  Ein wesentliches Merkmal von Backtracking ist, dass der gesamte Suchbaum der Teilloesung abgesucht wird.  Dies ist zweckdienlich, wenn an allen Blaettern des Baumes Loesungen stehen, die erzeugt werden sollen.", "start": 0.0, "end": 33.0}, {"text": "  Falls sich jedoch nur an wenigen Blaettern Loesungen befinden und eine einzige ausreicht, wuenscht man sich eine gezieltere Suche.  Im besten Fall sollte die Suche auf direkten Weg zur Loesung fuehren. Dies leisten Credit Algorithmen.  Es wird also bei jeder Entscheidung nur einmal eine Auswahl getroffen und nie ein Schritt rueckgaengig gemacht.", "start": 33.0, "end": 57.0}, {"text": "  Klar ist, dass dies schwierig zu realisieren ist. An den Knoten, an dem eine Entscheidung getroffen werden muss, hat man nur lokale Informationen.  Man kennt den aktuellen Zustand, den Weg dorthin und die Auswahlmoeglichkeiten fuer den naechsten Zug.  Aber die weiteren Auswirkungen koennen nicht direkt abgesehen werden.", "start": 57.0, "end": 76.0}, {"text": "  Da verwundert es nicht, dass es nur fuer wenige Probleme Credit Algorithmen gibt, die optimale Loesungen finden.  Gerade solche Algorithmen sind natuerlich besonders interessant, da Credit Algorithmen sehr effizient sind.  Bei Credit Algorithmen kommt jeder Auswahl eine besondere Bedeutung zu, da keine Auswahl spaeter wieder rueckgaengig gemacht wird.", "start": 76.0, "end": 99.0}, {"text": "  Damit das klappt, ist es oft wichtig, die Entscheidungen in der richtigen Reihenfolge abzuarbeiten. Dies wird an einem Beispiel demonstriert.  Bei der Intervallauswahl ist eine Menge von Zeitintervallen mit Anfangs- und Endzeitpunkt gegeben.  Von diesen Intervallen sollen moeglichst viele ausgewaehlt werden, die einen linearen Ablaufplan passen.", "start": 99.0, "end": 117.0}, {"text": "  Das heisst, die ausgewaehlten Intervalle duerfen sich nicht ueberlappen.  In diesem Beispiel koennen die drei Intervalle 2, 4 und 7 ausgewaehlt werden.  Die Aufgabe ist es nun, ein moeglichst effizientes Verfahren zu finden, das garantiert eine maximale Anzahl von passenden Intervallen selektiert.  Um ein greedy Verfahren zu formulieren, muessen wir zunaechst eine schrittweise Auswahl festlegen.", "start": 117.0, "end": 145.0}, {"text": "  Wir gehen die Intervalle der Reihe nach durch und entscheiden jeweils, ob das Intervall ausgewaehlt wird oder nicht.  Ein Intervall wird ausgewaehlt, falls es zu keinen schon gewaehlten Intervall in Konflikt steht, also zeitlich ueberlappt.  Damit es ein greedy Verfahren ist, darf keine getaetigte Auswahl wieder rueckgaengig gemacht werden.", "start": 145.0, "end": 162.0}, {"text": "  Es ist also entscheidend, in welcher Reihenfolge wir die Intervalle durchlaufen.  Wir werden vier unterschiedliche Sortierungen besprechen.  Sortierungen aufsteigend nach Anfangszeit, nach Endzeit, nach Intervalldauer und nach der Anzahl der Konflikte mit anderen Intervallen.  Nun ist die Frage, ob einer dieser Sortierungen zu einem greedy Verfahren fuehrt, das immer eine optimale Loesung findet.", "start": 162.0, "end": 194.0}, {"text": "  Zu drei der Sortierungen findet man leicht gegen Beispiele zur Optimalitaet.  Dort laeuft man die hier gezeigten Intervalle nach ihrer Anfangszeit, steht zunaechst das obere Intervall zur Auswahl.  Es wird ausgewaehlt und danach passt kein anderes mehr.  Es gibt aber eine andere Auswahl, die es auf drei Intervalle bringt.  Also ist die Strategie fruehester Start nicht optimal.", "start": 194.0, "end": 221.0}, {"text": "  Schauen wir uns das zweite Beispiel mit der Sortierung nach Intervalldauer an.  Zuerst steht das oberste Intervall zur Auswahl und dann das zweite oberste.  Sie werden beide selektiert, aber eine bessere Wahl ist es, die unteren drei zu selektieren.  Also ist auch die Strategie kuerzestes Intervall nicht optimal.  Etwas komplexer ist das Gegenbeispiel fuer die Strategie wenigste Konflikte.", "start": 221.0, "end": 248.0}, {"text": "  Notieren wir zunaechst fuer jedes Intervall mit wie vielen anderen Intervallen es ueberlappt.  Die Strategie wenigste Konflikte waehlt zunaechst das oberste Intervall, das einzige, welches nur zwei Konflikte hat.  Danach gibt es sechs Kandidaten mit drei Konflikten.  Von ihnen passen allerdings nur noch zwei der aeusseren Intervalle.", "start": 248.0, "end": 271.0}, {"text": "  Sind also insgesamt drei, waehrend es die optimale Auswahl auf vier Intervalle bringt.  Es bleibt nur noch eine der Sortierungen im Rennen.  Und in der Tat liefert die Sortierung nach Endzeitpunkt einen optimalen Polyalborithmus.  Der Beweis der Optimalitaet steht im Skript.  Dabei wird eine gegebene Loesung der Strategie fruehestens Ende mit einer optimalen Loesung verglichen.", "start": 272.0, "end": 296.0}, {"text": "  Durch eine Induktion ueber die ausgewaehlten Intervalle kann man zeigen,  dass der Endzeitpunkt des Kartenintervalls fuer die Loesung der Strategie fruehestens Ende nie spaeter liegt,  als der Endzeitpunkt des Kartenintervalls der optimalen Loesung.", "start": 296.0, "end": 316.0}, {"text": "  Und auf diese Weise gelangt man zu dem Ergebnis, dass die Auswahl der Strategie fruehestens Ende genauso viel Intervalle gewaehlt hat wie die optimale Loesung.  Und somit auch eine optimale Loesung darstellt.  Die Laufzeit dieses Algorithmus liegt in O von N log N.", "start": 316.0, "end": 335.0}, {"text": " Daran sieht man, dass ein greedy Algorithmus nicht unbedingt eine lineare Laufzeit haben muss,  obwohl der Verlauf im Suchbaum linear ist.  In diesem Fall liegt es daran, dass das Sortierte durchlaufen,  der Intervalle einen Zeitbedarf von O von N log N hat.  Fassen wir die Elemente des greedy Algorithmus zusammen.", "start": 335.0, "end": 358.0}, {"text": " Zunaechst muss, wie beim Backtracking ueberlegt werden,  durch welchen schrittweisen Prozess Loesungen fuer ein gegebenes Problem erzeugt werden koennen.  Fuer ein greedy Verfahren kommt hinzu, dass die Reihenfolge, in der die Entscheidungen durchlaufen werden, entscheidend sein kann.", "start": 358.0, "end": 373.0}, {"text": "  In dem Beispiel der Intervallausfall fuehrte nur eine, die viel besprochenen Sortierungen zu einem erfolgreichen greedy Verfahren.  In dem Skript werden noch andere recht aehnliche Probleme besprochen,  bei denen jeweils eine andere Sortierung zum Erfolg fuehrt.  Fuer die Implementierung folgen dann die Elemente.  Erstens, einen Kandidaten fuer den naechsten Schritt auswaehlen.", "start": 373.0, "end": 391.0}, {"text": "  Zweitens, einen Schritt ausfuehren.  Und drittens, erkennen, ob eine Loesung erreicht wurde.  In dem Beispiel der Intervallauswahl war die Sortierung bzw. die Reihenfolge der Knackpunkt.  Und der Auswahlschritt? Einfach.  Ein Intervall wurde ausgewaehlt, wenn es zu den bisher ausgewaehlten Intervallen passt.", "start": 391.0, "end": 417.0}, {"text": "  Es gibt auch andere Probleme, bei denen die Sortierung nicht wichtig ist bzw. die Sortierung durch das Problem vorgegeben ist.  In diesen Problemen ist oft der Aspekt der Auswahl der schwierige Punkt.  Greedy Algorithmen sind fuer die Praxis aeusserst interessant,  weil sie meist sehr effizient und einfach zu implementieren sind.", "start": 417.0, "end": 437.0}, {"text": "  Fuer Theoretiker sind sie zum Teil weniger erfreulich, da die Optimalitaetsbeweise oft umstaendlich sind.  Fuer die Praktiker ist das Problem bei den greedy Verfahren, dass es sie fuer viele Probleme nicht gibt.  Zumindest keine, die garantiert eine optimale Loesung finden.  Allerdings koennen auch solche Verfahren, die nur suboptimale Loesungen liefern, fuer die Praxis wichtig sein.", "start": 438.0, "end": 463.0}, {"text": "  Sie koennen als Teilelemente von komplexeren Verfahren einen Beitrag zur effizienten, optimalen Loesung liefern.", "start": null, "end": 463.0}]}]