[{"lecture": "31624_52_course_video", "Timestamps": [{"text": "  Wir beschaeftigen uns nun mit der ersten Aufgabe. Dazu erstellen wir zunaechst eine  Klasse namens Aufgabe 1. Die Aufgabe betrachtet das Tucson-Problem. Darin sind ein Array und  eine Zahl K gegeben, beide vom Typ Int. Wir werden jetzt eine Methode schreiben, welche  prueft, ob sich zwei Zahlen aus dem Array zu K addieren lassen.", "start": 0.0, "end": 27.92}, {"text": "Um uns einmal die Rahmenbedingungen  klarzumachen, fangen wir mit der Main-Methode an. In Ideas reicht es aus, zum erstellen  der Main, die Anfangsbuchstaben als Shortcut zu tippen, PSVM, Public Settic Void Main. In  der Main legen wir zunaechst ein K-Fest, zum Beispiel drei. Dann ueberlegen wir uns zwei  Beispiel-Ares.", "start": 27.92, "end": 52.52}, {"text": "Test 1, gleich 0, 1, 2, 3, 4 und test 2, den ich hier beispielhaft mit  dem New-Operator initialisiere und dann ueber eine Vorschleife mit 1 fuelle. Jetzt koennen  wir uns einmal ueberlegen, welches Ergebnis wir von unseren Test-Ares erwarten wuerden.  Im ersten addieren sich 0 und 3 und 1 und 2 zu 3.", "start": 52.52, "end": 67.4}, {"text": "Wir erwarten also True als Loesung  des Tucson-Problems. Im zweiten erwarten wir False, weil 1 und 1 nicht 3 ergibt.  Zur Loesung des Tucson-Problems schreiben wir gleich eine Methode Sum to Target. Um die  Methode dann zu testen, kann man sie einfach in der Main aufrufen.", "start": 67.4, "end": 87.24}, {"text": "Da wir die Methode aber  noch nicht geschrieben haben, erscheint sie hier rot als Fehler, auch zu erkennen an  dem kleinen roten Strich an der Seite. Das muessen wir jetzt also nachholen. Wir uebergeben  int k, also unsere Zahl k und den array, um den es geht, als Parameter und wollen ein  Boolean zurueckgeben.", "start": 87.24, "end": 103.76}, {"text": "Wir fuegen erstmal als default false als Rueckgabewert ein, damit  die Methode kompiliert und ueberlegen uns dann gleich, wann wir True zurueckgeben muessen.  Wir fangen mit der Aufgabe 1.2 an, dem BruteForce Ansatz. BruteForce heisst einfach, alle Moeglichkeiten  durchzuprobieren. Dazu brauchen wir erst einmal zwei Vorschleifen.", "start": 103.76, "end": 121.4}, {"text": "Wir wollen fuer  jeden Index den Wert des Areas an dieser Stelle mit jedem Wert an einem anderen Index  addieren und pruefen, was da herauskommt. Dazu schliessen wir aus, dass i gleich j.", "start": 121.4, "end": 146.12}, {"text": " Wenn dann die Summe der beiden Werte in dem array, also area an der Stelle i plus area  an der Stelle j, gleich k, dann geben wir dieses Ergebnis einmal aus zur Kontrolle und True  zurueck. So wie wir das jetzt aufgeschrieben haben, berechnen wir aber jede Summe doppelt.", "start": 146.12, "end": 156.92000000000002}, {"text": " Fuer den Index 0 berechnen wir die Summe an der Nullten und der ersten Stelle und fuer  den Index 1 berechnen wir nochmal die Summe an der ersten und der Nullten Stelle, da die  Addition aber komutativ ist, berechnen wir de facto die gleiche Summe zweimal, weil  unsere zweite Schleife auch bei Null anfaengt.", "start": 156.92000000000002, "end": 172.56}, {"text": "Das ist selbst fuer den BruteForce Ansatz  ueberfluessig. Wenn wir also die zweite Schleife einfach bei i plus 1 beginnen lassen, brauchen  wir die erste Illfabfrage nicht mehr und berechnen dann jede Summe nur einmal. Wenn  man sich das als Matrix vorstellt, berechnen wir nur die obere Dreiecksmatrix, weil die  Ergebnismatrix symmetrisch ist. Schauen wir mal, ob das alles soweit stimmt.", "start": 172.56, "end": 190.96}, {"text": "Wenn wir  die Main ausfuehren, gibt die Methode korrekterweise 3 plus 0 gleich 3 aus fuer den ersten array.  Dann testen wir noch den zweiten Test-Ary. Das ist auch, wie wir es erwarten wuerden.  Wir koennen jetzt also unseren Ansatz etwas verfeinern und schreiben eine zweite Methode  Summe to Target. In dieser Methode wollen wir nicht einfach alle Moeglichkeiten ausprobieren.", "start": 190.96, "end": 211.4}, {"text": "  Da die Methode aber die gleichen Parameter und den gleichen Rueckgabewert hat, braucht  sie einen neuen Namen, sonst ist die Methode nicht zuortbar und wir bekommen einen Fehler.  Zum Optimieren der Methode nutzen wir, dass wir den Array sortieren koennen, um uns klarzumachen,  warum das hilft, hier ein kleines Beispiel. Nehmen wir den Array 1, 4, 2 und 3, 5.", "start": 211.4, "end": 232.8}, {"text": "Sortiert  waere das 1, 2, 3, 4, 5. Wenn wir jetzt vorne und hinten gleichzeitig anfangen und diese  beiden Werte addieren, gibt uns die Summe eine Information. Hier 1 plus 5 gleich 6 und 6  ist groesser als 3. Die 5 ist also zu gross und wir verringern den letzten Index um 1 und  lassen damit die groesste Zahl weg. Dann haben wir 1 plus 4 ist immer noch groesser als 3.", "start": 232.8, "end": 257.28}, {"text": "  Das wiederholen wir so lange, bis wir ueber 1 plus 2 gleich 3 ankommen. Wenn die Summe kleiner  ist als 3, lassen wir entsprechend die kleinste Zahl weg. Zum Implementieren sortieren wir  zuerst den Array mit Arrays.sort. Dann legen wir die Indizes fest, deren Werte addiert werden  sollen. E gleich 0 fuer den Anfang und j gleich Array.length minus 1 fuer das Ende.", "start": 257.28, "end": 280.03999999999996}, {"text": "Dann wollen  wir unsere Schritte so lange wiederholen, wie sich i und j nicht treffen. Also while  i kleiner j. Wir verfahren wie in dem Beispiel. Erst berechnen wir die Summe und dann gehen  wir die verschiedenen Faelle durch. Wenn die Summe gleich k ist, sind wir fertig. Dann  gehen wir das gleiche aus wie vorhin und true zurueck.", "start": 280.03999999999996, "end": 300.47999999999996}, {"text": "Wenn die Summe groesser ist als k,  verringern wir den letzten Index und lassen damit die letzte Zahl weg. Das ist die groesste  Zahl. Sonst erhoehen wir den Anfangsindex um 1. Das wiederholen wir so lange, bis wir  entweder true zurueckgegeben haben oder am Ende false zurueckgeben. Dann testen wir, ob unsere  optimierte Methode funktioniert und das tut sie.", "start": 300.48, "end": 322.20000000000005}, {"text": "Zu guter Letzt schauen wir uns noch die  Laufzeiten an. Fuer den bruteforce Ansatz brauchen wir zwei Vorschleifen.", "start": 322.20000000000005, "end": 339.0}, {"text": "Es ist zwar nur die  obere Dreiecksmatrix, die wir betrachten, also 1 halb n\u00b2, wobei n die Laenge des Arrays ist,  aber in der Laufzeiteinalyse werden Konstanten generell weggelassen, also verbleiben wir  mit einer Laufzeit von n\u00b2. Fuer das Sortieren ist die Laufzeit vom Sortialgorithmus abhaengig.  Arrays.zort hat eine Laufzeit von n log n.", "start": 339.0, "end": 349.44}, {"text": "Da wir Konstanten weggelassen und die  Wildschleife den Array maximal einmal durchlaeuft, ist das auch die Laufzeit der Methode. Wir sind  also in der Tat schneller geworden.", "start": 349.44, "end": 350.76}]}]