[{"lecture": "31624_23_course_video", "Timestamps": [{"text": "  In diesem Video werden wir uns mit dem Thema Grafen beschaeftigen.  In unserem Alltag gibt es viele Dinge, die sich durch Enggrafen darstellen lassen.  Hier habe ich einmal zwei Beispiele.  Zum einen das S-Bahn-Netz von Berlin, zum anderen das Fluessenetz in Deutschland.  Es gibt allerdings noch unzaehlige andere Beispiele, die sich durch Enggrafen repraesentieren lassen.", "start": 0.0, "end": 29.6}, {"text": "  Vor allem fuer uns Informatiker sind Grafen interessant, um solche Strukturen wie das  S-Bahn-Netz oder das Fluessenetz soweit zu vereinfachen, dass wir algorithmisch Probleme  darauf loesen koennen.  Dabei besteht ein Graf aus zwei wichtigen Komponenten.  Zum einen die Knoten des Grafen und zum anderen die Kanten des Grafen.", "start": 29.6, "end": 49.56}, {"text": "  Das Ganze schauen wir uns hier einmal an einem Ausschnitt vom U-Bahn-Netz von Berlin an.  Wenn wir diesen Ausschnitt als Grafen darstellen wollen, dann koennen wir beispielsweise jede  Station als ein Knoten des Grafen repraesentieren und die Verbindung zwischen den Stationen  als Kanten des Grafen.  Wir erhalten also dadurch dieses vereinfachte Modell.", "start": 49.56, "end": 71.52}, {"text": "  Hier haben wir jetzt lediglich die Information wie die folgenden Stationen, also die Knoten  heissen und welche Stationen, also welche Knoten ueber Kanten miteinander verbunden sind.  Je nach Problem, was wir loesen wollen, ist diese Repraesentation schon ausreichend.  Nun muessen wir uns weiterhin ueberlegen, wie wir einem Programm einen solchen Grafen  als Input geben koennen.", "start": 71.52, "end": 93.76}, {"text": "  Eine Moeglichkeit hierzu ist die sogenannte Adiazenzmatrix.  Hier steht in jeder Zeile und in jeder Spalte jeweils alle Knoten und innerhalb der Matrix  wird damit eine 1 oder eine 0 gekennzeichnet, ob diese Knoten miteinander verbunden sind  oder nicht.  Auf der Diagonalen sehen wir, dass logischerweise jeder Knoten mit sich selber verbunden ist,  deswegen steht dort eine 1.", "start": 93.76, "end": 118.96}, {"text": "  Und nun koennen wir zum Beispiel gucken, mit welchen Stationen der Zoo verbunden ist.  Das sind der Kudam und der Wittenbergplatz.  Der Zoo ist allerdings nicht direkt verbunden mit der Augsburger Strasse und der Spichernstrasse.  Eine weitere Moeglichkeit, einem Programm einen solchen Grafen zu uebergeben, ist, indem  man einfach die Knotenpaare uebergibt, also die Kanten des Grafen.", "start": 118.96, "end": 142.08}, {"text": "  Der Zoo ist beispielsweise mit dem Kudam und dem Wittenbergplatz verbunden, das heisst  ich uebergebe diese beiden Kanten.  Der Kudam ist mit dem Zoo, dem Wittenbergplatz und der Spichernstrasse verbunden, das heisst  ich uebergebe diese Kanten.  Und das Ganze mache ich fuer alle Kanten des Grafen.", "start": 142.08, "end": 168.64}, {"text": " Aus diesen Informationen kann ich dann genauso wie bei der Adiazenzmatrix herleiten, welche  Knoten mit welchen anderen Knoten verbunden sind.  Das Ganze kann ich noch etwas strukturierter machen, indem ich die Kanten fuer jeden Knoten  angebe.  Hier gebe ich zum Beispiel zuerst alle Kanten an, die vom Zoo ausgehen, dann alle Kanten,  die vom Kudam ausgehen und so weiter und so fort.", "start": 170.79999999999998, "end": 192.48}, {"text": "  Erstelle ich dann innerhalb meines Programms den Grafen, kann ich zuerst die Knoten hinzufuegen  und anschliessend die Kanten.  Nachdem wir uns nun angeschaut haben, wie wir unseren Programm unseren Grafen uebergeben  koennen in einer gewissen Darstellung, schauen wir uns noch an, wie wir den Grafen innerhalb  unseres Programms speichern koennen.", "start": 192.48, "end": 211.84}, {"text": "  Eine Moeglichkeit ist es, Knoten und Kanten als Klassen zu implementieren.  Hierbei ist es wichtig, Knoten eindeutig voneinander unterscheiden zu koennen und fuer  jede Kante dann zu speichern, welche beiden Knoten verbunden sind.  Das fuehrt dann zu einer sehr anschaulichen Darstellung.  Fuer jeden Knoten muessten wir dann lediglich alle ausgehenden Kanten speichern.", "start": 212.95999999999998, "end": 235.04000000000002}, {"text": "  Gegebenenfalls koennen wir dann natuerlich noch weitere Informationen zu den Knoten und  den Kanten speichern, wie beispielsweise den Stationsnamen fuer die Knoten in unserem Beispiel.  Eine weitere Moeglichkeit ist es, den Grafen selbst als Adjazenzmatrix zu speichern.", "start": 235.04000000000002, "end": 257.92}, {"text": " Hierbei belaeuft sich der Speicherbedarf auf v\u00b2 fuer v Knoten, da die Anzahl der Zeilen  und die Anzahl der Spalten unserer Matrix genau der Anzahl der Knoten entspricht.  Um nun zu ueberpruefen, ob zwei Knoten miteinander verbunden sind, also Adjazent sind,  benoetigen wir lediglich eine konstante Laufzeit.", "start": 259.28, "end": 275.76}, {"text": " Wir muessen naemlich hier lediglich den richtigen Index der Matrix ueberpruefen  und gucken, ob dieser entweder 0 oder 1 ist.  Wenn dieser 0 ist, sind die Knoten nicht Adjazent.  Wenn dieser Eintrag 1 ist, dann sind die Knoten Adjazent.  Um nun zu ueberpruefen, welche Nachbarknoten ein Knoten hat, benoetigen wir eine Laufzeit von v,  wobei v die Anzahl der Knoten ist.", "start": 276.32, "end": 296.96}, {"text": "  Das liegt daran, dass wir fuer jeden Knoten die entsprechende Zeile der Matrix durchgehen  muessten und fuer jeden Eintrag dann ueberpruefen, ob dieser 0 oder 1 ist.  Da wir in diesem Fall immer ueber alle Nachbarknoten in der Matrix iterieren,  bietet sich der Adjazenzmatrix an, wenn wir einen sehr dicht verknuepften statischen Grafen haben.", "start": 296.96, "end": 320.32}, {"text": "  Alternativ zu Adjazenzmatrix koennen wir fuer jeden Knoten eine Adjazenzliste speichern.  Das bedeutet, wir speichern fuer jeden Knoten in einer Liste alle seine Nachbarknoten.  Fuer diese Art von Implementierung haben wir ein Speicherbedarf von v plus e,  wobei v wieder der Anzahl der Knoten und e die Anzahl der Kanten im Grafen ist.", "start": 321.52, "end": 342.4}, {"text": "  Die Laufzeit, um zu pruefen, ob zwei Knoten Adjazent, also Nachbarknoten, sind,  betraegt dann grad von v. Das heisst, die Laufzeit entspricht der Laenge der Adjazenzliste  fuer diesen bestimmten Knoten. Moechten wir also ueberpruefen, ob w ein Nachbarknoten von klein v ist,  dann muessen wir im Worst Case-Szenario die gesamte Liste seiner Nachbarknoten durchgehen.", "start": 342.4, "end": 365.76}, {"text": "  Genau das ist auch der Ansatz, um ueber alle Nachbarknoten zu iterieren.  Hier gehen wir auch wieder von Knoten klein v, die gesamte Adjazenzliste durch  und wissen so, mit welchen Knoten dieser Knoten benachboert ist.  Da die Laufzeit hier sehr stark von der Anzahl der Kanten bzw.", "start": 366.56, "end": 387.28}, {"text": "Anzahl der Nachbarknoten von  jedem Knoten abhaengt, ist die Laufzeit hier besser, je weniger Kanten wir am Grafen haben.  Deshalb bieten sich Adjazenzlisten fuer duenne statische Grafen an, also mit sehr wenig Kanten.  Nun gibt es noch zwei Moeglichkeiten, die Adjazenzlisten zu implementieren.  Zum einen gibt es die sogenannten Iterables.", "start": 388.15999999999997, "end": 410.08000000000004}, {"text": "Iterables sind ein Datentyp,  fuer diesen lediglich die Minimalfunktion implementiert werden.  Mit Minimalfunktion meine ich, dass wir mehrere Elemente in diesem Datentyp speichern koennen  und ueber diese iterieren koennen. Da hier so wenig Funktionalitaet implementiert ist,  ist dieser Datentyp effizienter als andere.", "start": 410.08000000000004, "end": 432.15999999999997}, {"text": "Das Problem, was das Ganze mit sich bringt,  ist, dass hier die Collections-Methoden nicht nutzbar sind, wie allerdings zum Beispiel in einer Linklist.  Diese ist zwar nicht so effizient, allerdings lassen sich hier Collections-Methoden nutzen,  wie zum Beispiel auf bestimmte Indizes zugreifen oder die Reihenfolge der Liste zu schaffeln.", "start": 433.28, "end": 450.8}, {"text": "  Eine letzte Moeglichkeit der Implementierung von Grafen, die ich heute vorstellen moechte,  sind die doppeltverketteten Pfeillisten oder am englischen Double-Connected-Aerolists.  Hier werden alle Knoten in einer doppeltverketteten Liste gespeichert.", "start": 450.8, "end": 473.28000000000003}, {"text": " Jeder Eintrag dieser doppeltverketteten Liste, also jeder Knoten, enthaelt dann selbst noch einmal  eine doppeltverkettete Pfeilliste. Jeder Eintrag dieser Pfeilliste zeigt dann auf ein Nachbarknoten.  Das bedeutet, ich habe alle Knoten einer doppeltverketteten Liste gespeichert  und fuer jeden Knoten eine weitere Liste, in der Zeiger auf die Nachbarknoten gespeichert sind.", "start": 474.32, "end": 492.0}, {"text": "  Der Vorteil hier ist, dass die Datenstruktur dynamisch ist und somit flexibel geaendert  werden kann. Es bietet sich also an, doppeltverkettete Pfeillisten zu benutzen, wenn wir ein dynamischen  Grafen haben, der sich also waehrend der Laufzeit des Programms stetig aendert.", "start": 492.0, "end": 514.72}, {"text": " Nun hat er so einen kurzen Ueberblick bekommen, was Grafengenere sind, in welcher Form wir Grafen  einem Programm uebergeben koennen und in welcher Datenstruktur wir Grafen innerhalb unseres Programms  speichern koennen. Im naechsten Video schauen wir uns dann mit der breiten und tiefen Suche die  ersten Algorithmen auf Grafen an.", "start": 514.72, "end": 522.32}]}]