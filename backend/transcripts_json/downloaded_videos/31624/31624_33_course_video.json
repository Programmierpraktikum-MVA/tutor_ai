[{"lecture": "31624_33_course_video", "Timestamps": [{"text": "  Hallo, fuer mich ist die dynamische Programmierung einer der coolsten, ich bin versucht zu sagen,  Tricks, den die Informatik so bisher hervorgebracht hat.  Deswegen mache ich dieses Video.", "start": 0.0, "end": 35.879999999999995}, {"text": " Es ist einfach unglaublich, dass wir mit der dynamischen Programmierung ein Algorithmus  entwickeln koennen fuer ein Problem, das eigentlich irgendwie exponentiell ist und das Ganze in  einem polnominiellen Algorithmus umwandeln.  Das geht natuerlich nicht fuer alle Probleme, aber es geht fuer eine ganze Reihe von Problemen  und das ist wirklich verrueckt.", "start": 35.879999999999995, "end": 49.480000000000004}, {"text": "  Also exponentiell bedeutet im Grunde genommen kann man das Problem nicht loesen, ausser  fuer ganz, ganz kleine Inputs fuer triviale Probleme.  Und polnominiell, quadratisch, kubisch, ist der sehr praktisch loesbar, auch fuer grosse,  relativ grosse Enden.  Und das ist im Grunde genommen, also Magie, wenn man nicht versteht, worum es geht.", "start": 49.480000000000004, "end": 76.88}, {"text": "  Ich moechte in diesem Video ein Beispiel fuer eine Anwendung geben und ganz kurz das Prinzip  erklaeren, aber ihr habt dann noch andere Videos, in denen ihr dynamische Programmierung im  Kontext von allen moeglichen anderen Problemen lernt, aber hier erstmal so ein bisschen Ueberblick.", "start": 76.88, "end": 99.56}, {"text": " Dynamische Programmierung heisst, es ist ein komischer Name eigentlich, weil es hat mit  Dynamik und mit Programmierung eigentlich nicht so viel zu tun, aber das ist nun mal  der Name.  Die Idee ist, dass wir eine Berechnung haben, die wir in so einer Baumstruktur darstellen  koennen.", "start": 99.56, "end": 122.48}, {"text": " Wir koennen euch das als Rekursion vorstellen, also die Berechnung hier in der ersten kleinen  Kugel ruft die Berechnung hier und hier auf, die wiederum ruft Rekursiv-Ande-Berechnung  auf und so weiter.", "start": 122.48, "end": 144.6}, {"text": " Wenn wir nun in der Situation sind, dass in diesem Berechnungsbau wiederkehrende Teilprobleme  sind, das heisst, dass gleiche Problem mehrfach berechnet werden muss, wie hier angezeigt  durch diese gruenen Punkte, also das ist jedes Mal genau die gleiche Unterberechnung,  dann haben wir einen ziemlich guten Hinweis darauf, dass man Dynamische Programmierung  anwenden kann.", "start": 144.6, "end": 157.2}, {"text": " Was brauchen wir?  Als erstes brauchen wir wiederkehrende Unterprobleme, weil das reicht nicht.  Als zweites brauchen wir auch noch, das Problem muss teilbar sein und dann, das ist wichtig,  die Loesung muss aus diesen Teilloesungen wieder zusammensetzbar sein.", "start": 157.2, "end": 182.4}, {"text": " Also das heisst, wir berechnen auf der einen Seite auf dem Weg nach unten alle moeglichen  verschiedenen Teilloesungen, aber die Teilloesungen werden dann auch auf dem Weg zurueck nach oben  wieder zur Gesamtloesung zusammengesetzt.", "start": 182.4, "end": 196.35999999999999}, {"text": " Das ist nicht bei allen Problemen so, aber wenn das der Fall ist, dann haben wir schon  mal zwei Anforderungen erfuellt, die notwendig sind, damit wir die Dynamische Programmierung  anwenden koennen.  Jetzt kommt die dritte und die ist sozusagen die Ausschlaggebende.  Wir brauchen etwas, das heisst optimale Unterstruktur.", "start": 196.35999999999999, "end": 215.28}, {"text": "  Wenn wir also dieses gruene Problem hier loesen, aneinander eine Loesung haben, das heisst,  wir haben im Grunde genommen nicht das Gesamtproblem geloest, sondern nur ein kleines Unterproblem  und wir haben hier eine Loesung.  Dann muessen wir davon ausgehen koennen, dass die richtige Loesung fuer dieses Unterproblem  auch Teil der richtigen oder der optimalen Loesung fuer das Gesamtproblem.", "start": 215.28, "end": 238.4}, {"text": "  Also diese Loesung hier ist dann die Gesamtloesung.  Das heisst, wir brauchen die Eigenschaft des Problems, dass wenn wir das Problem zerteilt  haben und die unter Probleme optimal loesen, also hier haben wir optimale Loesung, dass  dann auch diese optimale Loesung des Teilproblems ein Teil der optimalen Gesamtloesung ist.", "start": 238.4, "end": 275.04}, {"text": "  Denn es koennte ja sein, dass dadurch, dass ich diese Loesung hier mit anderen Komponenten  wieder zusammentuhe, dass ich Interaktionen zwischen diesen verschiedenen Komponenten  ergeben, die die lokal berechnete optimale Loesung gar nicht optimal mehr sein lassen.  Das ist aber aufgrund von dieser Eigenschaft optimale Unterstruktur auszuschliessen.", "start": 275.04, "end": 301.40000000000003}, {"text": "  Wie genau das definiert ist, das seht ihr im Skript und in der auffolgenden Videos, aber  es leuchtet erst mal ein, dass ich ein Problem zerteile und die Unterprobleme, in die ich  zerteile, sich wiederholen und ich gleichzeitig sich erstellen kann, dass die optimale Loesung  eines Unterproblems auch immer wieder die gleiche Loesung ist.  Das garantiert uns diese optimale Unterstruktur.", "start": 301.4, "end": 328.71999999999997}, {"text": "  Was sonst hilft es mir nicht, dass ich wiederkehrende Probleme habe, wenn die in dem Kontext, in  dem sie ausgerechnet werden, jedes Mal eine andere Loesung mehr liefern.  Aber wenn diese drei Eigenschaften gegeben sind, dann koennen wir dynamische Programmierung  anwenden.", "start": 328.72, "end": 354.64000000000004}, {"text": " Nun ist es ganz wichtig zu wissen, dass dynamische Programmierung nicht tatsaechlich ein Algorithmus  ist wie Quick Sort oder so, sondern dynamische Programmierung ist eine Problemloesungsstrategie,  die man verwenden kann, um einen Algorithmus zu erstellen.", "start": 354.64, "end": 370.88}, {"text": " Man kann nicht einfach sagen, ich habe hier eine Methode, die heisst dynamische Programmierung  und die wende ich auf ein Problem an, sondern man muss immer eine dynamische Programmierungsmethode  spezifisch fuer ein gegebenes Problem schreiben.  Es ist also eine Loesungsschablone, aber keine Loesung an sich.", "start": 370.88, "end": 388.48}, {"text": "  Und zu dieser Loesungsschablone gehoert immer, dass man in irgendeiner Weise diese wiederkehrenden,  zusammenbaubaren, optimalen Unterloesung sich abspeichert.  Und das passiert in einer Art Tabelle, wo nehmen wir mal an, hier der Eintrag hier ist also  die Loesung IJ, I gleich 2 und J gleich 3.", "start": 388.48, "end": 425.12}, {"text": " Und was immer ich hier speichere als die Loesung dieses Unterproblems, das kann ich immer wieder  abrufen, muss es nicht mehrfach berechnen und kann mir dabei, weil der Suchbaum exponentiell  ist und deswegen, wenn ich eine exponentielle Wiederholung von diesen Unterproblemen habe,  ich mir die exponentiell oft sparen kann, kann ich von etwas exponentiellen in etwas  polynomiales geben.", "start": 425.12, "end": 444.88}, {"text": "  Zum Beispiel, wenn ich jetzt, wenn meine Tabelle, in der ich mir die Zwischenergebnisse speichere,  sowas ist wie hier, dann kann ich sofort sehen, aha, das ist zum Beispiel, sagen wir mal,  also der Belli hat ja Order von n Quadrat viele Elemente und wenn ich zum Ausrechnen eines  Elements eine konstante Zeit berechne, dann habe ich ein Algorithmus, der Order n Quadrat  ist.", "start": 444.88, "end": 469.96}, {"text": "  Und das ist natuerlich viel besser als so ein exponentieller Suchbaum.  So, das ist natuerlich jetzt sehr schemenhaft, die Beschreibung davon, wie dynamische Programmierung  funktioniert.", "start": 469.96, "end": 501.28000000000003}, {"text": " Es gibt unglaublich viele Variationen davon, fuer jedes Problem gibt es eine neue Variation,  manchmal muss man die gesamte Tabelle ausfuellen, manchmal reicht es einfach nur die obere  Diagonale, also die obere, die obere Dreieck auszurechnen, manchmal reicht es, die obere  Dreieck auszurechnen, das haengt jeweils von der spezifischen Formulierung des Problems  ab.", "start": 501.28000000000003, "end": 512.88}, {"text": "  Aber was gemeinsam ist, ist, wir haben eine Tabelle, in der wir diese Zwischenergebnisse  abspeichern, die ist meist zweitdimensional, kann aber auch hoeher dimensional sein, wir  haben ein Berechnungsbaum, der wiederkehrende Unterprobleme hat und die sind nicht nur wiederkehrend,  die sind auch noch zusammenbaubar und die sind optimal in der Unterstruktur.", "start": 512.88, "end": 532.04}, {"text": "  Wenn all das gegeben ist, kann man dynamische Programmierung anwenden.  Okay, ich moechte euch jetzt ein Beispiel aus der Wissenschaft nennen, das ermoeglicht  wurde, ausschliesslich aufgrund der Tatsache, dass dynamische Programmierung angewandt  wurde.  Und zwar geht es dabei um die Sequenzierung des menschlichen Genoms.", "start": 532.04, "end": 558.88}, {"text": "  Das war in 2003 eine Sensation, mittlerweile hoert ihr das wahrscheinlich ganz oft, dass  von der und der Spezies, dass das Genom sequenziert wurde oder von dem und dem Virus oder zum  Beispiel vom Covid-19 Virus, haben wir das Genom sequenziert und koennen deswegen die  Proteine in mRNA-Impfstoffen vom Koerper nachbauen lassen.", "start": 558.88, "end": 588.64}, {"text": "  Also all das ist eine Konsequenz der Sequenzierung von Genomen, ob es von Menschen oder vom  Virus ist egal und das ist moeglich tatsaechlich nur mit der dynamischen Programmierung.  Ich tut mir leid, ich finde das ziemlich cool.  Also worum geht es hier?  Das Genom ist natuerlich die DNA des Menschen.  Wie ihr wisst, ist die im Zellkern, den wir hier sehen, ist die DNA drin.", "start": 588.64, "end": 617.68}, {"text": "  Ihr kennt das vielleicht nur aus dem Biologieunterricht, nur um so ein bisschen eine schoene Grafik  zu zeigen fuer die verschiedenen Dinger, die ist naemlich im Nucleus drin.  Und wir haben hier ein schematisches Bild von der Zelle, wo der Nucleus ein bisschen  vergroessert ist.  Hier haben wir die DNA.  Die DNA wird durch ein Transkriptionsprozess in RNA umgewandelt.", "start": 617.76, "end": 644.4799999999999}, {"text": "  Dann wird das weiterverarbeitet in sogenannte mRNA, also Messenger RNA und die wird dann  aus dem Zellkern hinaus in das Zytoplasma, also in das Wasser in der Zelle, rausgeschossen  aus dem Zellkern und dort wird von sogenannten Ribosomen, das sind Proteine, aus diesem mRNA  ein Protein erzeugt.", "start": 644.48, "end": 679.24}, {"text": " Es ist uebrigens ganz genau, wie dieser Impfstoff funktioniert, nur dass dieser Messenger RNA  nicht aus dem Zellkern kommt, sondern mit einem Medikament in die Zelle geliefert wird.  Genau dieselben Molekuele, Proteine, diese Ribosomen, lesen dann die vom Medikament eingefuehrte  Messenger RNA ab und produzieren ein Protein, das so aussieht wie das Spike Protein auf  dem Coronavirus.", "start": 679.24, "end": 702.8}, {"text": "  Das ist aber alleine da ohne den gesamten Virus und deswegen kann sich das Immunsystem  an dieses Protein gewoehnen, was bedeutet das es lernt dieses Protein zu zerstoeren  oder dieses Protein unwirksam zu machen und wenn dann ein Virus kommt, der diese Proteine  draussen hat und von den Proteinen abhaengig ist um in die Zelle rein gelangen zu koennen,", "start": 702.8, "end": 723.88}, {"text": " kann das Immunsystem sofort reagieren und diesem Virus disabeln.  Uebrigens das zentrale Dogma der Molekularbiologie ist genau das von der DNA zu RNA zu Messenger  RNA zu dem Protein.  Also hier wird dann ein Protein erzeugt.  Okay, das ist der Zyklus mit dem was da aus der DNA entsteht, mit einer kleinen Parenthese  zu der Corona-Infung mit Messenger RNA Stoffen.", "start": 723.88, "end": 759.6800000000001}, {"text": "  Schauen wir uns nochmal die DNA an, denn genau um die soll es jetzt gehen, es geht ja um  die Sequenzierung des Genoms und das Genom ist nichts anderes als die Gesamtheit der  DNA Struktur in einer Zelle.  Ihr kennt das wahrscheinlich von Bildern.  Auf der linken Seite diese kleinen schwarz-grauen Fleckchen, das sind die sogenannten Chromosomen.", "start": 759.68, "end": 785.92}, {"text": "  Der Mensch hat davon, ich glaube 23, wenn ich bin, ich irre und in all diesen Chromosomen  ist jeweils Erdmaterial enthalten.", "start": 785.92, "end": 818.84}, {"text": " Wir haben also hier ein Chromosompaar und das ist hier nochmal dargestellt und wir  zoomen jetzt mal in diese kleine Ecke des Chromosompaars rein und sehen, dass das gar  nicht einfach nur so die DNA ist, sondern dass hier so eine Art Wishmob aus DNA sich  um bestimmte Proteine, dieses hier sind wieder Proteine, herum wickelt und dieser Strang", "start": 818.84, "end": 824.7600000000001}, {"text": " aus dem Wishmob wiederum besteht aus weiteren Proteinen, das sind diese rosafarbenen Marshmallows  hier und um die herum wickelt sich ein blauer Strang und wenn wir da weiter reinsummen,  dann sehen wir hier diese bekannte Doppelhelix der DNA.", "start": 824.7600000000001, "end": 860.0400000000001}, {"text": " Wir sagen zu einer dieser Sprossen, sagen wir Basepair, das sind also ein paar von  sogenannten Nucleosaeuren, Nucleotiden und hier aus dem Vokabular GATC entwickelt werden,  es gibt also vier und zwei von denen gehoeren jeweils zusammen und sind jeweils an den  entgegengesetzten Enden einer Sprosse.", "start": 860.0400000000001, "end": 877.3199999999999}, {"text": "Der Punkt ist, in jeder unserer Zellen ist also  dieser DNA Strang unglaublich kompliziert, aufgewickelt um diese Molekuele herum dann  nochmal verdreht und nochmal verdreht und in diesen komischen Strukturen angeordnet.", "start": 877.3199999999999, "end": 903.6}, {"text": " In jeder Zelle von uns stecken drei Meter DNA, wenn ich also aus einer Zelle die ganze  DNA rausholen wuerde, auseinanderdroeseln und die ganz verschiedene Chromosomen  auseinanderlegen, wuerde das ganze drei Meter lang sein und drei Meter klingt vielleicht  noch nicht so viel, aber wenn ich jetzt aus allen menschlichen Zellen die DNA extrahieren", "start": 903.6, "end": 915.12}, {"text": " wuerde und diese drei Meter DNA auseinanderlegen wuerde, dann wuerde ich von der Erde bis zur  Sonne kommen und zurueck und das ganze 50 mal. Also in deinem Koerper steckt DNA, die so  lang ist, dass sie von hier bis zur Sonne und zurueck reicht und noch 49 mal hin und zurueck.  Ist schon ziemlich verrueckt.", "start": 915.12, "end": 945.6800000000001}, {"text": "Und genau diesen drei Meter langen Strang von DNA hat man  sequenziert. Was bedeutet, dass wir abgelesen haben, welche Buchstabenreinfolge GATC ist  denn da kodiert? Das sind, das muesste ich, was genau, das sind, ich glaube das sind drei  Milliarden Paare Base Pairs in der menschlichen DNA.", "start": 945.6800000000001, "end": 969.08}, {"text": "Also in diesen drei Metern sind drei  Milliarden verschiedene Buchstaben Kombinationen abgespeichert. Wenn wir die rauskriegen,  und wissen was sind die Gene, dann koennen wir Krankheiten heilen und so weiter und so fort.", "start": 969.08, "end": 983.9200000000001}, {"text": " Also das ist fuer die Medizin, ist das ein unglaublicher Fortschritt, wenn wir auch nicht  nur sequenziert haetten, sondern verstuenden, welcher Teil auf diese Sequenz entspricht auch  welcher Funktion. Aber gut, wir sind bei der dynamischen Programmierung.", "start": 983.9200000000001, "end": 1004.8}, {"text": "Es ist natuerlich  unglaublich kompliziert, wenn man sich das vorstellt, wie man einen drei Meter langen  molekularen, eine molekulare Kette ablesen will. Und das ist auch sehr kompliziert und deswegen  war eben genau der Schluessel, die Dynamischen Programmierung mit zu verwenden. In etwas,  was heisst Schrotschusssequenzierung oder auf Englisch Schottgarn Sequencing.", "start": 1004.8, "end": 1028.16}, {"text": "Das war die  Idee, dass wir in einem Reagenzglas ganz viele Zellen mit einer identischen DNA machen, die DNA  irgendwie rausholen und dann nehmen wir mal an, wir haben jetzt also in einem Reagenzglas drei  verschiedene identische, also vom selben Lebewesen drei verschiedene genetische Sequenzen.", "start": 1028.16, "end": 1047.3600000000001}, {"text": "Und jetzt  kommt der Schottgarn, der Schrotschuss, will zerschiessen das Ganze und das ist natuerlich voellig  zufaellig, wo diese verschiedenen Sequenzen zerschossen werden. Das ist hier angezeigt,  durch diese gruenen Schnitte, da wurde diese Sequenz zerschossen.", "start": 1047.36, "end": 1072.8799999999999}, {"text": "Ich habe nur hier ein paar  Schnitte gemacht, aber natuerlich dieser drei Meter Sequenz wird in hunderte, wenn nicht tausende und  zehntausende Untersquenzen auf einmal zerschossen.", "start": 1072.8799999999999, "end": 1083.9199999999998}, {"text": "Das erscheint jetzt erstmal nicht sehr zielfuehrend,  denn wir wollen nicht die gesamte Sequenz rauskriegen und jetzt verteilen wir das Ganze und haben damit  in gewisser Weise eine Art Scherbenhaufen, den wir erst mal wieder zusammensetzen muessen.", "start": 1083.9199999999998, "end": 1094.72}, {"text": "Das Ziel  ist natuerlich, dass so eine kurze Kette von DNA viel einfacher zu sequenzieren ist als das ganze  Ding. Das heisst also, wir zerschiessen diese Kette, damit wir diese einzelnen Teile gut  sequenzieren koennen, haben aber das Zusatzichproblem, dass wir dann die ganzen Puzzleteilungen  zusammensetzen muessen und genau da hilft die dynamische Programmierung.", "start": 1094.72, "end": 1112.6000000000001}, {"text": "Also wir haben jetzt,  ich habe jetzt einfach mal hier von hier oben eine Sekunde, ich habe hier diesen Teil hier  runter kopiert und diesen Teil hier runter kopiert. Hier oben ist klar, die sind sequenziell. Nach  dem wir es zerschossen haben, wissen wir es nicht mehr, dass die sequenziell sind.", "start": 1112.6000000000001, "end": 1133.1200000000001}, {"text": "Aber wir haben ja  auch diesen anderen Teil von dem orangenden DNA sequenziert und nun ist es so, dass es hier  Entsprechungen gibt. Diese beiden Teile entsprechen sich.", "start": 1133.12, "end": 1161.92}, {"text": "Das heisst, wenn wir diese Zeichenketten haben,  die diesen drei verschiedenen Sequenzen entsprechen, dann ueberschneiden die sich genau in diesen beiden  Teilen. Wir koennen also, wenn wir diese Sequenz hier von haben, diese Sequenz hier von haben und  hier von durch die Ueberlappung die Sequenzialitaet der beiden orangenen Teile wieder rekonstruieren.", "start": 1161.92, "end": 1178.4}, {"text": "  Und genau das ist das Problem, was wir loesen muessen. Nehmen wir mal an in dieser Schnittstelle hier,  steckt ein String, der irgendwie, also ich male das nochmal, das gibt hier kleine technische  Probleme. So hier, das sollte eine Klammer sein. Also hier steht, sagen wir mal, G T A A T C G, das steht  natuerlich sowohl im gelben als auch in dem orangischen.", "start": 1178.4, "end": 1213.32}, {"text": "Bei dem gelben kommt hier vorne noch  ganz viel dran und bei dem orangischen steht auch G T A A T C G und dann kommt noch ganz viel  da hinten dran.", "start": 1213.32, "end": 1239.48}, {"text": "Und dann kommt, nehmen wir mal an hier dieser zweite Abschnitt, ich mache jetzt  einen kurzeren String, dann kommt hier irgendwie A A T G C G und genau das gleiche steht natuerlich  auch hier drueber in dem gelben D N A Strang. Und naja, dann koennen wir also diese Dinge  miteinander erleihen und wir wissen dann, wie die Abfolge der einzelnen Strings ist.", "start": 1239.48, "end": 1253.8400000000001}, {"text": "Das heisst,  die Idee hinter dieser Schrotschusssequenzierung ist, ich unterteile meine D N A Strings in kleinere  Komponenten, die sich ueberlappen, damit ich diese kleine Komponenten einfach sequenzieren kann  und dann benutze ich einen effizienten Algorithmus, dynamische Programmierung, um aus diese  Ueberlappung die Gesamtkette wiederherzustellen.", "start": 1253.84, "end": 1280.6399999999999}, {"text": "Das heisst, wir brauchen ein Algorithmus, der  Zeichenketten miteinander so arrangiert, dass die Ueberlappung offensichtlich wird. Das ist hier  beispielhaft dargestellt. Wir haben hier zwei Strings, die aus den Buchstaben A A T G und C  bestehen und wir wollen die gerne miteinander so alignen.", "start": 1280.64, "end": 1303.72}, {"text": "Bei dem Alinen, also bei dem,  man sagt wohl oft Deutsch, auch Alignment, gibt es natuerlich oft auch so kleine Lesefehler oder es  gibt Mutationen. Das heisst, wir haben kleine Unstimmigkeiten, die uns dabei im Wege sind. Und  das wird hier ausgedrueckt.", "start": 1303.72, "end": 1323.84}, {"text": "Wir koennen also, das ist zum Beispiel Alignment 1, das ist, indem ich  einfach die beiden Zeichenketten nehme und versuche, das Matching zwischen diesen beiden  Zeichenketten zu maximieren. Das ist jetzt hier nicht so gut gelungen, aber wir koennen die beiden  Zeichenketten aneinander verschieben und drei Matches ist irgendwie ganz gut.", "start": 1323.84, "end": 1340.76}, {"text": "Wir koennen aber  diese Luecken hier einfuehren und dann haben wir noch weitere Matches. Wir haben 1, 2, 3, 4, 5, 6, 7.  Sieben Matches, aber dafuer mussten wir drei Luecken einfuehren. Oder wir koennen diese beiden  Luecken einfuehren und dann haben wir 1, 2, 3, 4, 5, 6, 6 verschiedene Matches.", "start": 1340.76, "end": 1359.8400000000001}, {"text": "So, wie ist es jetzt  der Besser? Hier haben wir drei Luecken eingefuehrt, hier mussten wir nur zwei einfuehren, hier haben  wir dafuer sieben Matches, hier nur sechs. Also wir haben hier drei verschiedene Arten und Weisen,  bestimmte Strings miteinander zu matchen.", "start": 1359.8400000000001, "end": 1377.24}, {"text": "Das ist genau das Problem, was wir loesen muessen, weil  hier ist ja noch irgendwie ganz viel dran und hier ist auch noch ganz viel dran. Wir wollen aber  diese Kriminalitaet rauskriegen, muessen also finden, dass diese Strings sich miteinander gematched haben  und dass wir daraus die ganze Kette wieder rekonstruieren koennen.", "start": 1377.24, "end": 1395.56}, {"text": "So, jetzt haben wir aber  ein informatisches Problem und das ist ganz einfach, dass Aneinanderreihen von Zeichenketten oder das  Matchen von Zeichenketten. Und das Matchen passiert entweder indem wir einen Buchstaben,  die sich nicht matcht, ueberspringen, indem wir einen Buchstaben ueberspringen, der sich matcht,  oder indem wir so ein Luecke einfuehren, dieses Minuszeichen.", "start": 1395.56, "end": 1416.96}, {"text": "Das ist ein Problem,  in dem es exponentiell, sogar doppelt exponentiell viele Moeglichkeiten gibt,  zwei Zeichenketten miteinander abzugleichen. Das ist die reine Anzahl der Moeglichkeiten,  das zu tun. Das wissen wir sofort, dieses Problem ist nicht loesbar.", "start": 1416.96, "end": 1447.96}, {"text": "Aber wir koennen die dynamische  Programmierung verwenden und mit der dynamischen Programmierung muessen wir nicht alle moeglichen  Alignments austesten, sondern wir testen kleine Unterprobleme aus und setzen aus diesen kleinen,  optimalen Unterloesungen die optimalen groesseren Loesungen zusammen.", "start": 1447.96, "end": 1461.52}, {"text": "Und genau das ist, was  dynamische Programmierung macht. Es gibt zwei Algorithmen, der eine heisst Smith-Waterman,  und der andere heisst Niedelman-Wunsch-Algorithmus. Und das sind die beiden Algorithmen, die bis heute  in der Genetik verwendet werden. Das sind beides dynamische Programmierungsalgorithmen,  die unterscheiden sich tatsaechlich nur in einer einzigen Zeile ihres Quotes.", "start": 1461.52, "end": 1498.68}, {"text": "Und die werden  benutzt, loesen das Problem und haben uns uns ermoeglicht, den Mensch des menschlichen Genoms,  das Genom von vielen Tierarten, aber auch das Genom von Viren zu sequenzieren. Mithilfe der  dynamischen Programmierung.", "start": 1498.68, "end": 1524.44}, {"text": "Mir ist klar, dass ich euch nicht gesagt habe, wie genau das geht,  aber ich hoffe, ich habe euch Appetit gemacht auf die naechsten Videos, weil die sollten euch das  tatsaechlich ganz genau erklaeren.", "start": 1524.44, "end": 1534.0}, {"text": "Und wenn ihr die geschaut habt, dann koennt ihr auf Google gehen  und Smith-Waterman und Niedelman-Wunsch eingeben, findet ihr Wikipedia-Seiten, auf denen diese  Algorithmen erklaert werden.", "start": 1534.0, "end": 1548.1200000000001}, {"text": "Und es sollte fuer euch ein leichtes sein, zu verstehen, ganz genau,  wie diese Methode funktioniert, die es uns ermoeglicht hat, die Genome von Lebewesen sequenzieren  zu koennen, mithilfe der Schrotschussmethode. Dann viel Spass dabei!", "start": null, "end": 1548.1200000000001}]}]