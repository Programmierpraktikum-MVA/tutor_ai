[{"lecture": "31624_6_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir nun abschliessend ein paar Themen des Semesters wiederholen.  Beginn wollen wir mit diesem Code Snippet. Wir haben hier eine Funktion, die einen Grafen  uebergeben bekommt, einen Integer und einen Boolean-Ary. Nun koennten wir uns zu diesem Code  folgende Fragen stellen.", "start": 0.0, "end": 30.68}, {"text": "Erst einmal, was macht dieser Code ueberhaupt? Dann ist die Frage,  kommt uns dieser Algorithmus vielleicht bekannt vor? Und wie gross ist die Laufzeit dieses Algorithmus?  Um herauszufinden, was dieser Code macht, wollen wir eine kleine Handsimulation durchfuehren. Dazu  benoetigen wir erst einmal die Eingabeparameter.", "start": 30.68, "end": 56.120000000000005}, {"text": "Wir haben einen Grafen G, ich habe hier zum  Beispiel Knoten 0, dann folgt hier Knoten 1, Knoten 2, Knoten 3 und Knoten 4. Ausserdem  bekomme ich uebergeben ein V.", "start": 56.120000000000005, "end": 77.72}, {"text": "Dieses entspricht wahrscheinlich eine meiner Knoten, das heisst  hier will ich zum Beispiel mal Knoten 0 und ich habe ein Boolean-Ary solved und ich sehe schon in  der ersten Zeile des Codes, ich benutze hier V als Index des Arrays. Das heisst vermutlich ist mein  Array solved so gross, wie ich Anzahl der Knoten habe. Also in unserem Fall 5 gross.", "start": 77.72, "end": 102.32000000000001}, {"text": "Initialisiert,  Symbolien arrays immer mit false. Nun fuehre ich den Beispielcode einmal aus. Zuerst setze ich  solved an der Stelle V auf true.", "start": 102.32000000000001, "end": 126.84}, {"text": "Anschliessend iteriere ich ueber alle Nachbarn von V und wenn  fuer diesen Nachbar solved noch nicht true ist, dann rufe ich rekursiv meine Funktion mit dem Knoten  V auf. Das heisst ich gehe in die Schleife, mein erster Nachbar von 0 ist 1, solved von 1 ist noch  false, das heisst ich rufe mystery mit 1 auf.", "start": 126.84, "end": 142.48}, {"text": "Ich setze also solved von 1 auf true und gehe  wieder alle Nachbarn durch. Hier habe ich als Nachbarn 0, 3, 4. Der Knoten 0 ist schon geloest,  das heisst es bleiben noch 3 und 4. Ich schaue mir also als naechstes 3 an und rufe meine  Mystery Funktion mit Knoten 3 auf.", "start": 142.48, "end": 162.84}, {"text": "Ich setze hier also Knoten 3 auf true und gehe nun in eine  Schleife ueber alle Nachbarn. Ich habe hier nur Nachbar 1, Nachbar 1 ist allerdings schon solved,  das heisst ich rufe meine Mystery Funktion nicht noch mal auf. An dieser Stelle returne ich und bin  wieder bei Knoten 1. Hierueber pruefe ich nur den naechsten Nachbarn naemlich 4.", "start": 162.84, "end": 183.64000000000001}, {"text": "Knoten 4 setze ich  also auf true und ueberpruefe dann alle Nachbarn. Auch hier bleibt nur Knoten 1 als Nachbar. Knoten 1  ist allerdings schon geloest, das heisst ich untersuche hier nichts weiter und return.", "start": 183.64000000000001, "end": 200.52}, {"text": "Nun habe ich  auch alle Nachbarn von Knoten 1 untersucht, das heisst auch hier kann ich return und bin nun wieder  bei Knoten 0. Von Knoten 0 kann ich nur den naechsten Nachbarn untersuchen und das ist Knoten 2. Auch fuer  diesen setze ich den Eintrag im solved area wieder auf true.", "start": 200.52, "end": 212.12}, {"text": "Anschliessend ueberpruefe ich alle  Nachbarn, das ist hier nur der Nachbar 0. Der ist allerdings schon geloest, das heisst ich returne  und nun ist auch alles fuer den Knoten 0 geloest, das heisst die Funktion returned. Was wissen wir  also ueber den Algorithmus? Wir haben herausgefunden, der Algorithmus ist auf alle Faelle rikrosiv.", "start": 212.12, "end": 233.4}, {"text": "Wir  haben ausserdem herausgefunden, Schritt fuer Schritt besucht dieser Algorithmus alle Knoten in unserem  Grafen.", "start": 233.4, "end": 252.88}, {"text": "Jetzt sollten wir uns noch fragen, in welcher Reihenfolge werden denn die Knoten untersucht?  Zuerst haben wir Knoten 0 untersucht, dann Knoten 1, dann Knoten 3, anschliessend Knoten 4 und dann  Knoten 2. Wenn wir uns an die Algorithmen zurueck erinnern, die wir auf Grafen kennengelernt haben,  dann entspricht das unserer Tiefensuche.", "start": 252.88, "end": 266.92}, {"text": "Unsere Mystery Funktion ist also eine reklusive  Implementierung der Tiefensuche. Bleibt nur noch die Frage nach der Laufzeit. Um die Laufzeit  abzuschaetzen, verwende ich die Ohnotation. Jetzt muss ich zum einen ueberlegen, wie oft wird die  Funktion aufgerufen und zum anderen muss ich ueberlegen, wie oft diese Schleife ausgefuehrt wird.", "start": 266.92, "end": 284.32}, {"text": "  Die Funktion wird genau fuer jeden Knoten einmal aufgerufen, das heisst ich habe auf alle Faelle  schon mal Anzahl der Knoten in meiner Laufzeit, in dem Falle GOSV. Fuer jeden Knoten gehe ich dann  alle benachbarten Kanten durch. Also fuer Knoten 0 waeren das 2 Kanten, fuer Knoten 1 waeren das 3  Kanten und so weiter und so fort.", "start": 284.32, "end": 311.72}, {"text": "Dass sich hier um ein Ungerichteten Grafen handelt, besuche ich  hier insgesamt jede Kante 2 Mal. Es kommt hier also die Laufzeit von 2e dazu. Da allerdings bei der  Abschaetzung Konstanten vernachlaessigt werden koennen, addieren wir hier nur die Anzahl der  Kanten dazu. Unsere Laufzeit ist also Anzahl der Knoten plus Anzahl der Kanten.", "start": 311.72, "end": 332.36}, {"text": "  Nachdem wir nun unsere Tiefensuche wieder erkannt haben, wollen wir nun noch einmal Grafen im Allgemeinen  wiederholen. Ihr seht hier, wie so oft als Beispiel verwendet, das S- und U-Bahn-Netz von Berlin,  welches alle Badesen und Schwimmbaeder verbindet.", "start": 332.36, "end": 350.84000000000003}, {"text": "Anhand dieses Beispiels wollen wir wiederholen,  welche Arten von Grafen wir bereits kennengelernt haben, welche Algorithmen wir auf diesen Grafen  kennengelernt haben und welche Arten von Problem damit geloest werden koennen. Bei Grafen haben wir  zuerst unterschieden zwischen gerichteten und ungerichteten Grafen.", "start": 350.84000000000003, "end": 369.04}, {"text": "Der Unterschied zwischen  den beiden war, in welche Richtung wir die Kante nehmen koennen. Bei gerichteten Grafen immer nur  entlang der Pfeilrichtung, bei ungerichteten Grafen in beide Richtungen. Anschliessend haben wir  Kanten Gewichte eingefuehrt.", "start": 369.04, "end": 388.88}, {"text": "Wir koennen also auch unterscheiden zwischen gewichteten und ungewichteten  Grafen. Je nach Graf entspricht das Kantengewicht eine andere Groesse. Bei Flussgrafen im speziellen  entsprach das Kantengewicht naemlich der Kapazitaet ueber eine Kante. Auf diesen Grafen haben wir  dann mehrere Algorithmen kennengelernt.", "start": 388.88, "end": 406.44}, {"text": "Mit der Breiten- und der Tiefensuche koennen wir Grafen  nach einem bestimmten Muster durchlaufen. Mit Prim und Grosskahl haben wir auf einem Grafen den  minimalen Spannbaum gefunden. Mit Dijkstra und Bellman-Ford haben wir auf einem Grafen kuerzeste  Wege gefunden.", "start": 406.44, "end": 424.12}, {"text": "Und mit dem Edmund-Carb-Algorithmus haben wir den maximalen Fluss ueber den Grafen  bestimmt. Doch wie lassen sich all diese Algorithmen auf unseren Beispielgrafen hier anwenden? Lautet  unser Problem zum Beispiel, dass wir ein bestimmtes Strandbad suchen, dann koennen wir diesen Knoten  mit der Tiefen- oder der Breiten-Suche finden.", "start": 424.12, "end": 439.84}, {"text": "Interessiert uns lediglich, welche Linien mindestens  verwendet werden muessen, um alle Schwimmbaeder zu erreichen? Dann koennen wir den minimalen  Spannbaum auf dem Grafen bestimmen, mithilfe von Prim oder Grosskahl.", "start": 439.84, "end": 456.84}, {"text": "Suchen wir von einem  Startknoten aus den kuerzesten Weg zu einem Schwimmbad, so koennen wir mittels des Dijkstra oder  Bellman-Ford-Algorithmus diesen berechnen. Wenn wir nun an heissen Sommertagen die Auslastung  unserer Strecke wissen wollen, dann koennen wir den Fluss ueber unseren Grafen bestimmen,  dann koennen wir den Fluss ueber unseren Grafen bestimmen.", "start": 456.84, "end": 471.56}, {"text": "Ihr seht schon, dass selbst so ein  sehr einfacher Graf zum einen sehr viele Darstellungsmoeglichkeiten hat und man allerdings  auch sehr viele Probleme durch die Darstellung als Graf loesen kann. Als naechstes wollen wir uns  nun die topologische Sortierung anschauen.", "start": 471.56, "end": 488.04}, {"text": "Hierzu haben wir links einen Code gegeben,  der unsere Mystery Funktion verwendet, um eine topologische Sortierung zu erstellen und auf  der rechten Seite haben wir nun Kleidungsstuecke, die wir topologisch sortieren wollen.", "start": 488.04, "end": 505.76}, {"text": "Zuerst  wollen wir einen gerichteten Grafen erstellen, wobei jede Kante bedeutet, dass der Startknoten  der Kante vor dem Endknoten der Kante angezogen werden muss. Als Beispiel, die Unterhose sollte  vor der Hose angezogen werden, deswegen sollte es eine Kante geben, die von Knoten 8 zu Knoten 6  geht.", "start": 505.76, "end": 523.76}, {"text": "Dann fragen wir uns, wie die Methode Mystery veraendert werden muss, damit sie in diesem  Code funktioniert. Anschliessend wollen wir eine topologische Sortierung angeben, die uns unser  Code hier zurueckgibt und abschliessend noch ueberlegen, fuer welche Grafen diese topologische Sortierung  funktioniert.", "start": 523.76, "end": 545.52}, {"text": "Zuerst einmal wollen wir die Kleidungsstuecke in einem Grafen sortieren, sodass immer  der Startknoten einer Kante vor dem Endknoten einer Kante angezogen werden muss. Was wir auf alle  Faelle sagen koennen, ist, dass die Unterhose, in dem Fall Knoten 7, angezogen werden muss,  bevor die Hose, also Knoten 5, angezogen wird.", "start": 545.52, "end": 566.56}, {"text": "Wir wissen auch, dass die Hose angezogen werden muss,  bevor der Guertel, also Nummer 3, angezogen werden muss. Wir wissen ausserdem, dass die Hose, also Knoten  5, angezogen werden muss, bevor man die Schuhe anziehen kann, also vor Knoten 4. Wir wissen allerdings  auch, dass wir die Socken anziehen muessen, bevor man die Schuhe anziehen kann, also Knoten 1.", "start": 566.56, "end": 588.0799999999999}, {"text": "Allerdings  sind die Socken unabhaengig von Unterhose und Hose. Was von dem unteren Teil auch unabhaengig ist,  sind die Kleidungsstuecke am Oberkoerper. Wir muessen auf alle Faelle das Unterhemd zuerst  anziehen, also Knoten 0. Und anschliessend koennen wir unabhaengig voneinander Krawatte und Sacco  anziehen. Allerdings beides erst nach dem Unterhemd.", "start": 588.0799999999999, "end": 610.76}, {"text": "Das heisst, auf das Unterhemd folgt  sowohl das Sacco als auch die Krawatte. Nun muessen wir uns ueberlegen, wie wir die  Mysteryfunktion anpassen muessen, damit diese in unserer topologischen Sortierung funktioniert.  Hier verwenden wir sie an dieser Stelle.", "start": 610.76, "end": 628.1999999999999}, {"text": "Wir uebergeben zusaetzlich zu dem, was nun dort oben  steht, auch ein Stack. Das heisst, mit diesem Stack muessen wir auf alle Faelle irgendetwas machen.  Nun muessen wir uns noch ueberlegen, in welcher Reihenfolge wir die Elemente auf dem Stack haben  wollen. Am Ende soll ganz oben auf dem Stack das Element liegen, was sich als erstes anziehen muss.", "start": 628.1999999999999, "end": 647.4}, {"text": "  In dem Falle also unser Knoten 7. Knoten 7 kann also erst gepusht werden, wenn alle Nachfolger auf  dem Stack sind. Das entspricht in unserer Mysteryfunktion der folgenden Stelle. In der Vorschleife  habe ich alle Nachbarn abgearbeitet. Das heisst, an dieser Stelle, wo ich jetzt den Strich gesetzt  habe, kann ich mein Element auf den Stack pushen.", "start": 647.4, "end": 675.04}, {"text": "Hier muesste also so etwas stehen wie Stack,  Push und dann mein aktuelles Element. Wollen wir nun einmal eine Handsimulation von der topologischen  Sortierung durchfuehren. Das, was ich hier aufgezeichnet habe, ist unser Graph G und diesen  uebergebe ich der topologischen Sortierungfunktion.", "start": 675.04, "end": 692.28}, {"text": "In dieser Funktion beginne ich damit,  ein Layern Stack zu initialisieren und ausserdem erzeuge ich ein Array visited,  welches fuer jeden Knoten speichert, ob dieser bereits besucht wurde. Initial ist das false fuer  jeden Knoten. Nun gehe ich in diese Schleife, die alle Knoten durchgeht. Beginn tu ich mit Knoten 0.", "start": 692.28, "end": 726.08}, {"text": "  Dieser ist noch nicht besucht, das heisst, ich rufe meine Mysteryfunktion auf. In dieser  eraender ich zuerst den Wahrheitswert meines Solved Arrays auf True und gehe nun alle Nachbarn  von 0 durch.", "start": 726.08, "end": 748.64}, {"text": "Der erste Nachbar von 0 in meinem Graph ist die 6, das heisst, ich rufe erneut die  Mysteryfunktion mit der 6 auf, setze die 6 auf True und dann gehe ich alle Nachbarn durch,  allerdings gibt es keine Nachbarn mehr, die ich noch nicht besucht habe, das heisst,  ich bin an der Stelle fertig, pushe die 6 auf den Stack und Return.", "start": 748.64, "end": 759.6}, {"text": "Dann schaue ich mir den  naechsten Nachbarn von 0 an, das ist die 2, das heisst, ich setze den Eintrag in mein visited  array auf True. Ueberpruefe nun alle Nachbarn, es gibt allerdings keine Nachbarn mehr,  die ich noch nicht besucht habe, das heisst, ich pushe den Knoten auf den Stack und Return. Nun  habe ich auch alle Nachbarn von 0 abgearbeitet, das heisst, ich pushe auch die 0 auf den Stack.", "start": 759.6, "end": 784.7}, {"text": "  Anschliessend return ich wieder zurueck zu meiner topological sort-clothing-Funktion und ueberpruefe  nun den naechsten Knoten, in dem Falle Knoten 1. Ich setze also wieder Knoten 1 auf True und  ueberpruefe die Nachbarn von Knoten 1. Knoten 1 hat als Nachbarn nur Knoten 4, das heisst,  ich rufe das ganze Rekursiv mit Knoten 4 auf.", "start": 784.7, "end": 811.22}, {"text": "Hier setze ich Knoten 4 auf True, Knoten 4 hat  nun allerdings keine Nachbarn mehr, das heisst, ich pushe Knoten 4 in den Stack und Return.  Dann habe ich auch Knoten 1 fertig abgearbeitet, das heisst, ich fuege Knoten 1 in den Stack  hinzu und Return.", "start": 812.22, "end": 829.58}, {"text": "Nun schaue ich mir in meiner topological sort-clothing-Funktion den naechsten  Knoten an, das waere hier Knoten 2. Knoten 2 ist allerdings schon besucht, das heisst,  ich schaue mir den nicht mehr an, sondern schaue mir stattdessen Knoten 3 an. Ich rufe also meine  Mystery Funktion mit Knoten 3 auf.", "start": 829.58, "end": 847.3000000000001}, {"text": "Zu Beginn setze ich den Eintrag im visited area erst mal auf True  und dann schaue ich mir wieder die Nachbarn an. Knoten 3 hat keine Nachbarn, das heisst,  ich pushe Knoten 3 auf den Stack und Return. Nun schaue ich mir in der topological sort-clothing-Funktion  als naechstes Knoten 4 an.", "start": 847.3000000000001, "end": 867.26}, {"text": "Knoten 4 ist schon abgearbeitet, das heisst, ich schaue mir als naechstes  Knoten 5 an, rufe die Mystery Funktion mit Knoten 5 auf. In dieser Mystery Funktion setze ich den  Eintrag im visited area erst mal auf True. Ueberpruefe dann alle Nachbarn.", "start": 867.26, "end": 888.0600000000001}, {"text": "Fuenf hat die Nachbarn 3 und 4,  die wurden allerdings beide schon besucht, das heisst, ich bin an der Stelle schon wieder fertig,  pushe die 5 auf den Stack und Return zur topological sort-clothing-Funktion. Hier wird  dann als naechstes der Knoten 6 ueberprueft.", "start": 888.06, "end": 899.38}, {"text": "Knoten 6 wurde allerdings auch schon fertig abgearbeitet,  das heisst, ich ueberpruefe als naechstes Knoten 7, rufe mit diesem Knoten wieder die Mystery Funktion  auf. Hier setze ich also erst einmal wieder den Eintrag vom visited area of true und ueberpruefe  dann alle Nachbarn.", "start": 899.38, "end": 918.9399999999999}, {"text": "Die 7 hat nur den Nachbarn 5, der Nachbarn 5 wurde schon fertig abgearbeitet,  das heisst, ich kann die 7 auf den Stack pushen und Return. Nun habe ich alle Knoten abgearbeitet,  das heisst, ich gehe noch in die letzte Weissschleife ueber und das ist eine Konsulenausgabe. Hier wird  nun Schritt fuer Schritt jedes Element vom Stack gepoppt und auf der Konsole ausgegeben.", "start": 918.9399999999999, "end": 946.86}, {"text": "Unsere  Ausgabe sieht also wie folgt aus. Wir haben zuerst Element 7, dann 5, dann 3, 1, 4, 0, 2 und dann die 6.  Das ist die Reihenfolge, in der wir unsere Kleidung anziehen muessten.", "start": 946.86, "end": 968.22}, {"text": "Zuerst also die Unterhose,  dann die Hose, dann der Guertel, dann die Socken, die Schuhe, das Unterhemd, die Krawatte und abschliessend  das Sacco. Das Ganze koennen wir auch nochmal so verdeutlichen, dass wir die Knoten von links  nach rechts anordnen, damit klar wird, in welcher Reihenfolge wir die Knoten abarbeiten muessen.", "start": 968.22, "end": 986.22}, {"text": "  Zuerst Knoten 7, anschliessend Knoten 5. In diesem Teilgraf folgt dann noch Knoten 1, Knoten 4 und Knoten 3  und Knoten 5 muss noch vor Knoten 4 abgearbeitet werden und vor Knoten 3 abgearbeitet werden.  Fuer den zweiten Teilgraf sieht das aehnlich aus.", "start": 986.22, "end": 1013.06}, {"text": "Hier haben wir zuerst Knoten 0 und dieser muss vor  Knoten 2 und Knoten 6 abgearbeitet werden, das heisst sowohl hiervor als auch hiervor. Bleibt noch die Frage  auf welchen Grafen das Ganze funktioniert? Da wir hier eine eindeutige Reihenfolge feststellen wollen,  koennen wir Startknoten und Endknoten einer Kante nicht vertauschen.", "start": 1013.06, "end": 1031.3}, {"text": "Die Richtung einer Kante ist also  wichtig. Somit funktioniert das Ganze nur auf gerichteten Grafen. Diese duerfen allerdings auch  kein Zyklus enthalten. Der Algorithmus funktioniert also auf gerichteten a-zyklischen Grafen.", "start": 1031.3, "end": 1052.3}, {"text": " Wollen wir uns nun abschliessend zur Wiederholung noch einmal die Alphabettersuche anschauen? Hierzu  wollen wir das folgende Beispiel loesen. Probiert das gerne erst einmal wieder selbst und anschliessend  zeige ich euch die Loesung.  Bei der Alphabettersuche starten wir mit der Suche bei dem Wurzelknoten.  Neben dieser gruenen Felder geben wir nun das Intervall beim Aufruf der Score Methode an.", "start": 1052.3, "end": 1086.3}, {"text": "  Initial rufen wir die Score Methode mit einem Beta von unendlich und einem Alpha von minusunendlich  auf. Da ich am naechsten Knoten noch kein Score berechnen kann, rufe ich erneut die Scorefunktion  mit Alpha und Beta auf. Diese haben sich nicht veraendert, das heisst Beta ist weiterhin unendlich  und Alpha ist weiterhin minusunendlich. Der Aufruf sieht genauso fuer den naechsten Knoten aus.", "start": 1087.3, "end": 1112.3}, {"text": "  Beta ist unendlich, Alpha ist minusunendlich. Nun erhalte ich als Rueckgabe ein Scorewert von 2.  Da hier Spieler A dran ist, wird verglichen, ob der Score groesser ist als mein bisheriges Alpha.  Das ist der Fall, das heisst ich ersetze mein bisheriges Alpha. Beta bleibt also unendlich und Alpha ist nun 2.  Das uebergebe ich dann auch der naechsten Score Methode, also Beta unendlich, Alpha 2.", "start": 1112.3, "end": 1142.3}, {"text": "  Von diesem Aufruf erhalte ich den Score 3 zurueck. Da ich hier immer noch Spieler A bin, der maximieren moechte,  vergleiche ich die 3 mit meinem bisherigen Alpha. Mein bisheriges Alpha ist 2, das heisst ich ersetze mein Alpha.", "start": 1142.3, "end": 1163.3}, {"text": " Nun habe ich alle Folgeknoten ueberprueft, das heisst ich gebe als Spieler A mein aktuellen Alpha  Wert als Score zurueck, in dem Falle 3. Im Knoten darueber ueberpruefe ich nun fuer Spieler B,  ob der Rueckgabe Wert in dem Falle 3 kleiner als mein bisheriges Beta ist.  Das ist der Fall, das heisst ich ersetze Beta durch 3 und Alpha ist hier weiterhin minusunendlich.", "start": 1163.3, "end": 1184.3}, {"text": "  Diese Parameter uebergebe ich dann auch, wenn ich den naechsten Nachfolgerknoten ueberpruefe.  Auch an dieser Stelle habe ich noch kein Ergebnis gefunden, das heisst ich uebergebe wieder mein Alpha und mein Beta.  Und nun erhalte ich das Ergebnis von 4. Ich vergleiche wieder, ob 4 groesser ist als mein bisheriges Alpha minusunendlich.  Das ist der Fall, das heisst ich ersetze mein bisheriges Alpha.", "start": 1184.3, "end": 1210.3}, {"text": "  Nun habe ich hier den Fall, dass Alpha groesser gleich Beta ist.  Deswegen kommt es an dieser Stelle fuer Spieler A zum Beta Cutoff.  Spieler A gibt dann also ohne die weiteren Knoten zu untersuchen den Wert von Alpha zurueck in dem Falle 4.  Spieler B vergleicht wieder, ist der Rueckgabe Wert in dem Falle 4 kleiner als mein bisheriges Beta, 3 ist es nicht.", "start": 1210.3, "end": 1237.3}, {"text": "  Das heisst ich gebe stattdessen mein bisheriges Beta, also 3 zurueck.  Nun sind wir hier oben wieder am Wurzelknoten angekommen.  Ich habe den Rueckgabe Wert 3 erhalten, ich vergleiche also ist 3 groesser als mein bisheriges Alpha minusunendlich, ja ist es.  Das heisst ich ersetze mein Alpha, ich habe also weiterhin Beta unendlich und Alpha 3.  Das uebergebe ich nun auch dem naechsten Aufruf.", "start": 1237.3, "end": 1268.3}, {"text": "  Da hier noch kein Score bestimmt werden kann, untersuche ich den ersten Kinderknoten, auch wieder mit Beta und Alpha.  Nun habe ich hier den Rueckgabe Wert 1, ich vergleiche also ist 1 groesser als mein bisheriges Alpha 3, ist es nicht.  Das heisst ich habe weiterhin Beta unendlich und Alpha 3.  Damit rufe ich dann auch wieder den naechsten Kinderknoten auf, Beta unendlich, Alpha 3.", "start": 1268.3, "end": 1296.3}, {"text": "  Hier erhaelt ich dann 2 zurueck, ich habe dann 2 zurueck, ich habe dann wieder 2 zurueck, ich habe dann wieder 2 zurueck,  hier erhaelt ich dann 2 zurueck, 2 ist auch nicht groesser als mein bisheriges Alpha 3,  das heisst ich ersetze auch hier das Alpha wieder nicht und gebe Alpha am Ende zurueck.", "start": 1296.3, "end": 1318.3}, {"text": "  Nun bin ich hier bei Knoten B, Knoten B ueberprueft nun ist die Rueckgabe 3 kleiner als mein bisheriges Beta, ist es, das heisst ich ersetze Beta zu 3.  Nun habe ich hier den Fall, Beta ist kleiner gleich Alpha und ich bin bei Spieler B,  das heisst an dieser Stelle kommt es zum Alpha Cutoff.", "start": 1318.3, "end": 1344.3}, {"text": " Ich untersuche also die folgenden Knoten nicht mehr, gebe meinen Beta zurueck, das ist in dem Falle 3  und gehe wieder zum Wurzelknoten, auch hier habe ich 3 zurueckgegeben bekommen, 3 ist nicht groesser als mein bisheriges Alpha 3.  Ich habe alle Kinderknoten untersucht, das heisst ich gebe meinen Alpha zurueck und das Endergebnis hier ist 3.", "start": 1344.3, "end": 1354.3}]}]