[{"lecture": "31624_8_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns die Hausaufgabe zu dieser Woche anschauen.  In dieser Hausaufgabe geht es um die folgende Knobelaufgabe.  Wir haben auch wieder ein Spielfeld aufgeteilt in Felder.  Auf diesen Feldern bewegen sich zwei Roboter.  Ziel des Spiels ist es nun, den einen Roboter an sein Zielort zu bringen.", "start": 0.0, "end": 26.0}, {"text": "  Das waere natuerlich sehr einfach, wenn ihr mit dem Roboter einfach beliebige Schritte gehen koenntet.  Allerdings koennt ihr die Roboter nur nach folgenden Regeln ziehen.  Ein Roboter darf nur nach oben, unten, links und rechts gezogen werden.  Wenn ein Roboter gezogen wird, dann laeuft er in die Richtung so lange,  bis er entweder an einer Wand oder am anderen Roboter zum Stehen kommt.", "start": 27.0, "end": 49.0}, {"text": "  Das bedeutet, entscheidet ihr euch ein Roboter in eine Richtung zu ziehen,  dann muesst ihr diesen so weit ziehen, bis ihr an der naechsten Wand oder am anderen Roboter zum Stehen kommt.  Ein Beispiel fuer die Loesung der Knobelaufgabe seht ihr hier rechts.  Der ausgefuehrte blaue und pinke Kreis entspricht den beiden Robotern.  Der blaue Ring entspricht dem Ziel fuer Roboter 0, also dem Blauen.", "start": 49.0, "end": 75.0}, {"text": "  Die dicken grauen Linien entsprechen den Waenden auf dem Spielfeld.  Eine moegliche Loesung waere also die folgende.", "start": 75.0, "end": 98.0}, {"text": " Man zieht zuerst Roboter 1, also dem pinken Roboter nach unten,  dieser wuerde dann bis zur Wand ziehen, dann zieht man ihn nach rechts, auch bis zur naechsten Wand,  anschliessend nach oben, auch bis zur naechsten Wand,  und dann kann man Roboter 0, also dem blauen Roboter, nach rechts ziehen bis zur Wand,  und dann nach oben, dort wuerde er dann vor dem anderen Roboter zum Stehen kommen", "start": 98.0, "end": 106.0}, {"text": " und somit sein Zielpunkt erreicht haben.  In der ersten Aufgabe sollte euch wieder einen Ueberblick verschaffen, was bereits implementiert wurde.  Die Klasse Position enthaelt die Implementierung der Spielfeldposition, also die Koordinaten einer jeden Position.  Die Klasse Move enthaelt die Implementierung der Zuege, die von den Robotern durchgefuehrt werden koennen.", "start": 107.0, "end": 131.0}, {"text": "  Die Klasse Robot enthaelt die Implementierung der Roboter und dessen Position.  Die Klasse Board enthaelt dann die Implementierung des Spielbrettes.  Sie enthaelt ausserdem Beispielcode in einer Main Funktion.  In der zweiten Aufgabe der Hausaufgabe sollte dann die Klasse Position vervollstaendigen.  Hierbei sollte die Funktion Equals und Hashcode implementieren.", "start": 132.0, "end": 157.0}, {"text": "  Die Funktion Equals erhaelt als Eingabe ein anderes Objekt vom Typ Object  und gibt ein Wahrheitswert zurueck, ob beide Objekte gleich sind.  Dazu muesst ihr zum einen ueberpruefen, ob die Objekte vom gleichen Datentyp sind  und anschliessend ueberpruefen, ob die Attribute uebereinstimmen, also zum Beispiel die x und die y Koordinate.", "start": 157.0, "end": 181.0}, {"text": "  Die Funktion Hashcode erhaelt keine Eingabe und soll den Hashwert des Position-Objekts zurueckgeben.  Ueberlegt euch hierzu, wie ihr aus den gegebenen Attributen einen eindeutigen Hashwert fuer jede Position zurueckgeben koennt.  Der genaue Hashwert ist hier nicht von Bedeutung, solange der Hashwert fuer jede Position ein anderer ist.", "start": 181.0, "end": 203.0}, {"text": "  Behaltet aber bei der Berechnung des Hashcodes fuer die Position auch die naechste Aufgabe schon einmal im Hinterkopf.  Hier soll die Klasse Board vervollstaendigt werden und zwar mit den gleichen Funktionen.  Die Equalize-Methode erhaelt auch hier wieder ein anderes Objekt vom Typ Object  und soll ein Wahrheitswert zurueckgeben, ob beide Objekte gleich sind.", "start": 203.0, "end": 221.0}, {"text": "  Und auch hier ueberpruefen wir erst mal wieder, ob die Objekte vom gleichen Datentyp sind  und dann vergleichen wir die Attribute, zum Beispiel die Roboter, auf dem Board.  Die Funktion Hashcode erhaelt auch hier wieder keine Eingabe und soll den Hashwert des Board-Objekts zurueckgeben.  Hier muss diesmal kein eindeutiger Hashwert fuer jedes Board zurueckgegeben werden.", "start": 221.0, "end": 245.0}, {"text": "  Um Kollision zu vermeiden und damit die Laufzeit zu verringern, bietet es sich allerdings an.  In Aufgabe 4 sollen dann diese Implementierung verwendet werden.  Dazu soll zuerst die Klasse Paar Schisssolution implementiert werden.  Diese benoetigt mindestens die Methode Move Sequence.  Diese erhaelt keine Eingabe und soll alle Zuege bis zur Loesungsstellung zurueckgeben.", "start": 245.0, "end": 271.0}, {"text": "  Schaut hierzu noch einmal, wie ihr Paar Schisssolution in der letzten Hausaufgabe programmiert habt.  Man kann hier auch wieder den Ansatz waehlen, Spielzuege wie in der letzten Hausaufgabe zu speichern und anschliessend zurueckzugeben.  Anschliessend soll noch die Funktion BFS with Hashing implementiert werden.", "start": 271.0, "end": 292.0}, {"text": "  Diese erhaelt als Eingabe das aktuelle Spielbrett und soll eine Loesung zu der aktuellen Spielsituation geben.  Diese Loesung ist eine Paar Schisssolution, das heisst, sie enthaelt mindestens alle Zuege bis zur Loesung.  Hierzu koennt ihr wie folgt vorgehen.  Der Basisalgorithmus, der hier angewendet wird, ist eine breiten Suche.  Wir koennen also fuer jede Spielsituation alle moeglichen Spielzuege testen.", "start": 292.0, "end": 318.0}, {"text": "  Um nun Spielsituationen nicht mehrmals zu ueberpruefen, wollen wir nur die Spielsituation ueberpruefen, die wir eben noch nicht untersucht haben.  Dazu wollen wir uns in einer Hashmap merken, welche Spielsituation wir bereits ueberprueft haben.", "start": 318.0, "end": 335.0}, {"text": " Warum machen wir das Ganze in einer Hashmap?  In einer Hashmap ist es naemlich moeglich, im konstanter Laufzeit zu bestimmen, ob wir eine Spielsituation schon ueberprueft haben oder nicht.  Das machen wir, indem wir den Hashwert einer Spielsituation berechnen und in der Hashmap ueberpruefen.  Sollten wir dort bereits ein Element finden, dann wurde diese Spielsituation schon ueberprueft, ansonsten nicht.", "start": 335.0, "end": 348.0}]}]