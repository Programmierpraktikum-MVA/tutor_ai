[{"lecture": "31624_16_course_video", "Timestamps": [{"text": "  Nachdem wir uns im ersten Video nun den Algorithmus von Dijkstra angeguckt haben,  schauen wir uns in diesem Video zum Vergleich den Algorithmus von Bellman Ford an.  Auch der Algorithmus von Bellman Ford arbeitet auf gerichteten Grafen mit Kantengewichten.  Auch er findet hier den kuerzesten Weg von einem Startknoten zu allen anderen Knoten im Grafen.", "start": 0.0, "end": 28.0}, {"text": "  Allerdings ueberpruefen wir hier in jedem Schritt die Distanz zwischen allen Knoten.  Hierbei gehen wir wie folgt vor.  Wir initialisieren erst alle Knoten, meist in einem Erre, und dann gehen wir in eine Schleife,  die die Anzahl der Knoten minus einmal durchlaeuft.", "start": 29.0, "end": 51.0}, {"text": " Innerhalb dieser Schleife gehen wir jeden Knoten einmal durch und updaten fuer jeden Knoten die Distanz zu allen Nachbarn,  wenn wir einen kuerzeren Weg zu diesen Knoten gefunden haben.", "start": 51.0, "end": 65.0}, {"text": " Nachdem wir das ganze Anzahl der Knoten minus einmal wiederholt haben,  fuehren wir das ganze noch einmal durch und wenn wir nun noch einmal die Distanz updaten muessten,  dann geben wir einen Fehler aus, denn dann haben wir einen negativen Zyklus im Grafen.  Warum das der Fall ist, schauen wir uns nachher noch mal im Detail an.  Die Initialisierung sieht hier genauso aus wie bei Dykstra.", "start": 65.0, "end": 78.0}, {"text": "  Der Startknoten hat logischerweise kein Vorgaenger und ein Abstand von Neu zum Startknoten.  Alle anderen Knoten haben auch noch kein Vorgaenger und Abstand unendlich zum Startknoten.  Auch das Update der Distanz funktioniert genauso wie bei Dykstra.", "start": 78.0, "end": 98.0}, {"text": " Falls der bisher gespeicherte Abstand vom Nachbarknoten groesser ist als der Abstand vom Knoten,  plus den Weg zwischen dem Knoten und dem Nachbarknoten,  dann pass ich sowohl den Vorgaenger auf meinen aktuellen Knoten an,  als auch den Abstand auf den Abstand vom Knoten plus den Weg zwischen Knoten und Nachbarn.  Das ganze wollen wir uns noch einmal an diesem Beispiel angucken.", "start": 98.0, "end": 116.0}, {"text": "  Auch dies koennt ihr gerne erst einmal wieder selbst probieren und anschliessend zeige ich die Loesung.  Wir wollen also nun auf diesem Grafen den Algorithmus von Bellman Ford ausfuehren.  Beginnen wir dazu, in der Nullten-Iteration alles zu initialisieren.  Der Startknoten kriegt die Distanz Null, alle weiteren Knoten kriegen die Distanz unendlich.", "start": 132.0, "end": 156.0}, {"text": "  Den Vorgaenger schreibe ich hier der Uebersichtlichkeit halber nicht mit.  Der kann aber leicht ergaenzt werden.  Ich habe hier acht Knoten im Grafen, das heisst ich muss sieben Iterationen durchfuehren.  Warum ist das der Fall?  Gucken wir uns ein sehr einfaches Beispiel fuer ein Grafen an.  Wir haben hier Knoten A, Knoten B, Knoten C, Knoten D.", "start": 156.0, "end": 184.0}, {"text": "  Das ist die einzige Moeglichkeit fuer ein Grafen mit vier Knoten,  wo der Start und der Endknoten maximal weit auseinander sind.  Diesen Kanten kann ich jetzt jeweils noch ein Gewicht geben,  das aber erst mal unrelevant gebe ich mal Kantengewicht ein.", "start": 184.0, "end": 206.0}, {"text": " Und in jedem Schritt updatee ich nun die Distanz von einem Knoten mehr,  das heisst im Schritt 1 die von B, im Schritt 2 die von C und im Schritt 3 die von D.  Das heisst in diesem Worst Case koennte man es nennen, benoetige ich Anzer der Knoten minus eine Iteration,  um auch den letzten Knoten zu updaten.  Schauen wir uns nun allerdings den Algorithmus von Bellman fort an.", "start": 206.0, "end": 225.0}, {"text": "  An der Distanz zu Knoten A wird sich nichts veraendern, diese wird immer auf 0 bleiben.  Das heisst ich ziehe hier die Nudel einmal bis zum Ende.  Nun muss ich in jeder Iteration alle Nachbarn ueberpruefen.  Fange ich mit den Nachbarn von A an.  Zu B habe ich nun ein Weg von 1 gefunden.  1 ist kleiner als unendlich, das heisst ich updatee meinen Weg.", "start": 225.0, "end": 248.0}, {"text": "  Zu C habe ich auch einen Weg gefunden, der kuerzer ist als unendlich,  nehme ich ein Weg von 3 von A aus, das heisst ich updatee auch diese Distanz.  Zu D, E, F, G und H habe ich noch keine kuerzeren Wege gefunden,  weil ich hier immer die Zeile darueber betrachte.", "start": 248.0, "end": 275.0}, {"text": " Zu B habe ich eine Distanz von unendlich, unendlich plus das Kantengewicht 1 von der Kante B zu D  ist definitiv nicht kleiner als unendlich, das heisst hier bleibt erstmal alles bei unendlich.  Nun gehen wir in die naechste Iteration.  Ich ueberpruefe auch hier erst wieder alle Nachbarn von A, hier aendert sich nichts,  das heisst das hier bleibt bei 1 und 3.", "start": 276.0, "end": 291.0}, {"text": "  Ich ueberpruefe alle Nachbarn von B, alle Nachbarn von C usw.  Alternativ kann ich natuerlich auch alle eingehenden Kanten der Knoten ueberpruefen.  Beispielsweise bei Knoten D geht die Kante von B ein.  B hat den Wert von 1 in der letzten Zeile, das heisst ich addiere die 1,2.  2 ist kleiner als unendlich, das heisst ich updatee meine Distanz.  Zu E gehen Kanten von B und C ein.", "start": 291.0, "end": 319.0}, {"text": "  B hatte letzte Iteration den Wert 1 plus die Kante 6 ergibt 7.  C hatte letzte Iteration den Wert 3 plus die Kante 1 ergibt 4.  Ich will hier das Minimum 4 und 4 ist kleiner als unendlich, das heisst ich updatee meine Distanz.  F hat eine eingehende Kante von D, D hatte in der letzten Iteration noch den Wert unendlich,  das heisst diese betrachte ich nicht weiter.", "start": 319.0, "end": 345.0}, {"text": "  G hat eine eingehende Kante von E und C, E hatte letzte Iteration noch unendlich,  das heisst diese betrachte ich nicht weiter.  C hatte allerdings letzte Iteration den Wert 3.  3 plus 4 ergibt 7, 7 ist kleiner als unendlich, das heisst ich updatee G.  Und nun schaue ich mir noch H an.  H hat eingehende Kanten von F und G.", "start": 345.0, "end": 367.0}, {"text": "  F und G hatten letzte Iteration beide den Wert unendlich, das heisst auch dieser Wert bleibt bei unendlich.  Nun schaue ich mir die naechste Iteration an.  Bei B geht nur die Kante von A ein, hier hat sich nichts geaendert, das heisst dieser Wert bleibt auf 1.  Bei C geht nur die Kante von A ein, auch hier hat sich nichts geaendert, das heisst das bleibt bei 3.", "start": 367.0, "end": 386.0}, {"text": "  Bei D geht nur die Kante von B ein, hier hat sich auch nichts geaendert, das bleibt bei 2.  Bei E geht die Kante von B und C ein, auch hier hat sich nichts geaendert, das heisst das bleibt bei 4.  Bei F geht die Kante von D ein, D hat jetzt letzte Iteration ein Wert bekommen, naemlich 2.  Das heisst ich nehme die 2 von D, addiere 2 von der Kante und komme somit auf 4.", "start": 386.0, "end": 408.0}, {"text": "  G hat eingehende Kanten von C und E.  Bei C hat sich nichts geaendert, allerdings haben wir nun ein Wert fuer E.  E erreiche ich mit 4, plus die Kante von 2 ergibt 6.  6 ist kleiner als 7, das heisst ich updatee hier meinen Wert.  H hat eingehende Kanten von F und G.  F ist in der letzten Iteration noch unendlich, G ist allerdings 7.", "start": 408.0, "end": 434.0}, {"text": "  Das heisst ich nehme den Wert von G7, addiere das Kantengewicht 2, komme auf 9 und 9 ist kleiner als unendlich.  Das heisst ich trage 9 in das Feld ein.  Nun gehen wir in die naechste Iteration.  Hier vorne wird sich wieder nichts aendern.  Dann schauen wir uns abschliessend noch H an.  Zu H fuehren 2 Kanten hin, einmal die Kante von F.", "start": 434.0, "end": 460.0}, {"text": "  F hat in der letzten Iteration den Wert 4 gehabt, plus 8 ergibt 12.  G hat in der letzten Iteration den Wert 6, plus 2 ergibt 8.  8 ist kleiner, also ist mein Wert fuer H 8.  Das Ganze muesste ich jetzt theoretisch noch bis zur Iteration 7 durchfuehren.  Allerdings wird sich hier nichts mehr weiter aendern und wir haben die kuerzesten Wege zu diesen Knoten gefunden.", "start": 460.0, "end": 486.0}, {"text": "  Doch wenn das Ergebnis von Bellman und Ford und Dijkstra das gleiche ist,  warum machen wir uns dann die Muehe und fuehren diese ganzen Iterationen aus?  Das Ganze sehen wir, wenn wir dieses Beispiel einmal mit dem Algorithmus von Dijkstra  und einmal mit dem Algorithmus von Bellman Ford loesen.  Probiert das gerne erst einmal selbst und schaut, ob euch dabei etwas auffaellt.", "start": 486.0, "end": 506.0}, {"text": "  Ueberlegt dann auch, ob sich eine Regel daraus ableiten laesst.  Anschliessend zeige ich die Loesung.  Beginnen wir damit, dieses Beispiel noch einmal mit Dijkstra zu loesen.  Wir haben hier wieder den Startknoten a und beginnen damit, die direkten Nachbarn von a zu ueberpruefen.", "start": 506.0, "end": 552.0}, {"text": " Zu b haben wir nun einen Weg gefunden, der 3 lang ist und von Knoten a aus kommt  und zu c haben wir einen Weg gefunden, der 2 lang ist und von Knoten a aus kommt.  Als naechstes schauen wir uns den Knoten mit der geringsten Distanz zum Startknoten an, den wir noch nicht besucht haben.  Das ist in dem Fall Knoten c. Das heisst, Knoten c sollte nun abgearbeitet sein.", "start": 552.0, "end": 572.0}, {"text": "  Ich schaue mir nun alle direkten Nachbarn von c an. Zum einen habe ich hier den Knoten f,  diesen erreiche ich nun mit einer Distanz von 5, von Knoten c aus und den Knoten g,  diesen erreiche ich mit einer Distanz von 4, von Knoten c aus.  Nun schaue ich mir den naechsten Knoten mit der geringsten Distanz zum Startknoten an.", "start": 572.0, "end": 595.0}, {"text": "  Das ist in dem Fall Knoten b. Das heisst, auch Knoten b sollte ich nun fertig abgearbeitet haben.  Ich schaue mir hier nun alle direkten Nachbarn von b an.  Knoten d erreiche ich mit einer Distanz von 7, von Knoten b aus  und Knoten e erreiche ich mit einer Distanz von 6, auch von Knoten b aus.  Allerdings erreiche ich auch Knoten c mit einer Distanz von 1, von Knoten b aus.", "start": 595.0, "end": 624.0}, {"text": "  Wir sehen schon, das fuehlt hier zu einem Problem.  Wir haben naemlich angenommen, der Knoten c waere schon fertig abgearbeitet.  Allerdings haben wir nun einen kuerzeren Weg gefunden.  Dieser Knoten ist also offensichtlich noch gar nicht fertig abgearbeitet  und wir muessen nun erneut seine Nachbarn untersuchen.  Wir folgen hierbei dem Pseudokot aus dem Skript.", "start": 624.0, "end": 649.0}, {"text": "  Beachtet allerdings auch, dass der Algorithmus nach dieser Implementierung kein greedy Algorithmus mehr ist.  Wir haben naemlich zuvor schon angenommen, dass wir zu Knoten c den kuerzesten Weg gefunden haben.  Diese Annahme hat sich im Nachhinein als falsch rausgestellt, wir muessen also nochmal den Knoten untersuchen.  Das bedeutet auch, wir muessen jetzt erneut seine Nachbarn untersuchen.", "start": 649.0, "end": 671.0}, {"text": "  Zu Knoten f haben wir jetzt einen Weg von 4 gefunden, auch von Knoten c aus  und zu Knoten g ein Weg von 3 auch von Knoten c aus.  Nun schauen wir uns den Knoten mit der naechsten kleinsten Distanz an.  Das ist hier Knoten g.  Wir nehmen also auch hier wieder an, dass wir hier den kuerzesten Weg zu diesem Knoten gefunden haben.", "start": 671.0, "end": 692.0}, {"text": "  Da g keine weitere Nachbarn mehr hat, muessen wir hier auch nichts weiter untersuchen.  Als naechsten Knoten untersuchen wir Knoten f.  Das heisst auch hier gehen wir nun davon aus, wir haben den kuerzesten Weg zu diesem Knoten gefunden  und untersuchen jetzt noch seine Nachbarn.  Sein Nachbar ist nur g, g erreiche ich nun mit einer Distanz von 2, von Knoten f aus.", "start": 693.0, "end": 718.0}, {"text": "  Das heisst auch fuer Knoten g habe ich eigentlich noch gar nicht die optimale Distanz gefunden.  Nun muesste ich als naechstes wieder Knoten g untersuchen.  Da Knoten g allerdings keine Nachbarn mehr hat, ist dieser Knoten fertig abgearbeitet.  Schauen wir uns als naechstes den Knoten mit naechster kleinsten Distanz an.  Das ist hier Knoten e.", "start": 718.0, "end": 738.0}, {"text": "  Ich gehe also davon aus, zu Knoten e habe ich schon den kuerzesten Weg gefunden  und untersuche jetzt noch die Nachbarn.  Der Nachbar ist nur Knoten f.  Ich finde allerdings ein kuerzeren Weg zu Knoten f, in dem Fall ein Weg von 3, von e aus.  Das heisst auch hier lag ich falsch mit der Annahme, dass ich bereits den optimalen Weg gefunden habe.", "start": 738.0, "end": 764.0}, {"text": "  Da ich nun Knoten f aktualisiert habe, muss ich nun auch nochmal die Nachbarn von Knoten f aktualisieren, in dem Falle also g.  Zu g habe ich naemlich nun einen Weg gefunden, der nur eins lang ist von Knoten f aus.  Nun muesste ich mir auch nochmal die Nachbarn von Knoten g anschauen, allerdings hat Knoten g wie gesagt keine Nachbarn.", "start": 764.0, "end": 783.0}, {"text": "  Nun schaue ich mir den Knot mit naechster kleinsten Distanz zum Startknoten an, das ist Knoten d.  Ich gehe also auch hier wieder davon aus, dass ich den kuerzesten Weg zu d gefunden habe.  Ich ueberpruefe nun noch seine Nachbarn, das ist nur Knoten e, allerdings finde ich ein kuerzeren Weg zu Knoten e,  mit der Laenge 5, von Knoten d aus.", "start": 783.0, "end": 805.0}, {"text": "  Das heisst, auch fuer Knoten e habe ich zuvor eigentlich gar nicht die kuerzeste Distanz gefunden.  Als Reaktion darauf muss ich nun auch nochmal Knoten f updaten.  Zu Knoten f habe ich naemlich nun einen Weg gefunden, der zwei lang ist, wenn ich von Knoten e komme.", "start": 805.0, "end": 827.0}, {"text": "  Und als Reaktion darauf muss ich nun auch nochmal den Nachbar Knoten g updaten, denn ich habe nun einen Weg gefunden, der null lang ist, wenn ich von Knoten f komme.  Wir sehen also, mit der entsprechenden Dykstra-Implementierung kommen wir auch hier zum Ziel.  Allerdings muessen wir viele Knoten mehrfach besuchen und der Algorithmus findet nicht mehr nach dem Greedy-Prinzip die optimale Loesung.", "start": 827.0, "end": 845.0}, {"text": "  Das liegt daran, dass wir hier negative Kanten in unserem Grafen haben.  Sobald wir negative Kanten in unserem Grafen haben, laesst sich Dykstra nicht mehr effizient als Greedy-Algorithmus einsetzen.  Stattdessen koennen wir den Algorithmus von Bellman-Ford verwenden.  Schauen wir uns das gleiche Beispiel also noch einmal mit dem Bellman-Ford-Algorithmus an.", "start": 845.0, "end": 878.0}, {"text": "  Auch hier finde ich im ersten Schritt ein Weg zu B mit Distanz 3 von A aus und ein Weg der Laenge 2 zu C von A aus.  In der naechsten Interaktion finde ich dann zu D ein Weg von B mit Laenge 7, ein Weg zu E mit Laenge 6,  einen Weg von C aus zu F, einen Weg von C aus zu F mit Laenge 5 und einen Weg von C zu G mit Laenge 4.  Ausserdem finde ich allerdings nun auch ein Weg von B zu C mit Laenge 1.", "start": 878.0, "end": 910.0}, {"text": "  Nun kann ich die naechste Interaktion von Updates durchfuehren.  Fuer Knoten D aendert sich nichts.  Knoten E kann ich nun allerdings auch von Knoten D aus erreichen mit einem Kantengewicht von minus 2.  Das heisst ich habe nun eine kuerzere Distanz gefunden von 5, indem ich von Knoten D komme.  Nun schaue ich mir als naechstes den Knoten F an.  F muss jetzt dem Fad von C aus und von E aus vergleichen.", "start": 910.0, "end": 941.0}, {"text": "  Von C aus habe ich jetzt eine neue Distanz, weil jetzt Knoten C die Distanz von 1 hat und zwar insgesamt Distanz 4.  Von Knoten E aus habe ich aus der letzten Interaktion noch Distanz 6, minus 3 ergibt 3.  3 ist kleiner als meine bisherige Distanz, das heisst ich waehle diese.  Und Knoten G erreiche ich von C oder F.", "start": 941.0, "end": 961.0}, {"text": "  C hat den Wert 1 aus der letzten Interaktion, plus 2 ergibt 3, das ist schon mal kuerzer.  Knoten F hat den Wert 5 aus der letzten Interaktion, minus 2 ergibt 3, das heisst ich habe 2 Pfade mit Laenge 3 zu Knoten G.  Ich kann mich hier also einen aussuchen.  Ich waehle hier zum Beispiel den von Knoten F aus.", "start": 961.0, "end": 984.0}, {"text": "  Nun kann ich in der naechsten Interaktion fuer Knoten F den aktualisierten Wert von E verwenden.  E hat naemlich jetzt nicht mehr den Wert 6, sondern den Wert 5.  Somit aendert sich hier auf die Distanz 3 auf Distanz 2 weiterhin von E aus.  In dieser Interaktion kann ich dann auf den Wert von G anpassen.  F hat jetzt naemlich nicht mehr den Wert 5, sondern Wert 3.", "start": 984.0, "end": 1006.0}, {"text": "  Das heisst ich komme insgesamt auf eine Distanz von 1 von Knoten F aus.  In der naechsten Interaktion kann ich dann erneut den aktualisierten Wert von F verwenden.  Dieser ist jetzt naemlich nicht mehr 3, sondern 2.  2 minus 2 ergibt 0 ist also kleiner als 1, deshalb aktualisiere ich mein Wert.  Diese Zwischenschritte der Interaktion muesst ihr nicht zwangslaeufig mitschreiben.", "start": 1006.0, "end": 1034.0}, {"text": "  Eine ausreichende Loesung waere hier 5 von Knoten C aus und 2 von Knoten E  und entsprechend auf der anderen Seite 3 von Knoten C aus und 0 von Knoten F.  Allerdings hat auch der Algorithmus von Bellman fort eine Einschraenkung.  Dieser laesst sich naemlich nicht auf Grafen anwenden, die einen negativen Zyklus haben.", "start": 1034.0, "end": 1063.0}, {"text": " Ein negativer Zyklus bedeutet, wenn ich eine beliebige Anzahl von Knoten habe,  die ueber ein Zyklus miteinander verbunden sind, ich mache hier einmal ein sehr einfaches Beispiel mit 3 Knoten,  und ich nun alle Kandengewichte dieser Kanten addiere, dann muss die Summe groesser gleich 0 sein.", "start": 1064.0, "end": 1081.0}, {"text": " Waere die Summe kleiner als 0, dann koennte der Algorithmus beliebig in diesem Zyklus laufen  und somit die Laenge des Pfades immer weiter verringern.  Der Algorithmus wuerde somit nie zu einem vernuenftigen Ergebnis kommen.", "start": 1081.0, "end": 1098.0}, {"text": " Um einen negativen Zyklus zu erkennen, gibt es im Bellman fort Algorithmus,  wie bereits zuvor erwaehnt, den einen Schritt nach der Schleife, wo man erneut ueberprueft,  ob sich die Distanz der Knoten updaten wuerde.  Ist das der Fall, haben wir einen negativen Zyklus im Grafen.", "start": 1098.0, "end": 1112.0}, {"text": " Zusammenfassend kann man also sagen, dass sich Dijkstra auf alle Probleme anwenden laesst,  wo keine negativen Kandengewichte vorkommen, beispielsweise wenn man eine Landkarte hat,  auf der man Distanzen zwischen Knoten hat, diese koennen nie negativ sein,  oder wenn wir zu unserem Beispiel mit dem S-Bahn-Netz zurueckkehren,  da hier die Fahrzeit zwischen zwei Stationen auch nicht negativ sein kann.", "start": 1112.0, "end": 1129.0}, {"text": "  Hab ich allerdings negative Kanten in meinem Grafen, so kann ich den Algorithmus von Bellman fort anwenden.  Befinden sich negative Zyklen in meinem Grafen, so kann ich keine der beiden Algorithmen anwenden,  um einen kuerzesten Weg in meinem Grafen zu finden.  Im Skript wurde noch eine weitere Implementierung vorgestellt.  Diese verwendet eine Q.", "start": 1129.0, "end": 1151.0}, {"text": "  Auch diese Implementierung moechte ich euch nun abschliessend einmal vorstellen.  Beginnen tun wir hier damit, den Startknoten in die Q einzufuegen, in dem Falle also Knoten A.  In jeder Iteration beginnen wir nun damit, den obersten Knoten aus der Q zu entfernen  und fuer alle Seiten Nachbarn zu ueberpruefen, ob man die Distanz updaten muss.", "start": 1151.0, "end": 1172.0}, {"text": "  Die Nachbarn gehen wir auch hier wieder in alphabetischer Reihenfolge durch.  Ist es moeglich, die Distanz zu einem Nachbarn zu updaten, so fuegen wir diesen wieder in die Q hinzu,  sofern er noch nicht in der Q steht, und updaten seine Distanz und sein Vorgaenger.  In der ersten Iteration nehmen wir also Knoten A aus der Q und schauen uns alle Nachbarn von Knoten A an.", "start": 1173.0, "end": 1192.0}, {"text": "  Das sind hier Knoten B und C.  Ich habe zu beiden Knoten eine kuerzere Distanz gefunden.  Den Knoten B erreiche ich nun mit einer Distanz von 3 von Knoten A aus  und Knoten C mit einer Distanz von 2 auch von Knoten A aus.  Da ich die Distanz zu beiden Nachbarn updaten konnte, muss ich auch beide der Q hinzufuegen.  In der naechsten Iteration wird dann Knoten B aus der Q entfernt.", "start": 1192.0, "end": 1219.0}, {"text": "  Knoten B hat 3 Nachbarn.  Ich ueberpruefe also wieder fuer alle 3 Nachbarn, ob ich die Distanz zu ihnen updaten kann.  Zu Knoten C habe ich nun einen kuerzeren Weg gefunden, der Laenge 1, wenn ich ueber Knoten B gehe.  Zu Knoten D habe ich nun einen Weg der Laenge 7 gefunden, wenn ich von Knoten B auskomme.  Und zu Knoten E habe ich nun einen Weg der Laenge 6 gefunden, wenn ich von Knoten B auskomme.", "start": 1219.0, "end": 1249.0}, {"text": "  Knoten C befindet sich schon in der Q, das heisst den muss ich nicht erneut hinzufuegen,  allerdings muss ich noch die Knoten D und E der Q hinzufuegen.  Nun hole ich als naechstes Knoten C aus der Q, das heisst ich schaue mir alle Nachbarn von Knoten C an.  Das sind hier Knoten F und G.  Zu F habe ich nun einen Weg der Laenge 4 gefunden, wenn ich von Knoten C auskomme.", "start": 1249.0, "end": 1274.0}, {"text": "  Und zu Knoten G habe ich nun einen Weg der Laenge 3 gefunden, wenn ich von Knoten C auskomme.  Knoten D und E bleiben in der Q stehen, Knoten F und G fuege ich der Q hinzu.  Nun hole ich als naechstes Knoten D aus der Q.  Knoten D hat nur den Nachbarn E, das heisst ich schaue, ob ich die Distanz von Nachbar E updaten kann.", "start": 1274.0, "end": 1301.0}, {"text": " Ich habe hier eine Distanz gefunden, die Laenge 5 fahrt, 5 ist kleiner als 6,  das heisst ich update meine Distanz und den Vorgaengerknoten.  E muss ich nicht erneut der Q hinzufuegen, denn E steht bereits in der Q  und F und G bleiben genauso in der Q stehen.  Als naechstes schaue ich mir den Knoten E an.  E hat nur den Nachbarn F.", "start": 1301.0, "end": 1323.0}, {"text": "  Zu F habe ich nun auch eine kuerzere Distanz gefunden, und zwar von Laenge 2 von Knoten E aus.  G steht allerdings schon in der Q, das heisst hier muss ich nichts weiter unternehmen.  Nun hole ich noch Knoten G aus der Q, G ist auch nicht erneut der Q hinzufuegen,  denn F steht schon in der Q und G bleibt auch weiterhin in der Q stehen.  Als naechstes schaue ich mir Knoten F an.", "start": 1323.0, "end": 1347.0}, {"text": "  F hat nur den Nachbarn G, zu G habe ich nun auch einen kuerzeren Weg gefunden,  und zwar der Laenge 0 von Knoten F aus.  Knoten G aus der Q, G hat keine weitere Nachbarn mehr,  das heisst auch hier muss ich nichts weiter untersuchen, die Q ist leer und mein Algorithmus terminiert.  Ich habe euch hier somit drei verschiedene Implementierungen des Bellman Fort Algorithmus praesentiert.", "start": 1347.0, "end": 1371.0}, {"text": "  Wenn euch die Unterschiede interessieren, dann ueberlegt doch einmal,  welches die Best- und Wurstcase-Laufzeit jeder Implementierung, die ich hier praesentiert habe, ist.  Im Endeffekt kommen allerdings alle drei zum gleichen Ergebnis.", "start": 1371.0, "end": 1382.0}]}]