[{"lecture": "31624_51_course_video", "Timestamps": [{"text": "  Nun benutzt man nicht immer nur eine Klasse und wenn mehrere Klassen miteinander interagieren,  zum Beispiel von einander Erben, spielen die vier Konzepte, die ich vorhin kurz aufgezaehlt habe,  eine grosse Rolle. Naemlich die Datenkapselung, die Vererbung, die Generalisierung und die Polymorphie.  Wir fangen jetzt mit der Datenkapselung an.", "start": 0.0, "end": 31.0}, {"text": "Die Zukunftsmodifizierer sind zum Teil ja auch  im letzten Beispiel aufgetaucht. Kurz zum Verstaendnis. Ein Package sind alle Klassen, die in einem Verzeichnis liegen.  Package ist der Defaultmodifizierer, das, was gilt, wenn nichts angegeben ist.  Dabei haben alle anderen Klassen aus dem gleichen Package Zugriff auf die derartig deklarierten Variablen und Methoden.", "start": 31.0, "end": 49.0}, {"text": "  Allgemein gesagt geht es also um die Sichtbarkeit der deklarierten Variablen und Methoden.  Protected erlaubt den gleichen Zugriff wie Package, aber zusaetzlich auch noch den Zugriff aus Unterklassen der Klasse,  auch wenn sie in einem anderen Verzeichnis liegen, in einem anderen Paket.", "start": 50.0, "end": 70.0}, {"text": "  Private und Public sind die beiden Extreme, wobei bei Private nur aus der Klasse selbst auf die Variablen und Methoden zugriffen werden kann  und bei Public von ueberall. Beides haben wir uns im letzten Beispiel bereits angeschaut.  Fuer alle Teile der Klasse, deren Zugriff beschraenkt ist, laesst sich der Zugriff ueber oeffentlichen Methoden gezielt steuern.", "start": 70.0, "end": 88.0}, {"text": "  Ein Beispiel sind die Getter & Setter Methoden, ueber die wir schon gesprochen haben. Das hat mehrere Vorteile.  Zum einen koennen Variable nicht veraendert werden in Arsch und Weisen, die nicht vorgesehen sein wuerden.  Zum anderen haelt sich der Effekt von Veraenderungen in Grenzen, wenn man auf Zugriffbeschraenken Variablen oder Methoden etwas aendert.", "start": 88.0, "end": 109.0}, {"text": "  Dann muss das nur in der jeweiligen Klasse selbst bzw. in dem Package oder in den Unterklassen angepasst werden und nicht ueberall, wo man die Methode haette auffuchen koennen.  Die Veraenderung hat also besonders bei Private einen lokalisierten Effekt.  Nun haben wir ja gerade Unterklassen schon angesprochen, also schauen wir uns nun die Verabungen einmal genauer an.", "start": 109.0, "end": 130.0}, {"text": "  Das Prinzip ist einfach. Eine Klasse kann ihre Attributo- und Methoden an eine andere weitergeben, vererben.  Es gibt nur fuer sichtbare Variablen, also je nachdem, in welchem Paket die abgeleitete Klasse ist, fuer Package, Protected oder Public.  Die abgeleitete Klasse wird auch Unterklasse oder Subklasse genannt. Die Klasse von der abgeleitet wird, wird Oberklasse oder Superklasse gelernt.", "start": 130.0, "end": 153.0}, {"text": "  Fuer das bessere Verstaendnis schauen wir uns hier das Beispiel an, welches wir auch gleich implementieren werden.  Wirbeltiere.  Die Klasse Kegelrobe kennen wir schon. Sie gehoert zu der Klasse der Saeugetiere, welche wiederum von der Klasse der Wirbeltiere erbt.  Das Stichwort im Code dafuer ist Extens, zum Beispiel Klaas, Saeugetiere, Extens, Wirbeltiere.", "start": 153.0, "end": 178.0}, {"text": "  Dann erbt die Klasse Saeugetiere alle Eigenschaften und Verhaltensweisen, die fuer sie sichtbar sind, von der Klasse Wirbeltiere.  Es sind also nun auch die Eigenschaften der Klasse Saeugetiere.  Dabei waere jetzt Wirbeltiere die Oberklasse und Saeugetiere die Unterklasse.", "start": 178.0, "end": 198.0}, {"text": " Man kann jetzt zum Beispiel fuer die Kegelroben eine Methode aufrufen, die urspruenglich fuer Wirbeltiere definiert ist,  weil die Kegelrobe ueber die Klasse Saeugetiere von Wirbeltiere erbt.  Das beugte Doppelungen im Code vor.  Beispielsweise stellt es sich sicher, dass man Veraenderungen an einer Methode, die vererbt wird, nicht in jeder Klasse einzeln vorn nehmen muss.", "start": 198.0, "end": 210.0}, {"text": "  Plaetzteres ist typischerweise sehr fehleranfaellig.  Man sollte Doppelungen im Code allgemein vermeiden.  Nun kann man sich diesen Klassenbaum ja nicht nur von oben nach unten anschauen, sondern auch andersherum.  Dann betrachtet man in jeder hoeheren Ebene eine Verallgemeinerung, Generalisierung der Vorherrigen.", "start": 210.0, "end": 236.0}, {"text": "  Wir legen nun dabei ein besonderes Augenmerk auf Obstrakte-Klassen und Interfaces, denn aus beiden kann nicht direkt ein Objekt instanziert werden.  Ausserdem lassen sowohl Obstrakte-Klassen als auch Interfaces das Implementieren von abstrakten Methoden zu, ueber die wir jetzt zuerst sprechen.", "start": 236.0, "end": 255.0}, {"text": "  Eine abstrakte Methode ist eine nicht ausprogrammierte Methode, eine Methode, die angelegt ist in ihrer Signatur, aber keinen Rumpf hat, keine Implementation.  Nehmen wir die Methode Essen, die wir gerade geschrieben haben fuer die Klasse Kegelrobbe.  Wirbeltiere essen auch. Es wuerde also Sinn ergeben, diese Methode fuer Wirbeltiere anzulegen und zu vererben.", "start": 256.0, "end": 271.0}, {"text": "  Allerdings essen auch viele Wirbeltiere viele unterschiedliche Dinge.  Um dies zu programmieren, gibt es zwei Moeglichkeiten.  Zum einen koennte man die Methode in jeder Subklasse ueberschreiben.  Dann muesste man sich trotzdem fuer Wirbeltiere eine Implementation ausdenken.  Zum anderen koennte man eine Methode anlegen, aber nicht implementieren.", "start": 271.0, "end": 289.0}, {"text": "  Das ist die zweite Moeglichkeit, eine abstrakte Methode.  Abstrakte Methoden koennen nur in Obstrakten-Klassen oder Interfaces implementiert werden.  Das heisst auch, dass eine Klasse abstrakt sein muss, soweit eine abstrakte Methode in ihr enthalten ist.", "start": 289.0, "end": 309.0}, {"text": " Wenn eine Klasse, die nicht abstrakt ist, wenn aber das Interface implementiert oder von der Abstrakten-Klasse erbt,  muss darin die Methode dann explizit implementiert werden.  In unserem Beispiel muessten dann, wenn Wirbeltiere eine abstrakte Klasse ist,  entweder Saeugetiere und Reptilien auch abstrakte Klassen sein,  oder wir muessten die Methode essen, in diesen beiden Klassen implementieren.", "start": 310.0, "end": 329.0}, {"text": "  Durch diese Abstrakten-Methode kann es aber fuer abstrakte Klassen und Interfaces  keine konkreten Objekte geben.  Wir haben ja gegebenenfalls keine vollstaendig definierten Verhaltensweisen im Gegensatz zu normalen Klassen.  Objekte koennen dann nur fuer die entsprechenden Subklassen installiert werden.  Interfaces gehen aber noch einen Schritt weiter.", "start": 329.0, "end": 352.0}, {"text": "  Gehen wir davon aus, dass man gerne zwei oder mehr Oberklassen in einer Unterklasse zusammenfuellen will.  Mehrfach Veraerbung sozusagen.  Das ist in Java aber nicht moeglich, auch nicht fuer Abstrakte-Klassen.  Es gibt fuer jede Unterklasse nur genau eine Oberklasse.  Diese Funktionalitaet bietet stattdessen Interfaces.", "start": 352.0, "end": 370.0}, {"text": "  Eine Klasse kann zwar nur eine Oberklasse-Exzente, aber mehrere Interfaces implementieren.  Das Stichwort dafuer ist Implements.  In unserem heutigen Beispiel gehen wir aber nur auf abstrakte Klassen ein.  Deswegen belassen wir es jetzt dabei und ruecken uns den letzten Konzept auf unserer Liste, der Polymorphie.  In der Vorlesung werden drei unterschiedliche Arten von Polymorphismus auch befuehrt.", "start": 370.0, "end": 393.0}, {"text": "  Der Adhoc Polymorphismus, der Subtyp Polymorphismus und der Parametrische Polymorphismus.  Polymorphie heisst erstmal nur, dass eine Methode oder ein Operator kontextabhaengig fuer verschiedene Datentueten funktioniert  und dann aufgegebenenfalls verschiedene Sachen macht, woertlich viele Formen anbind.  Zwei Varianten habe ich schon angesprochen.", "start": 394.0, "end": 417.0}, {"text": "  Einmal koennen wir vererbte Methoden ueberschreiben und haben dann je nach Kontext, also auf welchem Objekt die Methode aufgerufen wird,  eine angepasste Funktion, trotz gleicher Signaturen.  Die andere ist das Implementieren von Abstraktenmethoden in Unterklassen.  Das sehen wir gleich nochmal.  Ausserdem koennen durch die Vererbung Unterklassen den Typ ihrer Oberklasse angehen.", "start": 417.0, "end": 433.0}, {"text": "  Das waere dann Subtyp Polymorphismus.  Der Adhoc Polymorphismus bezeichnet einfach das Ueberladen von Operatoren und Methoden  mit unterschiedlichen Signaturen fuer unterschiedliche Datentypen als Parameter.  Ausserdem kann man in Java mit Generics arbeiten.  Die kann man sich als eine Art Platzhalter fuer Datentypen vorstellen,  sodass Methoden und Datentypen Argumente variablen Types haben koennen.", "start": 434.0, "end": 456.0}, {"text": "  Darauf gehen wir hier aber nicht genauer ein.  Nachdem wir jetzt alles theoretische Kurz beleuchtet haben,  werden wir einmal unser Wirbeltierbeispiel implementieren  und dann koennen Sie die unterschiedlichen Konzepte im Idealfall einfach einmal selbst ausprobieren.  Wir beginnen mit der Klasse Wirbeltiere.", "start": 457.0, "end": 478.0}, {"text": "  Wir werden alle Klassen so klein wie moeglich halten und auch erst mal im nicht abstrakten Setting anfangen.  Dazu kommen wir dann spaeter.  Wir haben hier also unsere Klasse.  Als Attribut ist ein Boolean gewaehlt,  weil es jetzt speichert, ob ein Tier an Land lebt oder nicht.  Im Konstruktor wird das Attribut als Parameter uebergeben und zugesiesen.", "start": 478.0, "end": 496.0}, {"text": "  Das soll uns als Superklasse auch erst mal reichen  und dann erstellen wir jetzt naechste Klasse, Saeugetieren.  Wie Sie sehen, wird einem hier auch direkt als zweites an Interface vorgeschlagen.  Das wollen wir aber gerade nicht.  So, nun wollen wir ja, dass die Klasse von Wirbeltiere erbt.  Also kommt hinter den Klassennamen ein Extenz Wirbeltiere.", "start": 496.0, "end": 522.0}, {"text": "  Das ist jetzt erst mal noch unterkringelt, weil wir den Konstruktor noch nicht geschrieben haben.  Bevor wir das beheben, legen wir aber noch die Fellfarbe als Attribut fest.  Fuer den Konstruktor muessen wir dann sowohl die Fellfarbe als auch das Boolean lebte an Land uebergeben,  da man hier keine pauschale Aussage fuer alle Saeugetiere treffen kann.  Diese muessen also gesetzt werden.", "start": 522.0, "end": 541.0}, {"text": "  Als erstes rufen wir dann den Superkonstruktor auf.  Da wir aber in der Oberklasse einen parametrisierten Konstruktor haben,  uebergeben wir so den Parameter an den Konstruktor der Oberklasse.  Der Konstruktor wuerde auch sonst immer aufgrufen, selbst wenn er nicht explizit dasteht.  Dann setzen wir das Attribut und sind mit der Klasse erst mal fertig.", "start": 542.0, "end": 565.0}, {"text": "  Zu Uebung koennten Sie hier eine Main-Methode schreiben und Objekte beider Klassen erstellen.  Ausserdem koennen Sie an dieser Stelle einmal ausprobieren,  was passiert, wenn die Oberklasse kein Parameter in den Konstruktor nehmen wuerde  und wie die Klasse Saeugetiere dann aussehen kann.  Im Video gehen wir jetzt weiter mit den beiden Unterklassen von Saeugetiere.", "start": 565.0, "end": 582.0}, {"text": "  Die Kegelrobber haben wir schon geschrieben.  Das passen wir dann gleich noch an und schreiben jetzt die Klasse Rotnacken-Wolubi.  Diese bekommt nur einen Konstruktor.  Wir koennen die Klasse zu Uebungen gerne erweitern,  so wie wir es mit der Klasse Kegelrobbe bereits gemacht haben.", "start": 582.0, "end": 603.0}, {"text": " Auch in dieser Klasse definieren wir die Erbschaften mit Saeugetiere  und rufen dann im Konstruktor den Superkonstruktor auf  und setzen darin die Fellfarbe auf Rot und das Kaengero auf an Landlebend.  Um diese beiden Sachen erweitern wir jetzt auch die Klasse Kegelrobbe.  Um fuer etwas mehr Abwechslung zu sorgen, tun wir mal so,  es wuerde sie nicht an Land leben und setzen die Fellfarbe auf weiss.", "start": 603.0, "end": 627.0}, {"text": "  Wie sie fuer sehr junge Kegelroben stimmt.  Eigentlich sind weibliche Kegelroben braun und maennliche grau gepfleckt.  Um das umzusetzen braeuchte man hier ein neues Attribut Geschlecht  und koennte dann die Fellfarbe entsprechend dem Geschlecht setzen.  Das sollten Sie zur Uebung hier einmal ausprobieren.  Bedenken Sie, dass der Aufruf super immer an erster Stelle im Konstruktor kommen muss.", "start": 627.0, "end": 652.0}, {"text": "  Das gleiche Prinzip wiederholen wir nun noch fuer die Reptilien.  Am besten pausieren Sie hier das Video und probieren es einmal alleine.  Reptilien erbt von Wirbeltiere und Attribut haben wir gewaehlt,  ob das Reptil giftig ist oder nicht.  Wenn das jetzt bei Ihnen auch so aussieht, sollte es funktionieren.  Zu guter Letzt erstellen wir noch die Klasse Kreuzotter.", "start": 652.0, "end": 674.0}, {"text": "  Und die Kreuzotter ist giftig und lebt an Land.  Die Klasse sieht dann so aus.  Wir brauchen keine Parameter fuer den Konstruktor,  sondern setzen die Parameter fuer den Superkonstruktor fest.  Jetzt testen wir erstmal, ob unser Baum von Klassen auch so funktioniert,  wie wir uns das vorstellen und schreiben eine Main-Methode in die Wirbeltier-Klasse.", "start": 674.0, "end": 695.0}, {"text": "  In der Main erstellen wir zunaechst ein Area von Wirbeltieren.  Das funktioniert nach dem gleichen Prinzip wie in der Klasse Kegerobe.  Man benutzt den New-Operator und gibt am Ende die Dimension an.  Dann muessen die einzelnen Tiere noch instanziert werden.  Ein Rotnackenurnebis, die Kegerobe Paula und eine Kreuzotter.", "start": 695.0, "end": 718.0}, {"text": " Da alle drei Klassen von der Klasse Wirbeltiere erben,  ist es kein Problem, den Area der Oberklasse mit Exemplaren der Unterklassen zu fuellen.  In einer Vorschleife geben wir uns dann aus, ob die jeweiligen Tiere an Land leben oder nicht.  Die Vorschleife itiriert wie vorhin ueber die Objekte des Areas direkt anstatt mit dem Index zu arbeiten.", "start": 718.0, "end": 736.0}, {"text": "  Dann fuehren wir die Main aus und erhalten True, Fort, True, soweit so gut.  Wir schauen uns jetzt an einem Beispiel an, wie der Zugriff auf die unterschiedlichen Variablen eingeschraenkt ist,  vor allem auf den unterschiedlichen Ebenen der Vererbung.  Man koennte zum Beispiel schauen, was passiert, wenn man lebt an Land Private macht.  Wir schauen uns wieder unsere Klasse Kegerobe an.", "start": 736.0, "end": 761.0}, {"text": "  Wir wissen, dass der Areae Tiere am Index 1 ein Objekt der Klasse Kegerobe hat.  Wir haben es ja gerade zugewiesen.  Man kann also theoretisch dafuer die GetName-Methode von vorhin aufrufen.  Die gibt es aber nicht, weil sich Oberklassen und nicht automatisch auf Unterklassen einschraenken  und wir einen Areae von Wirbeltieren haben.  In der Klasse Wirbeltiere gibt es diese Methode nicht.", "start": 761.0, "end": 785.0}, {"text": "  Wir koennten aber von der Klasse Wirbeltiere aus casten in die Klasse Kegerobe,  weil wir ja wissen, dass es eigentlich eine Kegerobe ist.  Dafuer definieren wir eine Kegerobe P und weisen ihr Tiere am Index 1 zu  und casten diese zu Kegerobe, indem wir es in Klammern davor schreiben.  Dann wird mir auch fuer P direkt GetName angeboten.  Dann fuehren wir die Main aus und erhalten Paula.", "start": 785.0, "end": 811.0}, {"text": "  Das stimmt. Das hat also geklappt.  Man sollte beim Casten immer sehr genau aufpassen, dass man weiss,  dass das jeweilige Objekt auch von dieser Unterklasse ist.  Wir koennen hier einmal ausprobieren, ob sie fuer die Kegerobe P auf das Atempunkt lebt  an Landzugriff haben und sich dann ueberlegen, warum das so ist.  Wir passen jetzt die Klasse etwas an und machen eine abstrakte Klasse daraus.", "start": 811.0, "end": 836.0}, {"text": "  Wir wollen unsere Methode essen, vererben, aber noch nicht implementieren.  Deshalb schreiben wir jetzt eine abstrakte Methode Public Abstract Essen  ohne Methodenrunde und fuegen in der Klasse Bezeichnung das Abstract ein.  Diese Methode essen implementieren wir jetzt jeweils fuer Kreuzotter  und Rotnackenvolleblie. Fuer die Kegerobe ist sie ja bereits fertig.", "start": 836.0, "end": 860.0}, {"text": "  Und jetzt fuegen wir den Methodenaufruf in unsere Vorschleife ein  und fuehren die Main Methode aus und bekommen einen dicken Pferd.  Warum?  Nun, wenn wir uns noch einmal unser Diagramm angucken, haben wir die gesamte mittlere Ebene ausgelassen.  Wir hatten aber gesagt, dass eine Unterklasse eine Abstraktentasse entweder die Abstraktenmethoden  implementieren muss oder selbst abstrakt sein muss.", "start": 860.0, "end": 885.0}, {"text": "  Genau wie es auch in der schoenen Fehlermeldung hier unten steht.  Da wir aber ueber das Essverhalten von Saeugetieren und Reptilien  in etwa genauso genaue Aussagen treffen koennen wie ueber das von Woebeltieren,  lassen wir das mit dem Implementieren sein und machen sie auch zu Abstraktenklassen.", "start": 886.0, "end": 904.0}, {"text": " Dann fuehren wir unsere Main nochmal aus und bekommen fuer jedes der Tiere  eine andere Auskunft ueber sein Essen.  Die Methode hat also kontextabhaengig Verhalten angepasst und ist damit Polymorph.", "start": 904.0, "end": 909.0}]}]