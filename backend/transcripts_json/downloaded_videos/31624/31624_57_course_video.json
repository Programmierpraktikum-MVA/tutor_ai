[{"lecture": "31624_57_course_video", "Timestamps": [{"text": "  Nachdem wir nun die ganzen Grundlagen wiederholt haben, schauen wir uns in diesem Video die ganzen Java-spezifischen Themen an.  Im Speziellen geht es hier um Klassen, Objekte und Methoden.  Beginn werden wir mit den Methoden.  Diese sind euch vielleicht besser bekannt unter dem Namen Funktionen.", "start": 0.0, "end": 29.0}, {"text": "  Diese werden verwendet, um Verschachtelungen von Code zu erzeugen und diesen dadurch uebersichtlicher zu machen.  Ausserdem koennen wir so verhindern, dass Code, den wir mehrmals brauchen, immer und immer wieder neu schreiben muessen.  Wir lagern dazu unseren Code, der sich immer wiederholt, in eine Funktion aus und rufen die dann an mehreren Stellen auf.  Die Suendtags sieht dabei folgendermassen aus.", "start": 30.0, "end": 60.0}, {"text": "  Zuerst muessen wir eine Funktion definieren, dazu benoetigt sie einen Rueckgabetypen, einen Funktionsnamen und dann in Klammern eine Liste mit Parametern.  Der Rueckgabetyp ist der Datentyp der Variable, die am Ende durch das Return zurueckgegeben wird.  Wird nicht zurueckgegeben, geben wir als Rueckgabetyp void an.  Anschliessend folgt ein eindeutiger Funktionsname, aehnlich wie bei den Variablennamen.", "start": 60.0, "end": 85.0}, {"text": "  In Klammern eine Liste mit Parametern, wobei wir immer den Datentypen und einen Namen angeben und alle dann mit comma drin.  Moechten wir zum Beispiel zwei Integer als Parameter uebergeben, die den Namen a und b tragen sollen, dann schreiben wir int a, int b.", "start": 85.0, "end": 106.0}, {"text": "  Anschliessend koennen wir dann in den geschweiften Klammern den Code schreiben, der in der Methode ausgefuehrt werden soll und schliessen diese mit einem Return ab.  Moechten wir nun eine Methode aufrufen, muessen wir den Namen der Methode angeben und in Klammern die Parameter, die wir uebergeben, hier reicht allerdings der Variablenname.", "start": 106.0, "end": 129.0}, {"text": "  Eine besondere Methode in Java ist die sogenannte Main Methode, diese gibt es nur einmal pro Programm und das Programm startet in dieser Main Methode.  Um eine Main Methode zu schreiben, schreiben wir Public, Static, Void, Main und in Klammern ein Stringary mit dem Namen Arcs.  Was diese Worte Public und Static bedeuten, das schauen wir uns nachher noch einmal an.", "start": 129.0, "end": 157.0}, {"text": "  Innerhalb dieser geschweiften Klammern schreiben wir dann wieder unseren Code und hier folgt die erste Zeile, die in unserem Programm ausgefuehrt wird.  Eine weitere besondere Methode, die ihr oefters verwenden werdet, ist die sogenannte Konsolenausgabe.  Diese sieht in Java folgendermassen aus, wir schreiben System.out.println und dann folgt in Klammern das, was wir ausgeben wollen.", "start": 159.0, "end": 181.0}, {"text": "  Auch die Ausgabe ist hier leicht anders als beispielsweise in C.  Moechten wir beispielsweise, wie hier, einen Integer und einen String in einem Text ausgeben, dann koennen wir das folgendermassen machen.", "start": 182.0, "end": 205.0}, {"text": "  Wir verketten innerhalb der Klammern einfach den Text, den wir ausgeben wollen, indem wir ein Anfuehrungszeichen den Text schreiben und dann mit einem Plus die Sachen anfuegen, die wir ausgeben wollen.  Der folgende Befehl zur Konsolenausgabe wuerde also zu der folgenden Ausgabe fuehren.  Wir haben das Wort, nun folgt der Inhalt, der in dieser Variable steht, in dem Fall ist das Wert.", "start": 207.0, "end": 227.0}, {"text": "  Kommt und dann folgt wieder eine Variable, diese hat den Wert 5, deswegen steht hier die 5 und dann mal vor.  Mit der groesste Unterschied zu Programmiersprachen wie beispielsweise C, ist das Java auf Klassen und Objekten basiert.  Bevor wir uns das genauer anschauen, versuchen wir allerdings erstmal zu verstehen, was es mit Klassen und Objekten auf sich hat.", "start": 229.0, "end": 250.0}, {"text": "  In der Realitaet ist es moeglich, alles in bestimmte Klassen zu unterteilen.  Ein sehr bekanntes Beispiel ist hierbei das Klassensystem in der Biologie, wo Pflanzen und Tiere in bestimmte Klassen und Unterklassen unterteilt werden.  Von einer bestimmten Klasse kann es dann mehrere Objekte geben.  Beispielsweise haben wir die Klasse Module.", "start": 251.0, "end": 277.0}, {"text": "  Objekte von der Klasse Module koennten nun zum Beispiel sein Algorithmen und Datenstrukturen oder Einfuehrungen in die Programmierung.  Ein weiteres Beispiel, wir haben die Klasse Menschen und Objekte von dieser Klasse koennten zum Beispiel die Menschen Anna, Bertha, Claudia und Daniel sein.  Oder wir haben die Klasse Universitaet und haben hier die Objekte TU Berlin, FU Berlin oder DTU da am Start.", "start": 278.0, "end": 303.0}, {"text": "  Schauen wir uns den Unterschied zwischen Klassen und Objekten allerdings noch einmal genauer an dem Beispiel Module an.  In unserem Fall ist Module die Klasse.  Die Klasse hat bestimmte Eigenschaften, zum Beispiel eine Teilnehmerzahl, Leistungspunkte oder ein Professor, der das Module betreut.", "start": 304.0, "end": 328.0}, {"text": "  Nun koennen wir mehrere Objekte vom Typ Module haben und diese Objekte haben alle eine Teilnehmerzahl, Leistungspunkte und ein Professor, allerdings unterschiedliche Werte dafuer.  Beispielsweise hat Algorith die Teilnehmerzahl 1500, 6 Leistungspunkte und Oliver Brock als Professor.  Analyses 1 fuer Ingenieure hat die Teilnehmerzahl 5000, 9 Leistungspunkte und Professor Penn Carras als Professor.", "start": 329.0, "end": 353.0}, {"text": "  Wir haben also verschiedene Objekte, die die gleichen Eigenschaften teilen, allerdings unterschiedliche Werte fuer diese Eigenschaften haben.  Das Ganze wollen wir nun in Java formulieren.  Um eine Klasse zu erzeugen, schreiben wir Public, Class und anschliessend den Klassennamen.  Und innerhalb dieser geschweiften Klammern schreiben wir dann alles, was zu dieser Klasse gehoert.", "start": 354.0, "end": 379.0}, {"text": "  Zu den meisten Klassen gehoeren Attribute, ein Konstruktor und verschiedene Methoden.  Diese Punkte schauen wir uns jetzt einzeln an.  Beginn werden wir mit den Attributen.  Attribute sind Variablen, die sich auf eine bestimmte Klasse bzw. auf ein bestimmtes Objekt beziehen und fuer jedes Objekt andere Werte haben.", "start": 380.0, "end": 407.0}, {"text": "  Diese werden in der Klasse deklariert und beschreiben die Eigenschaft der Klasse und die Werte eines Attributs, die Eigenschaften eines jeweiligen Objekts.", "start": 408.0, "end": 423.0}, {"text": "  Die Attribute werden beim Erstellen eines Objekts durch den Konstruktor initialisiert und wie ich bereits gesagt habe, besitzen alle Objekte einer Klasse die gleichen Attribute, allerdings koennen diese mit unterschiedlichen Werten belegt sein.  Das Ganze schauen wir uns allerdings am Ende nochmal an einem Beispiel an.  Als naechstes folgt der Konstruktor.", "start": 424.0, "end": 443.0}, {"text": "  Der Konstruktor ist eine besondere Art von Methode und ist dafuer da, die Attribute der Klasse beim Erstellen eines Objektes zu initialisieren.  Die Suendtags sieht dabei folgendermassen aus.  Wir schreiben Public, dann den Klassennamen, anschliessend wieder Klammern, in der wir Parameter angeben koennen und fuehren in den geschweiften Klammern die Initialisierung aus.", "start": 444.0, "end": 465.0}, {"text": "  Nun gibt es verschiedene Moeglichkeiten, ein Konstruktor zu definieren.  Zum einen kann der Konstruktor leer sein.  Hier schreiben wir nur Public, den Klassennamen, dann leere Klammern und lassen auch die geschweiften Klammern leer.  In diesem Fall werden alle Attribute mit Standardwerten initialisiert.", "start": 466.0, "end": 495.0}, {"text": "  Das bedeutet, jeder boolean wird mit false initialisiert, jeder character mit dem null character, jeder integer mit null, jeder double mit 0,0 und jeder string mit null.  Das funktioniert, da Variablen in Java immer mit ihren Standardwerten initialisiert werden, anders als z.B. in C.", "start": 496.0, "end": 515.0}, {"text": "  Schreiben wir in einer Klasse gar keinen Konstruktor, dann passiert das Gleiche, als haetten wir ein leeren Konstruktor und alle Attribute werden mit ihren Standardwerten initialisiert.  Moechten wir Attribute allerdings mit bestimmten Werten initialisieren, dann brauchen wir ein parametrisierten Konstruktor.", "start": 516.0, "end": 532.0}, {"text": "  Auch hier schreiben wir wieder Public, den Klassennamen und anschliessend in Klammern Parameter, die wir zur Initialisierung benutzen moechten.", "start": 533.0, "end": 551.0}, {"text": " In den geschweiften Klammern koennen wir dann unsere Attribute initialisieren, haben wir zum Beispiel ein Attribut mit dem Namen A, koennen wir das hier mit dem Wert A, den wir von hier oben bekommen initialisieren  und haben wir ein Attribut B, koennen wir dieses mit dem Wert B initialisieren, den wir von hier oben bekommen.  Das Schluesselwort This, schauen wir uns spaeter noch einmal an.", "start": 551.0, "end": 562.0}, {"text": "  Mit dem parametrisierten Konstruktor haben wir auch die Moeglichkeit, Attribute nur teilweise zu initialisieren.  In diesem Beispiel koennen wir auch noch ein Attribut mit dem Namen C haben, wenn wir das nicht im Konstruktor initialisieren, wird dieses dann mit Standardwerten initialisiert.  Neben dem Konstruktor kann eine Klasse auch noch weitere Methoden besitzen.", "start": 563.0, "end": 591.0}, {"text": "  Diese Methoden werden genauso wie wir uns das vorhin angeschaut haben definiert, indem wir ein Rueckgabetypen angeben, ein Funktionsnamen und anschliessend eine Liste mit Parametern.  Methoden einer Klasse haben die Besonderheit, dass diese nicht nur auf ihre eigenen Parameter zugreifen koennen, sondern auch auf die Attribute der Klasse, falls welche vorhanden sind.", "start": 592.0, "end": 611.0}, {"text": "  Bevor wir uns nun noch ein paar spezielle Methoden angucken, schauen wir uns erstmal die ganzen Schluesselwoerter an, die ich bisher erst mal uebersprungen habe.  Beginnen werden wir dabei mit dem Schluesselwort This.  This gibt uns eine Referenz auf das aktuelle Objekt.  Dies wird haeufig verwendet, um auf die Attribute des Objekts zuzugreifen, indem wir uns gerade befinden.", "start": 612.0, "end": 631.0}, {"text": "  Das Ganze wird klarer, wenn wir uns folgen das Beispiel angucken.  Wir haben hier die Klasse Test und diese besitzt ein Attribut mit dem Namen Attribut.  Im Konstruktor uebergebe ich jetzt ein Parameter, welcher auch den Namen Attribut traegt.  Was ich nun erreichen moechte, ist, dass mein Attribut mit diesem Wert initialisiert wird.", "start": 632.0, "end": 663.0}, {"text": "  Dieses traegt den Namen Attribut, unser Paralimeter traegt auch den Namen Attribut, das heisst ich wuerde hier schreiben Attribut ist gleich Attribut.  In diesem Fall ist allerdings nicht klar, welche Variable ich mit Attribut meine.  In diesem Fall wuerde beides als der Parameter interpretiert werden.  Somit wuerden wir unser Attribut hier oben nicht initialisieren.", "start": 664.0, "end": 689.0}, {"text": "  Mit dem Schluesselwort This sage ich nun ausdruecklich, ich meine an dieser Stelle nicht den Parameter, sondern mein Attribut.  Mit This Punkt kann ich also genau sagen, ich moechte auf mein Attribut zu greifen und nicht auf die lokalen Parameter.  Weiterhin sind wir ueber das Schluesselwort Static gestolpert.", "start": 690.0, "end": 709.0}, {"text": "  Dieses ist haeufig in Methodenkoepfen zu finden, beispielsweise haben wir das in der Main gesehen.  Dieses Schluesselwort wird immer genau dann benoetigt, wenn die Methode auch ohne erstellen eines Objektes aufrufbar sein soll.  Im Standardfall lassen sich naemlich auf Attribute und Methoden erst dann zu greifen, wenn ich von einer Klasse ein Objekt erstellt habe.", "start": 710.0, "end": 735.0}, {"text": "  Moechte ich auch ohne ein Objekt zu erstellen auf eine Methode zu greifen, benoetige ich eben das Schluesselwort Static.  Hier habe ich einmal 3 Beispielmethoden formuliert.  Eine Methode, die den Radius eines Objekts der Klasse Kreis ausgibt, eine Methode, die 2 Zahlen addiert und die Main Methode.", "start": 736.0, "end": 756.0}, {"text": "  Ich wuerde euch nun einmal bitten, kurz darueber nachzudenken, welche der Methode Static sein sollten und welche nicht.  Die erste Methode darf nicht Static sein, denn sie greift auf das Attribut Radius zu.  Und das Attribut Radius ist nur initialisiert, wenn auch ein Objekt der Klasse Kreis erstellt wurde.  Waehrend die Methode Static, koennte sie also nicht auf das Attribut zugreifen.", "start": 757.0, "end": 804.0}, {"text": "  Die Methode, die 2 Zahlen addiert, kann durchaus Static sein, denn sie benoetigt keine Attribute der Klasse, sondern nur 2 Parameter, eben genau die beiden Zahlen, die addiert werden sollen.  Auch die Main Methode muss Static sein, denn sie wird als erstes aufgerufen und somit koennen noch keine Objekte erzeugt worden sein.", "start": 805.0, "end": 819.0}, {"text": "  Weitere Schluesselwoerter, die uns bisher begegnet sind, sind Private und Public.  Diese kann ich jeweils vor die Deklaration einer Variable oder vor die Definition einer Funktion schreiben.  Ist ein Attribut oder eine Methode Private, so ist diese nur innerhalb der Klasse gueltig, das heisst man kann von aussen nicht auf das Attribut oder diese Methode zugreifen, sondern nur von innerhalb der Klasse.", "start": 820.0, "end": 852.0}, {"text": "  Ist ein Attribut bzw. eine Methode als Public deklariert, so kann man innerhalb aller Klassen darauf zugreifen, also auch von ausserhalb der Klasse, in der sie deklariert wurde.  Nun kann man sich fragen, warum man ueberhaupt Attribute und Methode als Private deklarieren sollte, wenn es doch viel einfacher ist, wenn alle Klassen darauf zugreifen koennen.", "start": 853.0, "end": 870.0}, {"text": "  Zum einen kann man, wenn Attribute Private sind, den Lese- und Schreibzugriff auf diese Attribute einschraenken.  Moechte man zum Beispiel nicht, dass bestimmte Attribute von aussen veraendert werden koennen, so kann man dieses Attribut auf Private setzen.  Um nun den Zugriff darauf zu kontrollieren, gibt es sogenannte Getter und Setter-Methode.", "start": 871.0, "end": 894.0}, {"text": "  Eine Getter-Methode wird verwendet, wenn das Attribut auf Private gesetzt ist, allerdings von aussen ein Lesezugriff erlaubt werden soll.  In dem Fall ist unser Attribut vom Typ Integer Private und wir moechten jetzt von ausserhalb der Klasse den Wert dieses Attributs lesen.", "start": 895.0, "end": 917.0}, {"text": "  Was wir nun tun koennen, ist eine Public-Methode zu schreiben, welche den Rueckgabetyp hat, der dem Datentyp unseres Attributs entspricht und den Namen GetAttributname traegt.  Eine Getter-Methode benoetigt keine Parameter und macht nichts weiter, als dieses Attribut auszugeben.", "start": 918.0, "end": 933.0}, {"text": " Warum funktioniert das?  Da diese Methode Public ist, kann man von aussen darauf zugreifen, das heisst man kann diese Methode aus jeder anderen Klasse aufrufen.  Diese Methode selbst kann allerdings auch auf das Attribut zugreifen, was wir hier sehen, da die Methode innerhalb der Klasse definiert wurde, in der das Attribut definiert wurden.", "start": 934.0, "end": 962.0}, {"text": "  Moechte man also zum Beispiel, dass von aussen nicht in dieses Attribut geschrieben werden kann, also die Variabe nicht veraendert werden kann, sondern nur der Wert ausgelesen werden kann, kann man dieses Attribut auf Private setzen und eine Getter-Methode schreiben.", "start": 963.0, "end": 971.0}, {"text": "  Moechte man allerdings dieses Attribut von aussen veraendern koennen, obwohl das auf Private gesetzt ist, so kann man eine sogenannte Setter-Methode schreiben.  Diese sieht der Getter-Methode sehr aehnlich mit dem Unterschied, dass sie nun nicht den Wert des Attributs zurueckgibt, sondern mit einem anderen Wert ueberschreibt.", "start": 972.0, "end": 999.0}, {"text": "  Wir haben hier wieder unser Attribut, was auf Private gesetzt ist und nun unser Setter-Methode, welche oeffentlich ist, den Rueckgabetyp Void hat, das heisst sie gibt nichts zurueck, sie traegt den Namen Set-Attributname und hat ein Parameter, welcher vom gleichen Datetyp ist wie unser Attribut.", "start": 1001.0, "end": 1010.0}, {"text": "  In der Setter-Methode machen wir nichts anderes, als unser Attribut auf den Wert zu setzen, den wir hier als Parameter uebergeben bekommen haben, eben genau wie im Konstruktor.  Wenn wir nun unsere Klasse erstellt haben, ist es uns moeglich, Objekte von dieser Klasse zu erzeugen.", "start": 1012.0, "end": 1032.0}, {"text": "  Haben wir zum Beispiel die Klasse-Modul geschrieben, dann koennen wir uns nun eine neue Variable vom Datentyp-Modul anlegen, die sie nenne ich jetzt Algodat, und initialisieren, indem ich den Konstruktor von dieser Klasse aufrufe.  Dazu schreibe ich das Schluesselwort New und anschliessend den Namen der Klasse, welche den Konstruktor aufruft.", "start": 1033.0, "end": 1044.0}, {"text": "  In Klammern schreibe ich dann alle Parameter, die fuer den Konstruktor benoetigt werden.  Hab ich ein Lern- oder kein Konstruktor, sind leere Klammern ausreichend, habe ich ein parametrisierten Konstruktor, so muss ich hier die entsprechenden Parameter angeben.  Wichtig hierbei ist, nur wenn der Konstruktor aufgerufen wird, wird auch ein neues Objekt erzeugt.", "start": 1045.0, "end": 1078.0}, {"text": "  Wenn ich jetzt zum Beispiel ein neues Objekt in dieser Zeile erzeuge und dann sage, ich habe eine neue Variable auch vom Typ-Modul, die nenne ich Intro-Proc, und weise ihr den Wert Algodat zu, dann wird nur die Referenz auf dieses Objekt kopiert.  Was das genau heisst, schauen wir uns einmal in einem einfacheren Beispiel an.  Ich habe hier mein klein Pseudocode erstellt.", "start": 1080.0, "end": 1100.0}, {"text": "  Wir haben zuerst die Main-Methode, welche ein AA initialisiert mit dem Wert 5, diesen dann der Funktion F uebergibt und anschliessend den Wert in A ausgibt.  Die Funktion F bekommt ein Double uebergeben, der heisst hier X, und macht nichts anderes, als 2 zu diesem Double dazu zu allieren.  Auf der rechten Seite habe ich dann mal etwas vereinfacht den Speicher unseres Programms dargestellt.", "start": 1101.0, "end": 1124.0}, {"text": "  Fuehren wir nun die erste Zeile der Main-Methode aus, wird irgendwo im Speicher die Variable A hinterlegt mit dem Wert 5.  Nun rufen wir unsere Methode F auf.  Diese bekommt den Wert A uebergeben, der heisst hier allerdings X, das heisst ich habe jetzt irgendwo im Speicher meine Variable X und die hat den gleichen Wert wie A.", "start": 1125.0, "end": 1147.0}, {"text": "  Nun addiere ich 2 zu meiner Variable X, weshalb die zu 7 wird und verlasse meine Methode wieder.  Da an dieser Stelle die geschweiften Klammern geschlossen werden und Variable nur innerhalb der geschweiften Klammern gueltig sind, in denen sie deklariert wurden, ist X jetzt aus dem Speicher verschwunden.", "start": 1148.0, "end": 1168.0}, {"text": "  Gebe ich nun allerdings A aus, erhalte ich natuerlich den Wert 5,0, weil sich an dieser Speicherstelle nichts veraendert hat.  Nun gibt es 2 Moeglichkeiten dieses Problem zu beheben.  Die erste Moeglichkeit wird Call by Value genannt.  Der erste Schritt in meinem Code ist hier der gleiche, ich habe wieder eine Variable A mit dem Wert 5,0, diese uebergebe ich wieder der Methode F.", "start": 1169.0, "end": 1191.0}, {"text": "  In der Methode F wird der Wert in X gespeichert, das sehen wir hier.  Nun erhoehen wir X wieder um 2, deswegen steht jetzt hier 7,0.  Und anschliessend, was wir vorher nicht gemacht haben, returnen wir den Wert wieder.  Das bedeutet der Wert der hier in X steht wird als Rueckgabewert der Methode zurueckgegeben, an die Stelle wo die Methode aufgegriffen wurde.", "start": 1192.0, "end": 1217.0}, {"text": "  Das heisst an dieser Stelle wird nun eine 7 zurueckgegeben und diese wird A wieder zugewiesen.  Das heisst A wird auf den Wert 7 gesetzt und wenn wir nun A ausgeben, hat A den Wert 7.  Die zweite Moeglichkeit ist Call by Reference.  Ich habe das Ganze hier mal mit einem einfachen Array gemacht, das gleiche wuerde aber auch funktionieren, wenn man Objekte oder Aehnliches benutzt.", "start": 1218.0, "end": 1242.0}, {"text": "  Fuer diese wird naemlich in der Variable lediglich eine Referenz gespeichert.  Leg ich mir hier also ein Array A an mit den Werten 5 und 2, speichere ich in der Variable nur den Ort des Arrays, die Speicheradresse des Arrays,  und an dieser Stelle stehen dann die beiden Werte.  Jetzt uebergebe ich A der Methode F, das bedeutet, dass was in A steht, wird jetzt in X kopiert.", "start": 1243.0, "end": 1276.0}, {"text": "  In A steht diese Referenz, in X wird also die gleiche Referenz kopiert.  Das bedeutet, beide Variablen referenzieren jetzt auf diesen Speicherbereich.  Wenn ich jetzt den ersten Wert in meinem Array X aendern moechte, dann gucke ich, welche Adresse steht in X, in X steht diese Adresse.  Der erste Wert ist dieser hier, das heisst, den erhoehe ich um 2.", "start": 1277.0, "end": 1310.0}, {"text": "  Und jetzt, obwohl ich kein Return benutzt habe, steht an der ersten Stelle von A der richtige Wert, da die Adresse die gleiche ist.  Gehen wir also nochmal zurueck zu unserem Beispiel.  Wir erstellen hier ein neues Objekt vom Typ Modul und speichern das in der Variable Algodot.  Und was wir in der zweiten Stelle machen, ist die Referenz, die in Algodot steht, nach IntroProc zu speichern.", "start": 1312.0, "end": 1333.0}, {"text": "  Das heisst, beide Referenzen zeigen nun auf ein und dasselbe Objekt.  Das bedeutet, wenn ich die Attribute von Algodot aendere, aendern sich auch die Attribute von IntroProc.  Moecht ich also zwei Objekte erzeugen, muss ich fuer IntroProc noch einmal den Konstruktor aufrufen.  Moechte ich nun auf Attribute oder Methoden einer Klasse zugreifen, dann gibt es hier verschiedene Moeglichkeiten.", "start": 1334.0, "end": 1361.0}, {"text": "  Bei den Attributen muessen wir beachten, ob diese Public oder nicht Public sind.  Wenn diese Public sind, kann ich von aussen darauf zugreifen, indem ich Objektname, Punkt, Attributname schreibe,  dann ein Ist gleich und einen bestimmten Wertzuweise.  Oder andersrum, wenn ich den Wert lesen moechte, schreibe ich Objekt.", "start": 1362.0, "end": 1386.0}, {"text": "ttribut auf der rechten Seite  und auf der linken Seite eine Variable, in die ich den Wert speichern moechte.  Sind die Attribute auf Private gesetzt, kann ich auf diese nur zugreifen, wenn sie eine Getter oder Setter Methode haben.  Dann schreibe ich auch wieder Objektname, Punkt, dann kommt der Methodenname, in dem Fall Set, Attribut und anschliessend der Wert in Klammern.", "start": 1387.0, "end": 1414.0}, {"text": "  Oder ich benutze die Getter Methode, um den Wert zu lesen, indem ich Objektname, Punkt, Get, Attributname schreibe und leere Klammern und das Ganze in einer Variablespeicher.  Moechte ich eine Methode ausfuehren, wird hier unterschieden zwischen Static und Nicht-Static.  Bei Nicht-Static-Methoden schreibe ich Objektname, Punkt, Methodenname und dann in Klammern meine Liste der Parameter.", "start": 1416.0, "end": 1440.0}, {"text": "  Ist die Methode aesthetic definiert, schreibe ich Klassenname, Punkt, Methodenname und anschliessend in Klammern meine Liste der Parameter.  Um das Ganze einmal anzuwenden, wollen wir uns folgende Aufgabe anschauen.  Probiert diese gerne erstmal selbst und dann zeige ich euch meine Loesung dazu.", "start": 1441.0, "end": 1460.0}, {"text": "  Definiert dazu zuerst eine Klasse-Module. Diese Klasse soll die privaten Attribute Teilnehmer, LP und Professor besitzen.  Ueberlegt euch hierzu, welche Datentypen dazu am besten geeignet sind.  Diese Attribute sollen dann mit einem parametrisierten Konstruktor initialisiert werden koennen.", "start": 1461.0, "end": 1480.0}, {"text": "  Um auf die Attribute zugreifen zu koennen, also auch von ausserhalb der Klasse, schreibt fuer die Attribute jeweils eine Getter und eine Setter Methode.  Weiterhin soll die Klasse die Methode Semesterende besitzen, welche die Teilnehmerzahl auf 0 setzen soll.  Definiert abschliessend eine weitere Klasse-Test, welche nur die Main-Methode enthaelt.", "start": 1481.0, "end": 1497.0}, {"text": "  Dieser koennt ihr dann die Funktionalitaet eurer Klasse-Module testen.  Beginnen wir also nun damit, erstmal eine neue Klasse zu erstellen.  Dazu mache ich einen Rechtsgeleg auf den Source-Orner, waehle New und dann Java-Class.  Ich gebe ihr den Namen Modul und druecke Enter.  Nun kann ich damit beginnen, die Attribute zu definieren.", "start": 1505.0, "end": 1539.0}, {"text": "  Die Klasse soll die privaten Attribute Teilnehmer, Leistungspunkte, also kurz LP, und Professor besitzen.  In Teilnehmer wird die Anzahl der Teilnehmer gespeichert.  Das heisst, hier bietet sich ein ganz zahliger Datentyp an.  Die LP sind auch immer ganz zahlig, das heisst auch hier bietet sich ein ganz zahliger Datentyp an.", "start": 1540.0, "end": 1561.0}, {"text": "  Und der Professor ist ein Name, der aus mehreren Buchstaben besteht, also eine Zeichenkette, somit bietet sich der Datentyp string an.  Alle diese Attribute sollen weiterhin private sein.  Das heisst, ich schreibe erst private, dann den Datentypen, in dem Falle int, und dann den Namen, in dem Falle Teilnehmer.  Das Gleiche mache ich nun mit LP.", "start": 1562.0, "end": 1596.0}, {"text": "  Und fuer Professor mache ich das Gleiche noch einmal, nur dass ich hier den Datentypen string waehle.  Diese Attribute sollen nun in einem Konstruktor initialisiert werden.  Ein Konstruktor besteht immer aus dem Schluesselwort Public.  Anschliessend folgt der Name der Klasse, in dem Fall Modul, und dann Klammern.  Innerhalb der Rundenklammern folgen nun die Parameter.", "start": 1596.0, "end": 1651.0}, {"text": "  In dem Fall moechten wir ein Integer Teilnehmer, ein Integer LP und einen String Professor haben.  Innerhalb des Konstruktors koennen wir nun unsere Attribute initialisieren.  Auf die Attribute greife ich mit dem Schluesselwort This zu, das heisst, ich kann zum Beispiel schreiben This.Teilnehmer.  Das waere in dem Fall mein Attribut Teilnehmer.", "start": 1653.0, "end": 1680.0}, {"text": "  Und das moechte ich initialisieren mit dem Parameter Teilnehmer, den ich hier uebergeben bekomme.  Wir sehen schon, diese beiden Stellen werden geheilitet, das sind eben genau die beiden Parameter.  Und diese Stelle wird mit dieser Stelle zusammen geheilitet, das ist eben genau mein Attribut.  Das Gleiche mache ich nun auch mit den anderen beiden Attributen.", "start": 1681.0, "end": 1728.0}, {"text": "  Um von aussen auf die privaten Attribute zugreifen zu koennen, benoetige ich ausserdem Gatter und Zetter Methoden.  Gatter und Zetter Methoden muessen dann publik definiert sein, damit ich von aussen darauf zugreifen kann und geben entweder den Wert unseres Attributs zurueck oder setzen unser Attribut auf einen bestimmten Wert.  Schauen wir uns zuerst die Gatter Methode fuer Teilnehmer an.", "start": 1729.0, "end": 1756.0}, {"text": "  Diese muss wie gesagt publik sein.  Eine Gatter Methode hat als Rueckgabewert den Datentyp unseres Attributs, also in dem Falle int, und wird meist get und dann wie das Attribut genannt.  Parameter benoetigen wir fuer Gatter Methode nicht.", "start": 1758.0, "end": 1790.0}, {"text": "  Innerhalb dieser Methode machen wir nichts anderes, als den Wert unseres Attributs zurueckgeben, das heisst wir schreiben return und dann brauchen wir unser Attribut, also this.teilnehmer.  Das Gleiche machen wir nun auch fuer die anderen Attribute.", "start": 1792.0, "end": 1806.0}, {"text": "  Wenn wir die Gatter Methode nicht von Hand schreiben, gibt es in die Idee auch die Moeglichkeit, einen Rechtsklick zu machen, auf generate zu gehen und Gatter Methoden auszuwaehlen.  Nun markieren wir die beiden Gatter Methoden, die uns noch fehlen und druecken auf ok.  Wie wir sehen, wurden jetzt hier die Gatter Methoden fuer LP und Professor erzeugt.", "start": 1809.0, "end": 1826.0}, {"text": "  Wir sehen allerdings auch, dass an dieser Stelle das this fehlt.  Da hier kein anderer Parameter in der Methode definiert wurde, der auch LP heisst, ist eindeutig, dass mit LP unser Attribut gemeint ist.  In dem Fall wird das this also nicht benoetigt.  Wenn ihr euch unsicher seid, koennt ihr allerdings jedes Mal, wenn das Attribut gemeint ist, this schreiben und es funktioniert.", "start": 1828.0, "end": 1855.0}, {"text": "  Nun benoetigen wir noch Setter Methoden.  Setter Methoden sind auch wieder public, weil wir von aussen darauf zugreifen wollen.  Haben keine Rueckgabe, das heisst wir geben als Datentyp void an.  Und als Name haben sie Set unter den Namen des entsprechenden Attributs.  Hier benoetigen wir allerdings ein Parameter, weil wir wissen muessen, auf welchen Wert wir das Attribut setzen.", "start": 1867.0, "end": 1896.0}, {"text": "  Und dieser Parameter muss vom gleichen Datentyp sein wie unser Attribut, in dem Fall also Integer Teilnehmer.  In dieser Setter Funktion machen wir dann nichts anderes als unser Attribut, in dem Fall Teilnehmer, auf den Wert von unserem Parameter zu setzen.", "start": 1897.0, "end": 1925.0}, {"text": "  Auch hier gibt es nun wieder die Moeglichkeit, die fehlenden Setter Methoden generieren zu lassen, indem ich einen Rechtsklick mache, auf Generate Gehe, Setter Methoden auswaehle und die beiden fehlenden Setter Methoden.  Wie wir sehen, ist hier nun, dass this zwangslaeufig notwendig, weil wir hier zweimal die Variable lp verwenden.  Einmal den Parameter und einmal unser Attribut.", "start": 1926.0, "end": 1953.0}, {"text": "  Abschliessend definieren wir noch weitere Methoden, in diesem Fall unsere Semesterende Methode.  Die Methode Semesterende soll die Teilnehmerzahl auf 0 setzen.  Da wir von aussen darauf zugreifen wollen, muss die Methode public sein.  Da wir nichts zurueckgeben muessen, geben wir das Datentypen void an und der Name der Methode lautet semesterende.", "start": 1957.0, "end": 1983.0}, {"text": "  Wir benoetigen hier auch keine Parameter, da wir die Teilnehmerzahl immer auf 0 setzen.  Um die Teilnehmerzahl nun auf 0 zu setzen, greifen wir wieder auf unser Attribut zu, in dem Fall Teilnehmer und setzen dieses auf 0.  Um das Ganze zu testen, erzeugen wir uns erstmal eine neue Klasse, die Test heisst.  Dazu will ich hier wieder new, Java-Class und gebe den Namen Test.", "start": 1987.0, "end": 2015.0}, {"text": "  In dieser Testklasse erzeugen wir dann die Main Methode.  Diese hat die Signatur public, static, void, main und kriegt als Argument ein Stringary von Argumenten.  Das Ganze laesst sich auch abkuerzen, indem ihr einfach die Anfangsbuchstaben schreibt, in dem Fall public, static, void, main und dann enter drueckt.", "start": 2016.0, "end": 2052.0}, {"text": "  Allerdings solltet ihr trotzdem im Kopf behalten, wie die Signatur der Main Methode aussieht.  Innerhalb dieser Main Methode moechte ich mir nun ein neues Objekt vom Typ Modul erstellen.  Ich gebe also als Datentyp Modul an, dann gebe ich meiner Variable einen Namen, in dem Fall zum Beispiel Algodat und weise einen Wert zu.", "start": 2052.0, "end": 2091.0}, {"text": "  An dieser Stelle muss ich nun den Konstruktor von Algodat aufrufen, indem ich das Schluesselwort new benutze, anschliessend den Klassennamen, in dem Fall Modul und nun entklammern die Teilnehmer, die LP und den Namen des Professors angeben.  Das wird uns hier von Ideas schon freundlicherweise angezeigt.", "start": 2092.0, "end": 2108.0}, {"text": "  Wir nehmen nun an, wir haben zum Beispiel 1500 Teilnehmer, das Modul bringt 6 LP und der Professor heisst Oliver Bock.  An dieser Stelle bitte nicht von diesem Teilnehmer LP und Professor verwirren lassen, das zeigt Ideen nur an, um euch zu zeigen, welche Parameter am Ende fuer welches Attribut steht.  Dieses Professor Doppelpunkt gehoert dabei allerdings nicht zur Suendtags.", "start": 2109.0, "end": 2139.0}, {"text": "  Nachdem wir nun ein neues Modul erstellt haben, koennen wir die Informationen dieses Moduls mittels der PrintLine-Methode ausgeben.  Um etwas auf der Konsole auszugeben, schreibe ich System, Punkt Out, Punkt Print Line und entklammern, was ich ausgeben moechte.", "start": 2140.0, "end": 2169.0}, {"text": "  Hier schreibe ich zum Beispiel das Modul-Algodat hat und jetzt moechte ich die Anzahl der Teilnehmer angeben, das kann ich mit diesem Plus hier erreichen.  Nun brauche ich die Anzahl der Teilnehmer. Waere das Attribut nicht auf Private gesetzt, koennte ich nun einfach schreiben, Algodat, Punkt Teilnehmer.", "start": 2170.0, "end": 2189.0}, {"text": "  Da das Attribut allerdings Private gesetzt ist, muss ich hier Getter und Setter Methoden nutzen, um darauf zuzugreifen.  Das heisst, ich nutze hier die Getter Methode fuer Teilnehmer, in dem Falle Get-Teilnehmer.  Nun kann ich meinen Satz fortsetzen, indem ich hier wieder ein Plus schreibe.  Kann ich zum Beispiel ein Komma setzen, bringt so und so viel LP.", "start": 2190.0, "end": 2220.0}, {"text": "  Hier nutze ich wieder die Getter Methode, um darauf zuzugreifen, das heisst, ich verwende den Namen meines Objekts bzw. meiner Variable Algodat, Punkt GetLP.  Dann setze ich meinen Satz weiter fort, bringt so und so viel LP und wird von, jetzt folgt der Name des Professors.  Diesen erhalte ich auch wieder ueber die Getter Methode, das heisst GetProfessor.", "start": 2220.0, "end": 2247.0}, {"text": "  Nun kann ich schliesslich meinen Satz abschliessen und herrichtet.  Das Ganze koennen wir nun einmal testen, indem ich hier einen Rechtsklick auf Test mache und Run Test Main auswaehle.  Wenn ihr die neueste Version von Java installiert habt, also die JDK 16, kann es passieren, dass euch Idee folgenden Fehler ausgibt.", "start": 2247.0, "end": 2280.0}, {"text": "  Das liegt daran, dass die Java Version noch sehr neu ist und noch nicht stabil mit der aktuellen IDEA Version funktioniert.  Die einfachste Methode ist, eine aeltere Version von Java zu installieren, zum Beispiel die JDK 15.", "start": 2281.0, "end": 2302.0}, {"text": " Wenn ihr nach der Installation von der JDK Version 15 und der Deinstallation von JDK Version 16 IDEA neu startet,  haltet ihr die Fehler-Meldung, dass die JDK 16 nicht mehr gefunden werden kann.  Dann geht ihr hier oben rechts auf Configure und wird die erkannte JDK aus.  Nun fuehlen wir das Ganze erneut aus.  Hier sehen wir nun die Ausgabe unserer Konsole.  Das Modul Algodat hat 1500.", "start": 2303.0, "end": 2324.0}, {"text": "  Wir sehen schon, hier fehlt das Wort Teilnehmer, das koennen wir gleich noch ergaenzen.  Beringt 6 LP und wird von Oliver Bock unterrichtet.  Der Zugriff auf unsere Attribute hat also funktioniert.  Nun koennen wir testen, eins dieser Attribute zu aendern.  Zum Beispiel wollen wir nun mehr Leistungspunkte fuer unser Modul erhalten.", "start": 2326.0, "end": 2346.0}, {"text": "  Darauf zugreifen koennen wir, indem wir wieder den Namen unserer Waren verwendet haben.  Wir koennen also die Abkuerzung des Modules auf den  Variablen schreiben, in dem Fall Algodat, dann ein Punkt und jetzt die Setter-Methode,  in dem Fall ZLP verwenden.  In Klammern geben wir nun die neuen LP an, in dem Falle 9.", "start": 2347.0, "end": 2381.0}, {"text": "  Nun kopiere ich mir einmal diese Ausgabe hier und lasse mir danach erneut den Text ausgehen.  Ich mache wieder rechtsklick auf Test und dann Run Test.main.  Wir sehen schon, hier fehlt jetzt wieder ein Leerzeichen, aber ansonsten sehen wir auch.  Zuerst bringt es 6 LP, danach bringt es 9 LP.  Unsere Getter und unsere Setter-Methode funktionieren also.", "start": 2381.0, "end": 2417.0}, {"text": "  Nun probieren wir noch die Methode Semesterende aufzurufen.  Dazu schreiben wir Algodat, also wieder unseren Objektnamen und dann den Namen der Methode,  in dem Falle Semesterende.  Anschliessend wollen wir uns das Ganze noch einmal ausgeben lassen.  Ich druecke hier wieder auf Run bzw. ich kann hier auch auf diesen Gruenpfeil druecken,  dann wird der letzte Run wiederholt.", "start": 2418.0, "end": 2450.0}, {"text": "  Wir sehen nun, zu Beginn hat Algodat 1500 Teilnehmer und 6 LP,  dann haben wir die Setter-Methode verwendet und haben LP auf 9 gesetzt, das sehen wir hier.  Und dann haben wir die Methode Semesterende verwendet und fallen auf 0 Teilnehmer.", "start": 2450.0, "end": 2462.0}]}]