[{"lecture": "31624_55_course_video", "Timestamps": [{"text": "  Hallo, heute moechte ich mit dir ueber objektorientierte Programmierung sprechen.  In diesem Kurs benutzen wir Java als Programmiersprache, um Algorithmen und Datenstrukturen anzuwenden.  Java ist eine relativ beliebte Programmiersprache, wie ihr hier seht.  Python ist entsprechend dieser Statistik die beliebteste, aber nicht darauf gefolgt von Java.", "start": 0.0, "end": 28.0}, {"text": "  Warum brauchen wir ueberhaupt so viele Programmiersprachen?  Reicht nicht eine.  Jede dieser Sprachen hat eine bestimmte Staerke.  Diese Staerke ist auch eine Konsequenz des sogenannten Programmiersprachenparadigmas.  Das bedeutet, dass es ein bestimmtes Konzept gibt, darueber wie Programme in diesen Programmiersprachen erstellt werden.", "start": 28.0, "end": 53.0}, {"text": "  Wir reden heute ueber eines dieser Paradigme, die objektorientierte Programmierung.  Aber es gibt noch eine ganze Reihe andere von solchen Paradigmen, das werdet ihr lernen, wenn ihr spaeter Kurse ueber Programmiersprachen entnimmt.  In jedem Fall wollte ich euch nur zeigen, dass wir euch nicht eine totale absurde Sprache praesentieren, sondern dass Java tatsaechlich auch in der Praxis relevant hat.", "start": 53.0, "end": 84.0}, {"text": "  Eine Frage, die sich stellt, wenn man konfrontiert ist mit so vielen verschiedenen Programmiersprachen aus so vielen verschiedenen Programmiersprachenparadigmen,  ist die Frage, welche dieser Sprachen ist denn die beste?  Und das ist eine Frage, die nicht wirklich zu beantworten ist.", "start": 84.0, "end": 101.0}, {"text": "  Es gibt zum Beispiel immer noch Leute, die argumentieren darueber ob Objektorientiertheit eine gute Idee ist oder nicht.  Ich finde, das ist eine gute Idee und deswegen reden wir mal darueber.  Aber die Frage ist noch mal davor, welche Sprache ist die beste?  Nehmen wir mal an, wir haben hier einen Kreis, der signalisiert, welche die Faehigkeiten einer bestimmten Sprache.", "start": 101.0, "end": 118.0}, {"text": "  Also haben hier die Sprache.  Nun wollen wir natuerlich ein Problem loesen und nehmen wir mal an, dieser zweite Kreis hier ist das Problem, das wir loesen wollen.  Nun koennen wir erfreut feststellen, dass das Problem der Problemkreis voellig innerhalb des Sprachkreises ist,  was bedeuten soll, dass wir das Problem mit der Sprache loesen koennen.", "start": 120.0, "end": 149.0}, {"text": "  Das ist allerdings nicht so besonders, denn es gibt etwas, das heisst, dass die Church-Touring-Hypothese,  die besagt, dass im Grunde genommen jede Funktion, die berechenbar ist, auch auf einem Computer berechenbar ist.  Und das heisst, wir haben das im Grunde genommen alle berechenbaren Funktionen mit den modernen Programmiersprachen auch berechnet werden koennen.", "start": 150.0, "end": 175.0}, {"text": "  Also es ist im Grunde genommen so entweder kann ein Problem nicht geloest werden oder es ist innerhalb des Kreises einer bestimmten Sprache.  Das hilft uns jetzt nicht, weil das bedeutet ja nur, dass wir eigentlich jede Sprache nehmen koennen, um jedes Problem zu loesen.", "start": 176.0, "end": 191.0}, {"text": "  Aber natuerlich gibt es da Unterschiede und die Sprachen unterscheiden sich darin, wie leicht ein Problem in einer bestimmten Sprache loesen kann.  Das heisst, bestimmte Dinge lassen sich gut mit der wegorientierten Programmiersprachen abbilden  und andere Probleme lassen sich besser mit zum Beispiel funktionalen Programmiersprachen abbilden.", "start": 191.0, "end": 212.0}, {"text": "  Wir sind aber hier fokussiert auf Algorithmen und Datenstrukturen und auf Java.  Also das heisst, wir werden diese Frage nicht weiter verfolgen.  Ich wollte euch aber noch einen dritten Faktor nennen und das ist natuerlich der Faktor Mensch.", "start": 212.0, "end": 240.0}, {"text": " Damit der Mensch eine Programmiersprache benutzen kann, um ein Problem zu loesen, muss er natuerlich die Sprache ausreichend beherrschen,  um alle die notwendigen Features von der Sprache benutzen zu koennen, die notwendig sind um das Problem zu loesen.  Das heisst, die beste Sprache hilft nichts, wenn man nicht programmieren kann oder wenn man das Problem nicht versteht.", "start": 240.0, "end": 251.0}, {"text": "  Genau deswegen sind wir hier. Wir wollen euch Java beibringen, damit ihr das so gut versteht,  dass alle moeglichen Probleme, die ihr kennt in der Welt, auch loesbar sind.  Gut. Also Java und objektorientierte Programmierung ist das Thema dieser Foliesung.  Ich will mit dir mal ganz einfach anfangen, ueber eine wirkliche Anwendung nachzudenken,  wie zum Beispiel eine Corona Tracking App.", "start": 251.0, "end": 283.0}, {"text": "  Schon klar, da haben wir irgendwelche Leute, die laufen durch die Gegend  und wenn die aber jemand anderen treffen, wie zum Beispiel hier,  dann ist das ein Ereignis, was wir in irgendeiner Weise gerne uns merken wuerden,  damit, falls dann einer der beiden spaeter positiv auf Corona getestet wird,  dass wir dann den anderen warnen koennen.", "start": 283.0, "end": 312.0}, {"text": "  Fuer diese Diskussion werde ich jetzt erstmal alle datenschutzrechtlichen Bedenken ueber Bord werfen.  Natuerlich wuerden wir gerne auch wissen, in welchem Ort die sich getroffen haben,  denn das wuerde uns ermoeglichen, rauszukriegen.  Wo sind denn die meisten Infektionen? Sind die im Supermarkt?  Sind die bei der Arbeit? Sind die in der U-Bahn? Und so weiter.", "start": 312.0, "end": 331.0}, {"text": "  Das heisst, wir wuerden gerne hier eigentlich einen Ort assoziieren,  den ich mal mit so einem kleinen Haeuschen symbolisiere.  Okay, also wir haben jetzt hier eine ganze Reihe von Dingen.  Wir haben erstens Menschen.  Zweitens haben wir die Bewegungsprofile der Menschen.  Drittens haben wir diese Ereignisse.  Und viertens haben wir Orte.", "start": 331.0, "end": 363.0}, {"text": "  Okay, die Idee ist natuerlich jetzt, dass wir versuchen, dieses Problem irgendwie im Rechner abzubilden  und gegeben das Thema der Vorlesung, machen wir das natuerlich  unter der Verwendung von objektorientierter Programmierung.  Was heisst es denn nun objektorientiert?  Wir sind also offensichtlich auch objektenorientiert.", "start": 363.0, "end": 386.0}, {"text": " Und was koennten diese Objekte sein?  Das ist das Angenehme an dieser objektorientierten Programmierung,  dass wir im Grunde genommen, wenn wir ueber das Problem reden, das wir gerne loesen wollen,  diese Objekte automatisch benennen muessen.  Gut, aber jetzt ist natuerlich die Frage, wie hilft mir eine Programmiersprache  moeglichst einfach, ein Problem zu realisieren, das auf Objekten basiert.", "start": 386.0, "end": 412.0}, {"text": "  Und dazu muessen wir jetzt versuchen, diese vier verschiedene Dinge, die wir haben,  irgendwie in einem Objektmodellierung zu bringen.  Und genau das wollen wir jetzt machen.  Also, wir haben verschiedene Dinge und ich war einfach das jetzt ja mal.", "start": 412.0, "end": 446.0}, {"text": " Wir hatten erstens, hatten wir die Menschen, ich weiss gar nicht mehr,  zweitens waren Bewegungsprofile, drittens hatten wir Begegnungen  und viertens hatten wir Orte.  Gut, also jetzt koennen wir uns ueberlegen, diese Bewegungsprofile sind immer assoziiert  mit einem Menschen, das heisst, wir haben in irgendeiner Weise ein Verhaeltnis  zwischen diesen beiden Dingen.", "start": 446.0, "end": 481.0}, {"text": "  Zwei oder mehr Bewegungsprofile sind assoziiert mit diesen Treffen.  Das heisst, wir koennen hier sagen, zwei oder mehr sind mit einem Treffen assoziiert.  Hier war das eins zu eins und wir koennen sagen, dass ein Treffen auch mit einem Ort assoziiert sein muss,  aber natuerlich kann an einem Ort viele Treffen stattfinden, also groesser, gleich eins.", "start": 481.0, "end": 512.0}, {"text": " Wir haben jetzt in weiss im Grunde genommen Objekte  und wir haben in blau irgendwelche Beziehungen zwischen diesen Objekten.  Und genau das bedeutet ist, dass wir jetzt diese Dingerung, die Beziehungen modellieren.  Wir brauchen dazu eine Art Sprache, um diese Beziehungen auszudruecken  und das werden wir gleich sehen.", "start": 512.0, "end": 531.0}, {"text": "  Aber wir koennen uns ja nochmal angucken, was diese Objekte tatsaechlich bedeuten.  Also wenn ich mir jetzt angucke, ich habe hier dieses Haus, das ist ein Objekt, ein Ort.  Es gibt hier aber verschiedene Arten von Orten.  Zum Beispiel koennten wir sagen, wir haben eine Schule.  Das soll eine Schule sein.  Meine Zeichenkuenste sind begrenzt.  Wir koennen sagen, wir haben ein Fussballstadion.", "start": 531.0, "end": 567.0}, {"text": "  Das soll ein Fussballstadion sein.  Oder was koennen wir noch haben?  Wir koennen sagen, wir haben ein Krankenhaus.  Das sind im Grunde genommen alles verschiedene Versionen von Orten,  die wiederum bestimmte Eigenschaften haben.  Und diese Eigenschaften koennen natuerlich wichtig dafuer sein,  was wir in der Anwendung programmieren wollen.", "start": 567.0, "end": 596.0}, {"text": " Das heisst, wir haben hier nicht nur ein Objekt,  sondern wir haben verschiedene moegliche Unterobjekte,  die aber eigentlich alle fuer ein Ort,  nennen wir das hier mal Ort, stehen koennen.  Also eine Schule ist ein Ort.  Ein Fussballstadion ist ein Ort.  Und ein Krankenhaus ist ein Ort.", "start": 596.0, "end": 623.0}, {"text": " Warum sollten wir das so aufzeichnen?  Nun, die Idee ist, dass wir unser Programm natuerlich so erstellen wollen,  dass es moeglichst einfach erweitert ist  und wir moeglichst wenig Fehler in der Programmierung machen.  Und deswegen ist es gut, wenn wir versuchen,  die Struktur der echten Welt in unserem Programm auf irgendeiner Weise abzubilden.", "start": 623.0, "end": 642.0}, {"text": " Und das machen wir hier, indem wir sagen,  alle diese drei Dinge, das Fussballstadion, die Schule und das Krankenhaus,  sind Orte.  Alle diese Orte haben eine Adresse.  Und vielleicht auch eine Telefonnummer.", "start": 642.0, "end": 671.0}, {"text": " Das heisst, wenn ich jetzt eine Klasse, ein Objekt programmiere,  das Ort heisst und Telefon und Adresse hat,  wie ich setzten und abfragen kann zum Beispiel,  dann wuerde es ja Sinn machen, dass auch eine Schule,  ein Fussballstadion und ein Krankenhaus  eine solche Telefonnummer und Adresse hat.", "start": 671.0, "end": 688.0}, {"text": " Wenn ich jetzt in all diesen vier verschiedenen Orten,  das separat programmieren muesste,  muesste ich jedes Mal, wenn sich zum Beispiel die Adresse aendert,  die Postleitzahl wird von fuenf auf acht Zahlen verlaengert,  muesste ich in jedem dieser verschiedenen Orte  eine Umprogrammierung vornehmen.", "start": 688.0, "end": 706.0}, {"text": " Und so ist aber die Idee, dass ich es einfach beim Ort mache  und die Schule, alle Eigenschaften des Ortes uebernimmt.  Dann brauche ich nur, in dem Ort zu aendern  und in allen drei davon abgeleiteten Orten  ist diese Veraenderung auch uebernimmt.", "start": 708.0, "end": 728.0}, {"text": " Ich spare mir also die mehrfache Programmierung  fuer Adresse und Telefon und ermoegliche,  dass ich, wenn ich die Adresse zum Beispiel aendern moechte,  also die Programmierung, die sich auf die Adresse bezieht,  aendern moechte, dass ich nur an einem Ort machen muss,  anstatt an allen anderen Orten.  Okay.", "start": 728.0, "end": 749.0}, {"text": " Wir haben also jetzt ueber Objekte gesprochen,  die es in der echten Welt gibt,  die wir versuchen, auf Objekte im Computer abzubilden.  Wir haben ueber Beziehungen zwischen diesen Objekten  in der echten Welt gesprochen, die wir hier in Blau gemalt haben.  Und natuerlich werden wir auch versuchen,  die in unserer Modellierung im Computer abzubilden.", "start": 749.0, "end": 766.0}, {"text": "  Wir haben aber noch ueber eine zweite Beziehung gesprochen,  und zwar die Beziehung zwischen Objekten im Computer,  die wir so strukturieren koennen,  dass uns doppelte Programmierung erspart bleibt  und dass die Veraenderung von der Programmierung  nur an einem einzelnen Ort passieren muss.", "start": 766.0, "end": 793.0}, {"text": " Und dann von Ort, das ist jetzt nicht klarer gewaehlt,  das Wort, in einem einzigen Programmteil  muss sich etwas aendern und dass alle anderen Programmteile,  die zu diesem Bezug stehen, wie hier zum Beispiel  Schule, Fussballzeit und Krankenhaus, im Bezug zum Ort steht,  wo ich also die Programmteile in den Ort veraendere  und automatisch alle anderen Orte,", "start": 793.0, "end": 809.0}, {"text": " Krankenhaus, Fussballzeit und Schule, diese Veraenderungen uebernehmen.  Gut, also ich hoffe, dass ihr jetzt so ein bisschen versteht,  warum die Fokussierung auf Objekte sinnvoll ist.  Erstens ermoeglicht uns, dass uns in der echten Welt danach zu orientieren,  wie wir unser Programm strukturieren sollten.", "start": 811.0, "end": 832.0}, {"text": " Und zweitens ermoeglicht dann auch der Seite des Computers  der Fokus auf diese Objekte auch tatsaechlich eine Erleichterung  der Programmierung und eine Verbesserung der Struktur des Programms,  wie wir gleich noch weiter sehen werden.  Okay, das haben wir jetzt durch mein nicht so talentiertes Gemahle  alles dargestellt.", "start": 832.0, "end": 853.0}, {"text": "Wir brauchen natuerlich ein bisschen  etwas formaler Art und Weise, mit der wir uns darueber austauschen koennen.  Und das passiert oft in der sogenannten Unified Modeling Language.  Das ist, wie der Name schon besagt, auch eine Sprache.", "start": 855.0, "end": 881.0}, {"text": " Es ist zwar keine Programmiersprache, in dem Sinne,  dass man das auf dem Computer eintippt und dann auf Start drueckt,  und ein Programm ablaeuft, aber in gewisser Weise ist es doch auch programmieren.", "start": 881.0, "end": 896.0}, {"text": " Es gibt zum Beispiel Software, die die ganzen Modelle, die wir gleich besprechen,  per Knopfdruck in ein gewisses Quellcode-Template verwandelt,  oder die auch einen bestehenden Quellcode nimmt und ihn in ein solches Modell umwandelt.  Okay, aber lass uns einfach mal angucken, wie diese Modelliersprache aussieht.", "start": 896.0, "end": 911.0}, {"text": "  Wir haben eben gerade von Objekten gesprochen, und Objekte sind irgendwie Dinge in der echten Welt.  Wir wollen natuerlich nicht jeden Ort und jedes Auto und jedes Objekt,  das wir in unserem Computer praesentieren wollen, von vorne an programmieren.  Das heisst, wir wollen im Grunde genommen eine Art Template entwickeln, die wir dann instanziieren koennen.  Diese Templates sind Klassen.", "start": 911.0, "end": 937.0}, {"text": "  Eine Klasse ist also das Template, aus dem wir Objekte instanziieren koennen.  Die Klasse definiert, wie ein Objekt auszusehen hat,  und in dem Moment, in dem ich eine Klasse benutze, um ein tatsaechliches Objekt zu schaffen, im Speicherplatz.  Das hat dann tatsaechlich Variablen, Methoden usw. und so fort.  Dann instanziieren die Klasse in einem Objekt.", "start": 937.0, "end": 960.0}, {"text": "  Wir schauen uns also mal ganz kurz an, wie wir so eine Klasse definieren koennen.  In UML passiert das, indem wir so ein Rechteck hier malen, das verschiedene Unterkaesten hat.  Im obersten Kasten ist der Name der Klasse.  Hier nicht so einfallsreich, meine Klasse.  Hier stehen die Members, Mitglieder oder die Variablen, wenn man so moechte, die in dieser Klasse definiert werden.", "start": 960.0, "end": 990.0}, {"text": "  Wir haben ein Attribut, das ist ein Integer, wir haben ein zweites Attribut, das ist Float,  und wir haben ein drittes Attribut, Circle.  Und dann haben wir natuerlich auch bestimmte Methoden, ob 1, ob 2, ob 3,  wie verschiedene Innen- und Ausparameter haben und die bestimmte Werte zurueckliefern.", "start": 990.0, "end": 1011.0}, {"text": "  Das heisst, wir definieren eine Klasse, dadurch dass wir sagen, diese Klasse besteht aus bestimmten Bewerten  und aus bestimmten Methoden, die auf diesen Werten operieren.  Eine Klasse buendelt also die Eigenschaften eines Objekts,  und diese Eigenschaften werden als Variablen gespeichert,  und sie buendelt diese Eigenschaften mit den Methoden, die auf diesen Eigenschaften ausfuehrbar sind.", "start": 1011.0, "end": 1047.0}, {"text": "  Und im Grunde genommen beschreibt dieses Diagramm das Interface, das ich habe, um mit einer Klasse zu interagieren.  Hier gibt es noch ein paar Feinheiten, zum Beispiel dieses Plus hier, das sagt, dass das Attribut auch von aussen gesehen werden kann.", "start": 1047.0, "end": 1068.0}, {"text": " Das Attribut 2 wegen des Minus kann nicht von aussen gesehen werden,  und dieser Hashtag heisst Protected und bedeutet, dass Attribut 3 nicht von aussen gesehen werden kann,  aber von allen Klassen, die abgeleitet sind aus dieser Klasse. Dazu reden wir gleich.  Also die Idee ist, dass alles, was in diesem Kasten steht,  ist, was man als Programmierer wissen muss, um eine Klasse zu verwenden.", "start": 1068.0, "end": 1096.0}, {"text": "  Und das ist der Sinn von Abstraktion. Unabhaengig davon, wie diese ganzen Dinge implementiert sind,  kann ich mir diese Definition der Klasse anschauen und kann verstehen, was macht denn ein Objekt, das ich aus dieser Klasse instanziere.  Dieses Diagramm ist also eigentlich die Anleitung, wie ich Objekte dieser Klasse verwenden kann.", "start": 1096.0, "end": 1129.0}, {"text": "  Okay, das heisst, wir haben jetzt eine Definition von einer Klasse, die wir ableiten aus einer Objektart in der echten Welt  und wir beschreiben die Funktionalitaet dieser Objektart, indem wir die Attribute und die Methoden in dieser Klasse Definition festhalten.", "start": 1129.0, "end": 1162.0}, {"text": " Okay, jetzt hatten wir hier diese Idee, dass wir das Ganze hier out genannt haben,  dass wir hier eine Telefonnummer hatten, dass wir eine Adresse hatten und so weiter.  Und jetzt koennte man zum Beispiel bestimmte Operationen hier definieren wie SetAddress.  Das ist, wenn man dieses abstattete Beispiel mal ein bisschen konkreter macht.", "start": 1162.0, "end": 1192.0}, {"text": "  Gut, in dem Beispiel vorher hatten wir ja einen Ort und wir hatten dann im Grunde genommen noch andere Klassen definiert.  Wir hatten die eine Schule genannt und wir hatten eine Stadion genannt und so weiter.  Und die Idee war natuerlich, dass die in irgendeiner Weise mit der Klasse Ort in Beziehung stehen.  Und genau darueber reden wir jetzt.", "start": 1192.0, "end": 1222.0}, {"text": "  Wir haben naemlich eine sogenannte Veraermungsheraichie, ein Klassendiagramm.  Hier illustriert am Beispiel von Zellen.  Zuerst schauen wir uns vielleicht mal kurz hier auf der rechten Seite an die verschiedenen Assoziationen, die verschiedenen Verhaeltnisse, die es zwischen verschiedenen Klassen geben kann.", "start": 1222.0, "end": 1243.0}, {"text": "  Assoziation ist eine Abhaengigkeit, Generalisierung, Realisierung, das sind die vier Moeglichkeiten.  Wir schauen uns aber jetzt mal kurz die Generalisierung an.  Denn das ist genau der Pfeilkopf, den wir hier auf der linken Seite in diesem Diagramm haben.  Wir haben also ganz oben eine Klasse, die heisst Zelle.  Diese Klasse hat drei sogenannte Unterklassen.", "start": 1243.0, "end": 1272.0}, {"text": "  Eine Muskelzelle, eine Blutzelle und eine Nervenzelle.  Das sind drei verschiedene Typen von Zellen.  Aber alle drei sind auch Zellen.  Also eine Blutzelle ist natuerlich auch eine Zelle.  Die Blutzellen wiederum unterteilen sich in rote und weisse Blutgloebige.  So was hat es jetzt fuer einen Vorteil, dass wir so eine Klassenheraichie ...  erstellen.", "start": 1272.0, "end": 1313.0}, {"text": "Welches Ziel hat das?  Wie schon eben beschrieben.  Zum Beispiel koennen wir sagen, alle Zellen haben eine DNA.  Das gilt natuerlich fuer die Allgemeinizelle, das gilt aber auch fuer alle Unterzellen.  Und nun koennen wir alle Sachen, die mit DNA zu tun haben, hier oben definieren.  Und weil wir sagen, eine Blutzelle ist eine Generalisierung.", "start": 1313.0, "end": 1343.0}, {"text": "  Also die ist eine Instanz, ist eine ... ist eine Generalisierung, bestimmt gar nicht.  Das ist genau andersherum.  Die Zelle ist natuerlich das generellere Klasse.  Und die Blutzelle ist eine Spezialisierung dieser Zelle.  Aber wir koennen alles, was mit DNA zu tun hat, in der Zelle definieren.  Und wir sagen, dass die Blutzelle vererbt.  Vererbt alle Eigenschaften der Zelle.", "start": 1345.0, "end": 1373.0}, {"text": "  Genauso wie dann die weisse Zelle, also die klasse-weite Blutzelle.  Die Eigenschaften von Blutzell vererbt.  Und die Eigenschaften von Blutzell setzen sich natuerlich zusammen aus den Dingen,  die die Zelle selbst, die die Blutzelle von Zelle vererbt hat.  Und die, die in Blutzell zusaetzlich noch definiert wurden.", "start": 1373.0, "end": 1400.0}, {"text": " Das heisst, wenn wir diesen Baum von oben nach unten entlangwandern,  dann ergeben sich immer weitere und spezifische Funktionalitaeten.  Und somit ist eine weisse Blutzelle spezifischer als eine Blutzelle.  Und wiederum spezifischer als eine Zelle.  Wie gesagt, der Vorteil ist, dass wir alles, was mit DNA zu tun hat,  nur einmal programmieren muessen in der Zelle.", "start": 1400.0, "end": 1422.0}, {"text": "  Ganz automatisch, so wie dieser Baum aufgebaut ist,  haben alle anderen Klassen, die abgeleitet sind von der Zelle,  alle Funktionalitaet bezueglich der DNA automatisch mit geerbt.  Wenn also jetzt eine neue wissenschaftliche Erkenntnis es erforderlich macht,  dass wir etwas zu der DNA Verarbeitung in der Zelle hinzufuegen,  dann muessen wir das nur genau einmal machen, naemlich in der Zelle.", "start": 1422.0, "end": 1451.0}, {"text": "  Nun, aber was wuerde passieren, wenn wir rausbekemen,  dass die DNA Verarbeitung in Nervzellen anders funktioniert  als in den ganzen anderen Zellen?  Gut, lebst dann haetten wir immer noch die Moeglichkeit,  in einer bestimmten Klasse, hier in der Klasse Nervenzelle,  das zu ueberschreiben, was die Zelle definiert hat.", "start": 1451.0, "end": 1477.0}, {"text": " Wir verlieren also keine Flexibilitaet, die Winn aber die Moeglichkeit,  Programmierarbeit zu sparen, Fehler auszuschliessen  und unseren Code sehr viel einfacher modifizierbar zu machen.  Okay, vielleicht nochmal ein...  Das ist Vererbung, Polybophismus habe ich noch nicht erklaert,  was das bedeutet.", "start": 1477.0, "end": 1506.0}, {"text": " Das ist Vererbung, also Vererbung ist, wenn wir die Klasse,  die wir benutzen und programmieren, so anordnen,  dass wir die Funktionalitaet, die in einer hoeheren Klasse erstellt ist,  in den niedrigeren Klasse verwenden koennen.  Ein ganz wichtiges Feature von Java und von allen objektorientierten  Programmiersprachungen, die ist der sogenannte Polymorphismus.", "start": 1506.0, "end": 1529.0}, {"text": "  Polymorphismus basiert genau auf diesen Klassendiagramm,  auf dieser Hierarchie aus Klassen.  Und er benutzt ganz genau diese Funktionalitaet aus,  das wir gesagt haben, wenn wir in der Zelle was definieren,  dann erben alle der abgeleiteten Klassen diese Funktionalitaet ganz automatisch.", "start": 1529.0, "end": 1557.0}, {"text": " Das heisst, wenn ich jetzt also in irgendeiner Weise in meinem Programm  ein Objekt definiere, ein Objekt des Typszelle,  das heisst, wir benutzen den Klassennamen als Typen.  Genauso wie wir Integer haben oder Float oder Boolean,  wird durch die Definition einer Klasse ein neuer Typ geschaffen,  in diesem Fall der Typzelle.", "start": 1557.0, "end": 1585.0}, {"text": " Wenn ich jetzt irgendwo in meinem Programm eine Variable verwenden moechte,  wie vom Typzelle ist, dann kann in diese Variable  ein Objekt gespeichert werden, das von allen daraus abgeleiteten Zelltypen ist.  Denn wir koennen uns diese Pfeile hier vorstellen,  wir koennen sie lesen als isA.  Also ein Blutcell ist ein cell.", "start": 1585.0, "end": 1612.0}, {"text": " Das heisst, wo immer eine Zelle stehen darf,  darf auch eine Blutcell stehen, denn eine Blutcell ist ja eine cell.  Das heisst, ich kann einen Programm schreiben,  indem ich den Variable Typzelle benutze,  aber in einem bestimmten Aufruf als Parameter eine weisse Blutcelle verwenden,  die in diese Methode hineingeben.", "start": 1612.0, "end": 1635.0}, {"text": " Und das Programm laeuft ganz normal durch,  als ob die white blood cell ein Objekt vom Typzelle waere.  Ist sie naemlich auch.  Und genau das heisst Polymorphismus.  Poly sind mehrere Formen.  Das heisst, eine Variable des Typzelle kann mehrere Formen haben,  naemlich alle Formen von den Unterklassen dieser Zelle.", "start": 1635.0, "end": 1662.0}, {"text": " Und jetzt ist es auch irgendwie einleuchten,  dass wenn ich zum Beispiel eine Funktion auf Ufuf,  eine Variable, die Zelle, heisst, im Bezug auf die DNA,  und das, was in meiner Variable vom Typzelle drin gespeichert ist,  ist aber eine weisse Blutcelle,  dass dann natuerlich nicht die Methode der DNA von hier oben aufgerufen wird,  sondern die Methode der DNA, die hier unten drin ist.", "start": 1662.0, "end": 1692.0}, {"text": "  Das kann entweder im Fall von white blood cells genau die gleiche sein,  oder wir hatten ja gesagt, bei den Nervenzellen muessten wir das ueberschreiben,  weil Nervenzellen in irgendeiner Weise etwas anders machen mit der DNA.", "start": 1692.0, "end": 1712.0}, {"text": " Das heisst, wenn ich in dem Objekt, in der Variable vom Typzelle,  eine Nervenzelle drin habe, dann wuerde eine andere Methode aufgerufen werden,  als bei der white blood cell.  Das alles regelt aber Java fuer uns.  Wir muessen uns darum nicht kuemmern.  Es wird immer die richtige DNA Methode aufgerufen,  solange wir das in dieser Programme, in dieser Klassen-Hierarchie richtig erstellt haben.", "start": 1712.0, "end": 1733.0}, {"text": "  Okay, wir schauen uns vielleicht nochmal ein weiteres Beispiel an,  wie man mit diesen Klassenprogrammen beschreiben kann.  Hier ist ein Beispiel fuer ein Spreadsheet.  Wir haben also eine Klasse, die heisst Spreadsheet.  Einfach hat halber, sind hier weder die Members noch die Methode spezifiziert.  Davon gibt es genau eins.", "start": 1733.0, "end": 1761.0}, {"text": "  Und dieses Spreadsheet Contain enthaelt also ganz viele Objekte des Typzelle.  Jetzt ist jetzt eine andere Zelle, das ist die Zelle aus dem Beispiel davor.  Jede dieser Zellen hat eine Expression in sich assoziiert,  und zwar genau eine.  Eine Zelle ist eine Expression zugeordnet  und entsprechend ist dieser Zelle auch ein Wert zugeordnet.", "start": 1761.0, "end": 1787.0}, {"text": "  Dieser Wert ergibt sich aus der Expression durch eine Evaluation.  Das heisst, im Grunde genommen haben wir hier dargelegt,  anhand der Unified Modeling Language,  mit Hilfe von diesem Klassendiagramm, wie man ein Spreadsheet aufbauen kann.  Natuerlich gibt es hier noch ganz viele Unterdetails,  gibt ganz viele verschiedene Arten von Pfeilen usw.", "start": 1789.0, "end": 1813.0}, {"text": "  Aber die Idee ist, dass wir diese Art von Modell, von grafischer Darstellung benutzen koennen,  um eine gewisse Struktur in meinem Programm abzubilden.  Die Universal Modeling Language besteht aus ganz, ganz vielen verschiedenen Arten von Diagramm.  Also wir haben hier wieder eine Art Klassenherarchie.  Wir haben einen UML Diagramm Type.", "start": 1813.0, "end": 1837.0}, {"text": " Da gibt es die sogenannten strukturellen Diagramme,  oder die statischen Diagramme,  und die Behavior oder die dynamischen Diagramme.  Wir haben das Klassendiagramm schon kennengelernt.  Wie ihr seht, gibt es eine ganze Reihe von anderen.  Und eine Sache, die wir gleich uns noch angucken,  ist bei den dynamischen oder den Behavior Diagrammen,  ist das Use Case Diagramm.", "start": 1837.0, "end": 1859.0}, {"text": "  Aber vielleicht vorher ganz kurz, was soll das?  Warum haben wir so viele verschiedene Diagramme,  um im Grunde genommen die Struktur von einem Programm abzubilden?  Denn das Programm selbst bildet ja schon so ein leichter Klub.  Warum brauchen wir diese ganze Art der Visualisierung?  Nun, es hat sich herausgestellt,  dass man nicht sehr viele Zeilen-Quelcode  gleichzeitig sich angucken kann.", "start": 1859.0, "end": 1890.0}, {"text": "  Und dass dadurch, gegeben durch die kognitiven Beschraenkungen  von Menschen, die ganze Struktur des Programms  nicht einfach ueberblickbar ist.  Und man benutzt also diese ganzen Diagrammen,  um bestimmte Aspekte des Programms, des gesamten Quelcos,  grafisch darstellen zu koennen, damit der Mensch sie einfacher erfassen kann.  Das ist keine wirklich ganz neue Idee.", "start": 1890.0, "end": 1917.0}, {"text": "  Wenn ihr euch ueberlegt, in der Architektur ist das ganz genauso.  Es ist nicht so, dass alle Leute, die ein Haeusern bauen,  mit einem echten 1 zu 1 Modell dieses Hauses planen,  sondern die haben Skizzen, die sind verschieden.  Es gibt den Aussenansicht,  die ist vielleicht fuer die Stadtplanung wichtig.  Es gibt den Grundriss, der ist fuer das Bauen wichtig.", "start": 1917.0, "end": 1943.0}, {"text": "  Dann gibt es bestimmte Grundrisse, in denen die elektrischen Kabeln  eingezeichnet sind und so weiter.  Es gibt also fuer jedes Gewerk, auf dem Bau,  gibt es spezifische Bauplaene.  Das heisst, also auch dort ist es klar sinnvoll,  bestimmte Aspekte eines Gesamtgebildes abbilden zu koennen,  um sie besser verstehen zu koennen.  Genau das ist das Ziel der Unified Modelling Language.", "start": 1943.0, "end": 1972.0}, {"text": "  Deswegen bietet diese Unified Modelling Language  so viele verschiedene Versionen,  weil jede dieser Versionen ein anderen Aspekt  des Gesamtgebildes abbilden.  Wie gesagt, wir haben die Klassend diagramme kennengelernt  und gucken uns nochmal News Case diagramme an,  nur um die Fuehle zu bekommen.", "start": 1972.0, "end": 2013.0}, {"text": " Wir werden innerhalb dieses Kurses  diese ganze USML-Geschichte nicht unbedingt weiter vertiefen,  aber wenn ihr spaeter mal fuer ein Jobinterview euch hier vorstellt,  sind solche Dinge zu wissen absolut essentiell.", "start": 2013.0, "end": 2029.0}, {"text": " Viele Firmen benutzen UML,  um die Softwareentwicklung robuster, effizienter zu machen,  auch um ein Team ueber bestimmte Designentscheidungen,  was die Software angeht, diskutieren zu koennen  und dann die beste Entscheidung treffen zu koennen.  Also was wir euch hier beibringen,  ist auf jeden Fall verwendet in der Industrie.", "start": 2029.0, "end": 2044.0}, {"text": " Wir haben jetzt eine statische, strukturelles Diagramm gesehen  und wir schauen jetzt mal eine Art dynamisches Diagramm an,  aber nur ganz oberfaechlich, naemlich das Use Case diagramme.", "start": 2044.0, "end": 2068.0}, {"text": " Also wir haben hier eine, wie sagt man dazu,  eine Vending Machine,  eine Vending Machine, da sind verschiedene Dinge drin  und die Frage ist, welche Use Cases gibt hier?  Was ist ein Use Case?  Ein Use Case ist sozusagen ein typische Art und Weise,  ein Objekt zu benutzen.", "start": 2068.0, "end": 2079.0}, {"text": " Bei Use Case geht es normalerweise nicht darum,  die ganzen Einzelfaelle und die ganzen Probleme,  die auftreten, koennen zu erfassen.", "start": 2079.0, "end": 2105.0}, {"text": " Man kann es geht darum, klar zu beschreiben,  was ist hier das Ziel?  Was soll als Funktionalitaet ermoeglicht werden?  Und jetzt die Frage, wie viele Use Cases gibt es denn  bei einer Vending Machine und was sind die?  Vielleicht haltet ihr kurz das Video an und denkt mal drueber nach.", "start": 2105.0, "end": 2120.0}, {"text": " Aber es ist auch jetzt nicht unglaublich kompliziert,  das erste Use Case oder der erste Use Case ist by something.  Das ist ja klar.  Und jetzt kann man das aufschluesseln, was genau die Schritte sind  und jetzt kommt die dynamische Komponente,  die zeitliche Komponente rein.", "start": 2120.0, "end": 2139.0}, {"text": " Also schmeisst man erst das Geld rein  oder drueckt man erst die Zahlen  und dann sagt man, wie viel Geld man reinbekommen,  wie viel Geld man zahlen muss  und wann kommt das Wechselgeld und so weiter.  Das muss man jetzt in diesem Use Case ganz klar festlegen,  eine normale Benutzung, wie sieht die aus?  Hier gibt es aber noch ein zweiter Use Case  und das ist die Befuellung.", "start": 2139.0, "end": 2158.0}, {"text": "  Und natuerlich hat dieser zweite Use Case  ganz andere Anforderungen als der erste.  Man muss also die Tuer oeffnen koennen,  man muss einspeichern koennen,  wie viele verschiedene Dinge von einer Sorte sind noch da,  damit man nicht beim leeren Regal immer noch Geld rein tut  und Tachen rausbekommt.  Das sind ganz andere Dinge,  die man bei diesem zweiten Use Case abdecken muss.", "start": 2158.0, "end": 2188.0}, {"text": "  Und ich denke, wir haben bei dieser Vending Machine  mit diesen beiden Use Case eigentlich alles abgedeckt  und wir koennten jetzt zwei Teams bilden,  das eine, das den ersten Use Case anarbeitet  und das zweite, das den zweiten Use Case ausarbeitet,  die dann wieder zusammenkommen,  ihre Use Case Diagramme vergleichen  und gegenseitig diskutieren.", "start": 2188.0, "end": 2216.0}, {"text": " Okay, bevor wir zum Ende kommen,  moechte ich noch eine Sache sagen,  die immer wieder missverstanden wird,  die aber eigentlich ganz einfach ist, was Java angeht.  Das hat jetzt eigentlich gar nichts mit objektorientiertem Programmierung zu tun,  das ist nur eine Eigenschaft von Java,  die man sich einfach merken sollte.  Und das ist, Java ist immer call by value.", "start": 2216.0, "end": 2247.0}, {"text": " Was bedeutet das?  Wenn ich eine Methode aufrufe  und dazu ein Parameter uebergebe,  kann ich entweder den Wert des Parameters uebergeben?  Das ist call by value.  Oder ich kann eine Referenz zu diesem Wert  ins h oder c++ waere das vielleicht ein Pointer,  eine Referenz zu diesem Wert uebergeben.  Das waere call by reference.  Nun ist es so, Java ist immer call by value.", "start": 2247.0, "end": 2281.0}, {"text": "  Das heisst, wenn ihr irgendetwas an eine Methode uebergibt,  wird immer der Wert kopiert.  Der Wert wird uebergeben.  Und das war es. Es gibt keine Alternative dazu.  Nun ist das Problem, dass wir hier eine Bedeutungskollision des Wortes Referenz haben.  In Java werden Objekte mit Referenzen behandelt.  Also wenn ja eine Objektvariabe definiert,  dann haelt diese Variable als Wert, eine Referenz.", "start": 2281.0, "end": 2319.0}, {"text": "  Wenn ich jetzt aber diese Referenz als Parameter uebergeben moechte,  dann wird der Wert dieser Referenz uebergeben  und nicht der Speicherplatz,  in dem dieser Referenz urspruenglich gespeichert wird.  Also das heisst, auch eine Referenz wird per call by value uebergeben.", "start": 2319.0, "end": 2351.0}, {"text": " Denn call by value und call by reference bezeichnet die Art und Weise des Uebergebens des Parameters  und nicht was da als Parameter uebergeben wird.  Daher kommt die Verwirrung.  Auch eine Referenz wird in Java call by value uebergeben.", "start": 2351.0, "end": 2371.0}, {"text": " Das ist vielleicht jetzt so ein bisschen euch noch nicht klar, was das bedeutet,  wenn ihr anfaengt in Java zu programmieren und wenn ihr anfaengt Objekte in Methoden zu uebergeben,  dann koennt ihr euch kurz vor Augen fuehren,  dass ihr diese Referenz zu dem Objekt als Wert uebergebt.  Nicht als Referenz auf den Speicherplatz, in dem die Referenz gespeichert ist.", "start": 2371.0, "end": 2393.0}, {"text": "  Okay, das Einzige, was ihr euch merken muesst, ist, Java ist immer call by value.  Okay, also wir haben versucht heute,  uns dem Thema Objektorientierte Programmierung anzuwenden, anzunehren.  Wir haben darueber gesprochen, dass es Klassen gibt.  Diese werden instanziiert.  Das war jetzt falsch.  Instanziiert.  Ich glaube so schreibt man das zu Objekten.", "start": 2393.0, "end": 2441.0}, {"text": "  Das heisst, die Klasse ist die Definition des Templates, die Struktur.  Und wenn wir das instanzieren, dann schaffen wir ein Objekt, das entsprechend dieser Struktur geschaffen wird.  Nur ein Objekt hat tatsaechlich einen Platz im Speicher.  Eine Klasse ist einfach nur eine Definition.  Nur wenn sie instanziert ist, existiert sie real im Rechner und kann von euch benutzt werden.", "start": 2441.0, "end": 2470.0}, {"text": "  Wir haben gesehen, dass es Klassenhierarchien gibt.  Und dass die eine ganze Reihe von Funktionen erfuellen.  Also das eine ist, dass sie uns das Leben leichter machen soll.  Dadurch, dass wir bestimmte Dinge nur einmal programmieren muessen.  Und dann aus einer Klasse, abgeleitet unter Klasse, das was sie programmiert haben, mit uebernehmen koennen.  Das spart uns Arbeit.", "start": 2470.0, "end": 2504.0}, {"text": "  Sowohl beim Programmieren, als auch Arbeit beim Modifizieren des Programms,  weil wir nur einen Ort haben, an dem eine Funktionale implementiert ist.  Wir haben gesehen, dass wir mit UML verschiedene Blickwinkel auf Quellcode einfach visualisieren koennen.  Das heisst, es ist immer eine gute Idee, bevor man anfaengt zu programmieren,  zu versuchen, ein UML Diagramm zu erstellen.", "start": 2504.0, "end": 2535.0}, {"text": "  Weil in einem UML Diagramm ein Pfeil von A nach B zu biegen,  oder eine neue Methode hinzuzufuegen oder ein Attribut zu veraendern, kostet genau vier Sekunden.  Waehrend ein riesiges Programm umzustellen, oder gar eine ganze Klassenhierarchie umzustellen,  indem man den Java Code aendert, unglaublich viel aufwendiger wird.", "start": 2535.0, "end": 2555.0}, {"text": "  Das heisst, genau wie Architekten nicht einfach ein Haus irgendwo auf die Heide bauen,  koennen wir als Informatiker und Informatikerinnen diese Programmierprache, UML, diese Modellierungssprache benutzen,  um Dinge auf einer abstrakten Ebene zu durchdenken, um moeglichst frueh Fehler zu vermeiden.  Und dann haben wir noch gesagt, Java ist Call by...  Nee, das schreibe ich mal aus.  Call by value.", "start": 2555.0, "end": 2591.0}, {"text": "  Immer.  Okay.  Also, das heisst, ihr solltet jetzt ein bisschen besser verstehen, wie wir die Features von objektorientierte Programmierungen benutzen koennen,  um das Ziel, was wir als Informatiker und Informatikerinnen haben, umzusetzen.", "start": 2591.0, "end": 2627.0}, {"text": " Naemlich, dass wir Probleme in der echten Welt erkennen, verstehen, modellieren mit den Werkzeugen der objektorientierten Programmierungen  und dadurch Programme erstellen, wie wir uns helfen, diese Probleme zu loesen.  Gut, ich danke dir fuers Zuhoeren und wir sehen uns bald wieder.", "start": 2627.0, "end": 2633.0}]}]