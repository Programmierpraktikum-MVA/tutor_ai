[{"lecture": "31624_60_course_video", "Timestamps": [{"text": "  Dieses Video zeigt an einem etwas komplexeren Beispiel, wie man mit dem Debagger auf Fehler-Suche  in Java-Programmen geht. Dazu moechte ich ein kleines Programm schreiben, was mehrere Objekte  in eine Warteschlange, also in eine Queue einspeist. Diese Objekte sollen vom Typ Position sein. Das ist  hier die Klasse, die die beiden Instanzvariablen x und y enthaelt.", "start": 0.0, "end": 40.72}, {"text": "Das koennen zum Beispiel die  Koordinaten auf einem Spielbrett sein. Und die Klasse Position hat zwei Methoden, einmal ein  Konstruktor Position, der die beiden x und y Koordinaten uebergeben kriegt. Und es wird die  Methode toString ueberschrieben, damit Positionen auf dem Bildschirm ausgegeben werden koennen.  Hier moechte ich also eine Queue herstellen, die Objekte vom Typ Position bekommen kann.", "start": 40.72, "end": 69.32000000000001}, {"text": "Mit  Alt-Enter kann ich hier erreichen, dass automatisch der richtige Importfunktion eingefuegt wird. Die  Variablen nenne ich Queue. Und jetzt muss ich einen Konstrukte aufrufen, um eine Queue zu  konstruieren. Allerdings ist hierbei zu beachten, dass Queue in Java ein Interface ist und keine eigene  Klasse ist. Das heisst, wir brauchen nun eine Klasse, die diese Interface Queue implementiert.", "start": 69.32000000000001, "end": 99.96000000000001}, {"text": "Und  da ist eine gute Wahl die Linked List. Ich hier auch verwenden werde. Und nun mache ich eine Schleife,  um mehrere Positionen in die Queue einzuspalten. Ich nehme drei Elemente und verwende die Methode  Add von Queue, um die hinzuzufuegen.", "start": 99.96, "end": 126.8}, {"text": "Hier braucht eine Position und ich nehme die Positionen mit  den Koordinaten 0,i, um zu sehen, ob das funktioniert hat. Ich moechte jetzt die Positionen, die in der  Queue gespeitert sind, ausgeben. Dazu kann ich mir zu Nutze machen, dass das Interface Queue, das  Interface Iterable, implementiert. Das heisst, wir koennen direkt ueber die Queue iterieren.", "start": 126.8, "end": 146.28}, {"text": "Dann ist  die Lauffallvariabel also vom Typ Position in Enttier POS und gebe hier mit dem Doppelpunkt an,  dass sie ueber die Queue laufen soll. Und dann gebe ich mit System Out. Ich mache die Ausgabe,  Position ist enthalten und ich lasse mit Steuerung Shift F10 das Programm laufen. Und wie erwartet,  wird ausgegeben, 0,0,0,1,0,2 sind in der Queue enthalten.", "start": 146.28, "end": 187.51999999999998}, {"text": "Nun machen wir eine Art Gegentest und  nehmen eine Position P, die auf jeden Fall nicht enthalten ist, sagen wir zum Beispiel 0,5 und gucken,  ob die Position enthalten ist oder nicht. Dafuer gibt es die Methode Contains in dem  Interface Queue.", "start": 187.51999999999998, "end": 216.64000000000001}, {"text": "Also mit Queue Contains P wird uns der Wahl schwer zurueckgegeben, ob P in der Queue  drin ist oder nicht. Und das gebe ich hier auch auf dem Bildschirm aus, also ist enthalten und die  Frage wird beantwortet durch die Bultschewariabe drin. Wenn ich das nun auch laufen lasse,  wie erwartet, die Position 0,5 ist nicht enthalten.", "start": 216.64000000000001, "end": 239.12}, {"text": "Zweiteren Test gucke ich, was jetzt passiert,  wenn ich hier eine Position nehme, die auf jeden Fall enthalten sein sollte, 0,0 und hier ist es aber  jetzt so, dass auch angezeigt wird, 0,0 ist nicht enthalten. Das ist jetzt nicht so gedacht, also  ein Fall fuer den Debugger. Ich setze einen Break Porn und starte einen Debugdurchlauf.", "start": 239.12, "end": 261.24}, {"text": "Hier sehen  wir wieder die Variabeln unten im Debug Fenster. Die Darstellung ist jetzt etwas komplexer, weil wir  hier nicht mehr primitive Datentypen haben, sondern Objekte von Referenztypen und hier fuer die Queue  wird zum Beispiel angezeigt, dass sie ein Objekt vom Typ Link List ist und das die Laenge 3 ist.", "start": 261.28000000000003, "end": 276.76}, {"text": "Und  wenn ich sehen will, was in der Queue drin ist, klick ich auf das Dreieck. Hier werden jetzt drei  Objekte vom Typ Position angezeigt mit den entsprechenden Speicherspositionen und hier wird  die ueberschriebene Methode Two String verwendet, um direkt die Positionen auch hier anzeigen zu  koennen.", "start": 276.76, "end": 301.6}, {"text": "Ansonsten kann man auch hier nochmal eine Ebene tiefer gehen und die Instanzvariabeln  des jeweiligen Objekts anschauen. Das ist aber hier nicht noetig, weil die Information hier schon  enthalten ist. Hier unten sehen wir auch, dass die Position P, die Koordinaten 0,0 hat, genau wie  das erste Element der Queue.", "start": 301.6, "end": 319.6}, {"text": "Deswegen ist es hier ueberraschend, dass jetzt es drin zufolgs  evaluiert wird. Das drin kriegen wir hier aus der Methode Contains geliefert. Das heisst, wir  sollten uns mal die Dokumentation von Contains angucken.", "start": 319.6, "end": 343.0}, {"text": "Das geht mit Steuerung Q und hier steht  Returns True, if and only if this collection contains at least one element e suchedObjects  equals 0,i. Das heisst, hier ist relevant die Methode Equals, um der Sache jetzt weiter auf  den Grund zu gehen. Nehmen wir jetzt die Position aus der Queue, die mit P gleich sein sollte.", "start": 343.0, "end": 360.52}, {"text": "Das ist  hier das erste Element der Queue, 0,0. Das kriegen wir hier einfach indem wir die Methode Queue.peak  nehmen. Wir haben hier die Variable vergessen. Queue gleich Peak. Damit kriegen wir jetzt das Element von  der Spitze der Queue geliefert und gucken, ob die gleich sind.", "start": 360.52, "end": 401.36}, {"text": "Also das soll jetzt ein Q equals P,  dass wir uns auf dem Bildschirm ausgeben, ob die gleich sind. Also sind U und P gleich.  Und die Antwort wird durch die Pulse Variable gleich geliefert. Ich starte wieder den Debakt  durchlauf. Dafuer muss der alte gestoppt werden.", "start": 401.36, "end": 422.76000000000005}, {"text": "Er stoppt an unserem Breakpoint, bis dann hat sich  nichts geaendert. Also wirklich jetzt hier gerade mal F8. Damit wir ans Ende kommen. Wir sehen,  Q ist in der Tat auch eine Position 0,0, genau wie P. Dieses Q ist jetzt das was von der Spitze  der Warteschlange genommen wurde. Und trotzdem wird aber hier gleich zu false evaluiert.", "start": 422.76000000000005, "end": 446.96}, {"text": "Also  obwohl Q und P dieselben Positionen repraesentieren wird, Q equals P zu false ausgewert. Um diese  Sachen nun auf und rund zu gehen, sollten wir gucken, welche Implementation denn hier konkret  genutzt wird. Und dazu kriegt man die rechte Maustaste und waehlt dann go to Implementation  aus. Und hier sucht jetzt die IDE, welche Methode genau fuer diesen Equals Aufruf zustaendig ist.", "start": 446.96, "end": 469.24}, {"text": "  Und hier sehen wir nun, dass es die Equals Methode aus dieser Grundklasse Object ist. Und die  testet nur auf diese einfache Gleichheit, die bei Referenztypen die Gleichheit der Speichersposition  ist. Und die ist bei P und Q tatsaechlich nicht gleich.", "start": 469.24, "end": 499.44}, {"text": "Damit wir eine sinnvolle,  semantische Definition von Equals bekommen fuer Positionsobjekte, muessen wir diese Methode  Equals in Position implementieren. Also ueberschreiben. Dafuer habe ich jetzt erstmal kopiert und  aendere jetzt die Implementation. Wir nehmen ja an, dass hier das Objekt, was uebergeben wird,  von PIP Position ist.", "start": 499.44, "end": 525.4399999999999}, {"text": "Also cast sich das Eingabeargument Object zu Position und dann ersetzt  ich hier den Gleichheitstest von Speicherbereichen auf den Test ob x und y Positionen uebereinstimmen.  So, ich lasse wieder das Programm laufen. Hier sehen wir jetzt, dass es drin tatsaechlich  zu true evaluiert wird.", "start": 525.4399999999999, "end": 551.72}, {"text": "Und wenn ich weiter im Code mich vorbeite, sehe ich auch, dass hier  gleich zu true evaluiert wird. Also jetzt mit dieser Implementation von Equals in Position  funktioniert der Test auf Gleichheit und der Contains Test fuer eine Q so wie erwartet. Es gibt  aber noch einen kleinen Schoenheitsfehler.", "start": 551.72, "end": 569.72}, {"text": "Die Implementation von Equals ist ja nicht so ganz,  wie gedacht, weil ich hier einfach davon ausgehe, dass das uebergeben Eingabearobjekt vom  Typ Position ist oder das dahin casten laesst jedenfalls. Das sollte aber so nicht sein. Man sollte  so implementiert sein, dass beliebige Eingabearobjekte vernuenftig bearbeitet werden.", "start": 569.72, "end": 589.08}, {"text": "Dafuer ist  dann die Implementation etwas komplexer, aber gluecklicherweise hilft uns da die IDE. Wenn ich  hier auf Generate und dann Equals gehe und hier alle Vorschlaege uebernehme, kriege ich hier eine  wunderbare Implementierung von Equals automatisch generiert. Wir sehen der wesentliche Teil hier  unten. Es ist genau derselbe Code, den ich vorhin verwendet habe.", "start": 589.08, "end": 617.28}, {"text": "Aber die ersten beiden Zahlen  pruefen noch, ob das Objekt von der richtigen Klasse ist oder ob es null ist und somit erhaelt  mal eine sinnvolle Implementierung. Die IDE erzeugt immer gleichzeitig auch eine ueberschriebene  Methode von Hashcode, weil man immer diese beiden Methoden gleichzeitig ueberschreiben sollte.", "start": 617.28, "end": 636.68}, {"text": "Wenn man  eine von beiden ueberschreibt, sollte auch die andere ueberschrieben werden, damit alles konsistent  bleibt. Da war das Thema Hashing erst spaet in der Foliesung behandelt, wird interessiert,  dass hier nicht kommt, nicht vor. Also koennen wir sie hier einfach loeschen.", "start": 636.68, "end": 659.6}, {"text": "Ich starte jetzt noch mal  den, das gesamte Programm auch mit dieser automatisch generierten Equals Funktion und wir  sehen, es funktioniert alles, wie es soll. Wieder also hat uns der Debagger geholfen,  den Fehler im Java-Programm schnell zu finden und zu korrigieren.", "start": 659.6, "end": 679.8}, {"text": "Ausserdem kamen bei diesem Video  noch zwei andere Werkzeuge vor, dass man mit Steuerung Q die Java-Dokumentation zu Java-Methoden  direkt angezeigt bekommt und dass man bei einem Methodenaufruf mit GoToImplementation sehen kann,  welche Implementierung der Methode in dem konkreten Fall verwendet wird.", "start": 679.8, "end": 684.76}]}]