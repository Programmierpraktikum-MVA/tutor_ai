[{"lecture": "31624_82_course_video", "Timestamps": [{"text": "  Der Algorithmus von PRIM zur Bestimmung eines minimalen Spannbaums basiert auf der Schnitt-Eigenschaft.  Die Schnitt-Eigenschaft wird in einem separaten Video besprochen.  Sie besagt, fuer einen beliebigen Schnitt gilt, dass jeder minimale Spannbaum mindestens eine der minimal kreuzenden Kanten enthalten muss.  Daraus kann direkt der PRIM Algorithmus abgeleitet werden.", "start": 0.0, "end": 33.0}, {"text": "  Man startet mit einem leeren Baum MST unter einem Startknoten S.  Dieser Startknoten definiert den markierten Bereich N, der im folgenden Schrittweise vergroessert wird, bis er alle Knoten des Grafen umfasst.  Bei dieser schrittweisen Auswahl werden die kreuzenden Kanten bezueglich des durch M definierten Schnittes betrachtet.  Von diesen Kanten wird eine mit minimalem Gewicht ausgewaehlt.", "start": 33.0, "end": 64.0}, {"text": "  Falls das minimale Gewicht noch einmal vorkommt, gibt es keine Wahlmoeglichkeit und es steht fest, welche Kante ausgewaehlt werden muss.  Diese Kante wird dem Baum MST hinzugefuegt und der Zielknoten wird markiert.  Am Ende der Schleife wird MST der minimale Spannbaum des gegebenen Grafen sein.  Schauen wir uns den Ablauf in einem Beispiel genauer an.", "start": 64.0, "end": 86.0}, {"text": "  Fuer diesen Grafen soll ein minimaler Spannbaum als Handsimulation erstellt werden.  Handsimulation nennt man das Simulieren des Ablaufes von einem Algorithmus mit Stift und Papier fuer ein gegebenes Beispielproblem.  Handsimulationen sind typische Klausuraufgaben.  Gemaess des PRIM Algorithmus, der oben nochmal zusammengefasst ist, wird zunaechst der Startknoten markiert.", "start": 86.0, "end": 111.0}, {"text": "  Dann werden die kreuzenden Kanten bezueglich der aktuellen Markierung untersucht.  Es geht also um den Schnitt, der die markierten Knoten von den unmarkierten Knoten trennt.  Die kreuzenden Kanten sind also die Kanten mit Gewicht 2, 1 und 3.  Die minimalkreuzende Kante ist die Kante mit Gewicht 1.  Nun haben wir also einen vergroesserten markierten Bereich und neue kreuzende Kanten.", "start": 111.0, "end": 145.0}, {"text": "  Fuer diesen Schnitt ist nun diese Kante mit dem Gewicht 2 die minimalkreuzende Kante.  Der Knoten U wird markiert.  Nun betrachten wir diesen Schnitt.  Hier haben wir zwei Kanten mit minimalem Gewicht.  Zwei Kanten mit dem Gewicht 3.  Wir koennen eine beliebige Auswahl treffen und entscheiden uns fuer diese Kante.  Damit ist der Knoten hier unten markiert.  Der neue Schnitt laeuft hier.", "start": 145.0, "end": 176.0}, {"text": "  In diesem Fall haben wir wieder eine eindeutige Kante mit minimalem Gewicht.  Diese Kante mit Gewicht 2 hier unten.  Damit ist der vorletzte Knoten markiert.  Nun laeuft der Schnitt hier lang.  Die Kante mit Gewicht 6 ist die minimalkreuzende Kante.  Damit haben wir auch den letzten Knoten erreicht.  Die markierten Kanten stellen den spannbaum dar, wie er vom Primalgorithmus gefunden wird.", "start": 176.0, "end": 204.0}, {"text": "  Nun kommt eine knifflige Frage.  Ich fuege hier oben zwischen den Knoten U und V eine zusaetzliche Kante in den Grafen ein  und bezeichne ihr Gewicht mit der Variabe X.", "start": 204.0, "end": 233.0}, {"text": " Die Frage ist, fuer welchen Wert von X koennte diese Kante Teil eines minimalen Spannbaums sein?  Beziehungsweise, fuer welche Werte ist sie sicher in jedem minimalen Spannbaum enthalten?  Sie koennen gerne das Video hier stoppen und zunaechst selbst ueberlegen.  Diese Frage koennen Sie mit der Schnitteigenschaft beantworten.", "start": 233.0, "end": 257.0}, {"text": " Wenn wir etwas ueber die Kante UV aussagen wollen mit der Schnitteigenschaft,  koennen wir die Schnitte betrachten, die die Knoten U und V von dem Rest abtrennen.  Zum Beispiel fuer den Knoten U waere das dieser Schnitt hier.  Die kreuzenden Kanten sind die mit Gewicht 2, 5 und X die Schnitteigenschaft besagt.  Jeder minimale Spannbaum muss eine der minimal kreuzenden Kanten enthalten.", "start": 257.0, "end": 284.0}, {"text": "  Das heisst, damit hier die Kante zwischen UV und V ins Spiel kommt, muesste X mindestens gleich 2 sein.  Dann kann sie in diesem Vergleich ausgewaehlt werden.  Damit sie in diesem Vergleich zwingend ausgewaehlt wird, muesste X kleiner als 2 sein.  Schauen wir uns nur noch den Schnitt um den Knoten V an.  Hier sind die kreuzenden Kanten, diejenigen mit Gewicht 7, 6 und X.", "start": 284.0, "end": 312.0}, {"text": "  In diesem Vergleich sehen wir, dass X schon in den minimalen Spannbaum kommen kann.  Wenn das Gewicht X gleich 6 ist und fuer ein Gewicht kleiner als 6, muss X in den Spannbaum kommen.  Wir sagen also, X ist kleiner gleich 6.  In diesem Fall koennen wir die Kante mit Gewicht 6 loeschen und dafuer die Kante UV zu dem Grafen hinzufuegen.", "start": 312.0, "end": 339.0}, {"text": "  Schliesslich soll noch die Frage nach einer effizienten Implementierung angesprochen werden.  Hier ist der relevante Ausschnitt des Ptoilocotes.  Zeitkritisch ist die Operation, eine minimal kreuzende Kante auszuwaehlen.  Diese Operation wird V-1 ausgefuehrt und es ist eine Auswahl aus maximal hier vielen Kanten.", "start": 339.0, "end": 363.0}, {"text": "  Bei einer Auswahl gemaess einem Wert mit minimalem Gewicht kommt einem direkt eine Priority Queue in den Sinn.  Hier koennte man also eine Priority Queue fuer die kreuzenden Kanten waehlen.  Tatsaechlich erhaelt man so eine Implementierung von Prim.  Allerdings geht es noch besser.", "start": 363.0, "end": 387.0}, {"text": "  Das Problem bei der Priority Queue fuer die Kanten ist, dass fuer jeden Knoten mehrere Kanten, die zu ihm hinfuehren, gespeichert werden.  Auch solche, die ein grosses Gewicht haben, also nie als die minimal kreuzende Kante ausgewaehlt werden.  Sie machen die Priority Queue unnoetig lang und darum leidet die Effizienz.", "start": 387.0, "end": 411.0}, {"text": "  Die Idee zur Verbesserung ist, dass man zu jedem Knoten nur die minimal kreuzende Kante, die zu ihm fuehrt, speichert.  Hier muss allerdings noch ein Aspekt beachtet werden.  Waehrend des Algorithmus, wird der markierte Bereich immer weiter ausgedehnt, d.h. die Menge der kreuzenden Kanten aendert sich.", "start": 411.0, "end": 436.0}, {"text": "  D.h. zu einem Knoten kann zunaechst eine kreuzende Kante gefunden werden und spaeter andere, die ein geringeres Gewicht haben.  D.h. man muss in dieser Priority Queue der Knoten das Gewicht der Kanten, die zu dem Knoten fuehren, aktualisieren koennen.  Wenn spaeter eine leichtere Kante gefunden wird, wird ihr Gewicht in der Priority Queue gespeichert.", "start": 436.0, "end": 462.0}, {"text": "  Aber das Aktualisieren des Gewichtes, also den Prioritaetswert in einer normalen Priority Queue, ist nicht effizient.  Daher muss fuer eine effiziente Implementierung des Primalgorithmus die indizierte Priority Queue gewaehlt werden.  Auf diese Weise erreicht man eine Laufzeit in O von E lock V.  Zu guter Letzt wird nun eine Javersimulation des Primalgorithmus vorgefuehrt.", "start": 462.0, "end": 495.0}, {"text": "  Die weiss markierten Kanten sind die kreuzenden Kanten und die blauen sind der markierte Bereich, der ausgehend von dem Startknoten besucht wird.  Wird die Kanten in der Vorbereitung des Primalgorithmus verwendet?  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.", "start": 512.0, "end": 541.0}, {"text": "  Wird die Kanten im Vorbereit des Primalgorithmus verwendet?  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.  Die Kanten sind die Kanten im Vorbereit des Primalgorithmus.", "start": 541.0, "end": 559.0}]}]