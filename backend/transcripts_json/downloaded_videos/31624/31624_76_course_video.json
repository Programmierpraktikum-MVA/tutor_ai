[{"lecture": "31624_76_course_video", "Timestamps": [{"text": "  Bei der Loesung von algorithmischen Aufgaben ist man mit der Herausforderung konfrontiert,  dass viele wichtige Probleme in der Komplexitaetsklasse NP sind.  Dies bedeutet, dass kein effizienter Algorithmus fuer das Problem bekannt ist und es vermutlich  auch keinen geben kann, gemaess der P-Ungleich-NP-Vermutung.", "start": 0.0, "end": 27.8}, {"text": "  Eine Art mit dieser Herausforderung bei Optimierungsproblemen umzugehen ist die Entwicklung von approximativen  Algorithmen.  Diese Algorithmen zeichnen sich dadurch aus, dass sie nicht in Anspruch haben, eine optimale  Loesung zu finden, sondern nur eine Annaeherung, also eine Approximation einer optimalen Loesung.", "start": 27.8, "end": 48.24}, {"text": "  Das Ziel dabei ist es, eine schnellere Laufzeit zu erreichen, und zwar auch im Worst Case.  Zudem geben approximative Algorithmen eine Garantie, wie gut ihre Approximation ist,  also wie weit ihre Loesung hoechstens von der Optimalitaet entfernt ist.  Diese Garantie wird haeufig in die Bezeichnung des Algorithmus integriert.", "start": 48.24, "end": 76.28}, {"text": "  Ein Algorithmus wird roh Approximationsalgorithmus genannt, wenn sich die Werte seiner Loesung  hoechstens und den Faktor roh von der optimalen Loesung unterscheiden.  Bei einem Minimierungsproblem gilt also, dass der Loesungswert C kleiner oder gleich  dem optimalen Wert C Stern mal roh ist.  Fuer Maximierungsprobleme ist der Loesungswert C groesser oder gleich dem Loesungswert C Stern  geteiligt roh.", "start": 76.28, "end": 112.44}, {"text": "  Eine Einze-Aproximation, also mit roh gleiche Eins, waere also eine exakte Loesung.  Fuer einen Wert roh knapp ueber Eins erhaelt man sehr gute Approximationen, und je groesser  der Wert ist, desto groeber ist die Approximation.  Natuerlich lassen sich nicht immer geeignete Approximationen der Loesung finden.  Fuer konkrete Problemstellungen koennen die folgenden Faelle auftreten.", "start": 112.44, "end": 139.88}, {"text": "  Erstens, das Problem laesst sich ueberhaupt nicht in polinomieller Zeit approximieren,  egal wie unambitioniert das Ziel auch ist.  Dies ist zum Beispiel der Fall fuer das Traveling Salesman Problem, TSP.  Selbst der Versuch einen Algorithmus zu entwerfen, der eine Tour findet, die maximal 1000  Mal, solange wie die kuerzeste Tour ist, ist zum Scheitern verurteilt.", "start": 139.88, "end": 163.8}, {"text": "  Fuer einzelne Problemstellungen ist dies natuerlich moeglich, aber nicht im Worst Case.  Fuer einzelne Problemstellungen ist dies natuerlich moeglich, aber nicht im Worst Case, egal wie  hoch man den Faktor waehlt.  Der Beweis dieser Aussage steht im Alkoholzript.  Zweiter Fall, das Problem laesst sich zwar approximieren, aber nicht beliebig gut.  Dies gilt zum Beispiel fuer das Metrische TSP.", "start": 164.8, "end": 198.8}, {"text": "  Das ist der Spezialfall des Traveling Salesman Problem, bei dem die Distanzen der Knoten die  Dreiecksunleichung erfuellen.  Fuer das Metrische TSP gibt es einen Approximationsalgorithmus, der in Ofen Fahro 4 eine Tour bestimmt, die hoechstens 50%  laenger als die kuerzeste Tour ist.  Hier ist also eine Approximation moeglich, die selbst im Worst Case gute Resultate liefert.", "start": 198.8, "end": 223.8}, {"text": "  Aber es geht nicht beliebig gut.  Kein Algorithmus kann in polinomieller Zeit eine Tour finden, die garantiert hoechstens 123.  laenger als die kuerzeste Tour ist.  Dann gibt es den dritten Fall, dass das Problem sich beliebig gut approximieren laesst.", "start": 223.8, "end": 254.8}, {"text": " Das heisst, es gibt einen Algorithmus, der fuer jedes konkrete Problem eine Loesung innerhalb  einer vorgegebenen Approximationsguete liefert, egal wie nah der gesteckte Rahmen am Optimum ist.  Diese Situation liegt beim 01-Rucksack-Problem vor.  Da koennte man sagen, prima, dann fordern wir, dass die Abweichung vom Optimum kleiner als die Maschinen-Geneutigkeit ist.", "start": 254.8, "end": 273.8}, {"text": "  Dann haetten wir ein praktisch optimales Resultat fuer ein NP-Problem in polinomieller Zeit.  So klappt das allerdings leider nicht.  Bei der genaueren Definition von beliebig gut approximierbar wird im Algorithmus naemlich mehr Zeit gegoennt, je genauer die Loesung sein soll.", "start": 273.8, "end": 295.8}, {"text": "  Die funktionale Abhaengigkeit wird in der Definition des Approximationsschemas mit vollstaendig polinomieller Laufzeit festgelegt.  Fuer jedes noch so kleine Epsilon muss der Approximationsalgorithmus eine 1 plus Epsilon-Aproximation der Loesung liefern.  Und die Laufzeit muss durch ein Polinom in der Laenge der Eingabe und in 1 durch Epsilon beschraenkt sein.", "start": 295.8, "end": 328.8}, {"text": "  Das heisst, je genauer die Approximation sein soll, desto mehr Zeit darf der Algorithmus verwenden.  Und daher kann dann die Laufzeit fuer Loesungen, die sehr exakt am Optimum sein sollen, sehr langsam sein.  Ein solches Approximationsschema wird fuer das 01-Rucksack-Problem im Algorithmus besprochen.", "start": 328.8, "end": 342.8}]}]