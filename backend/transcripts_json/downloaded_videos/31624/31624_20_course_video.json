[{"lecture": "31624_20_course_video", "Timestamps": [{"text": "  In diesem Video werden wir uns mit dem Thema Union-Find beschaeftigen.  Union-Find ist eine Datenstruktur.  Sie wird verwendet, um schnell die Zugehoerigkeit von Elementen zu ueberpruefen.  Somit ist eine schnelle Identifizierung von Gruppen moeglich.  Bevor wir uns aber naeher damit auseinandersetzen, wie diese Union-Find-Datenstruktur aussieht,  muessen wir erst einmal gewisse Grundbegriffe verstehen.", "start": 0.0, "end": 30.08}, {"text": "  Beginn werden wir mit dem Grundberief der Mengen.  Das Thema Meng ist euch wahrscheinlich schon aus die Mathematik-Kursen bekannt.  Eine Menge ist eine unsortierte Ansammlung an Elementen.  Wir haben hier beispielsweise zwei Mengen.  Und diese koennen wir nun mit bestimmten Elementen fuellen.  Die Elemente 4, 6, 9, 11 und 13 sind nun Menge 1.  Die Elemente 3, 7 und 12 in Menge 2.", "start": 30.08, "end": 59.08}, {"text": "  Nun habe ich die Mengen Menge 1 und Menge 2 genannt.  Es gibt allerdings noch eine weitere Moeglichkeit, diese Mengen genau zu benennen.  Das koennen wir mit Repraesentanten machen.  Wir waehlen uns fuer jede Menge ein Element aus und waehlen dieses als Repraesentant der Menge.  Die Menge auf der linken Seite hat nun den Repraesentanten 4, die Menge auf der rechten Seite den Repraesentanten 3.", "start": 59.08, "end": 85.08}, {"text": "  Dieser Repraesentant ermoeglicht es uns nun, die Menge genau zu benennen.  Die Elemente 6, 9, 11 und 13 sind zum Beispiel auch in der Menge mit dem Repraesentanten 4.  Die Elemente 7 und 12 sind in der Menge mit dem Repraesentanten 3.  Auch der Repraesentant selbst ist Teil der Menge.  Nachdem wir diese Grundbegriffe geklaert haben, schauen wir uns die Grundfunktion eine Union-Feind-Datenstruktur an.", "start": 85.08, "end": 112.08}, {"text": "  Zum einen hat die Union-Feind-Datenstruktur eine Funktion, um Elemente hinzuzufuegen.  Diese kann entweder Teil des Konstruktors sein oder wie hier in dem Beispiel eine Add-Funktion.  Mit der Add-Funktion fuegen wir eine neue Menge hinzu, die nur genau ein Element enthaelt und dieses Element ist dann auch gleichzeitig der Repraesentant der Menge.", "start": 112.08, "end": 135.08}, {"text": "  Habe ich also zum Beispiel nur die Menge mit dem Repraesentanten 4 wie in diesem Beispiel und rufe die Add-Funktion mit der 5 auf,  da wird eine neue Menge hinzugefuegt, die nur die 5 enthaelt und die 5 ist der Repraesentant der Menge.  Eine weitere Funktion, die auch Namens geben fuer die Datenstruktur ist, ist die Feind-Funktion.", "start": 135.08, "end": 154.08}, {"text": "  Mit der Feind-Funktion koennen wir den Repraesentanten eines Elements einer Menge wiedergeben.  Ruf ich beispielsweise Feind mit der 13 auf, dann erhalte ich den Repraesentanten der Menge, in der die 13 enthalten ist.  In unserem Beispiel ist die 13 in der linken Menge enthalten, diese hat den Repraesentanten 4, also erhaelt ich als Rueckgabe Repraesentant 4.", "start": 154.08, "end": 177.08}, {"text": "  Abschliessend benoetigt eine Union-Feind-Datenstruktur auch die Union-Funktion.  Diese vereinigt, wie der Name schon sagt, zwei Mengen miteinander.  Das bedeutet, alle Elemente beider Mengen werden in eine Menge zusammengefuegt.  Dabei muss man allerdings beachten, dass man nun einen neuen Repraesentanten fuer diese neue Menge bestimmen muss.", "start": 177.08, "end": 197.08}, {"text": "  Eine Menge darf naemlich immer nur einen Repraesentanten haben.  Vereinige ich zum Beispiel die Menge mit Repraesentant 4, mit der Menge mit Repraesentant 5, dann ergibt sich eine neue Menge, mit einem gemeinsamen Repraesentanten, in dem Fall zum Beispiel 4.  Um diesen Repraesentanten zu bestimmen, gibt es unterschiedliche Moeglichkeiten.", "start": 197.08, "end": 222.08}, {"text": "  Wichtig ist nur, dass jetzt alle Elemente dieser neuen Menge als Repraesentanten die 4 gespeichert haben.  Diese Union-Feind-Datenstruktur laesst sich dann auf verschiedene Beispiele anwenden.  Ein Beispiel sind hier die Grafen.  Hierzu fuehre ich zwei neue Begriffe ein.  Zum einen die Equivalenz-Relation.", "start": 222.08, "end": 245.08}, {"text": "  Die Equivalenz-Relation besagt, dass zwei Knoten in diesen Grafen miteinander verbunden sind, wenn diese eine bestimmte Eigenschaft teilen.  Dadurch entstehen zusammenhaengende Knoten.  Equivalenz-Klassen sind dann Zusammenhangskomponenten, also zusammenhaengende Knotengruppen, die miteinander verbunden sind.  In unserem Beispiel hier rechts haben wir Buecher mit unterschiedlichen ISPN-Nummern.", "start": 245.08, "end": 269.08}, {"text": "  Alle Buecher, die die gleiche ISPN-Nummer teilen, sind ueber eine Kante, also ueber eine Equivalenz-Relation miteinander verbunden.  Diese Knotengruppen, die dadurch entstehen, sind dann unsere Equivalenz-Klassen.  Die Equivalenz-Klassen sind untereinander nicht verbunden, sie bilden also Cluster.  Diese Equivalenz-Klassen lassen sich vergleichen mit den Mengen unserer Union-Feind-Datenstruktur.", "start": 269.08, "end": 293.08}, {"text": "  Um die Union-Feind-Datenstruktur besser zu verstehen, habe ich hier ein sehr einfaches Beispiel.  Wir haben drei Knoten 0, 1 und 2.  Diese sind zu Beginn jeder seiner eigenen Menge zugeordnet.  Das heisst, Knoten 0 ist in Menge A, Knoten 1 ist in Menge B und Knoten 2 ist in Menge C.  Verwende ich nun die Union-Funktion mit Knoten 0 und Knoten 1, so vereinige ich die beiden Mengen A und B.", "start": 293.08, "end": 325.08}, {"text": "  Habe ich eine Funktion, die mir zurueckgibt, ob diese beiden Knoten verbunden sind, also in der gleichen Menge sind, dann ist die Rueckgabe nun wahr.  Nun kann ich auch die Mengen A und C miteinander vereinigen, indem ich Union 0, 2 aufrufe.", "start": 325.08, "end": 346.08}, {"text": " Waren diese beiden Vereinigungen erfolgreich, sind nun nicht nur die Knoten 0 und 1 in der gleichen Menge und die Knoten 0 und 2 in der gleichen Menge,  sondern es sind auch die Knoten 1 und 2 in der gleichen Menge.  Wollt ihr diese Union-Feind-Datenstruktur implementieren, muesst ihr allerdings auf einige Dinge achten.", "start": 346.08, "end": 358.08}, {"text": "  Wichtig ist, dass nach einer Vereinigung immer alle Elemente in der gleichen Menge sind.  Hier sehen wir ein Beispiel-Code von einer solchen Union-Funktion.  Ich wuerde euch einmal bitten, kurz zu ueberlegen, ob dieser Code korrekt funktioniert oder nicht.  Tatsaechlich sieht der Code auf den ersten Blick sinnvoll aus, funktioniert allerdings nicht korrekt.", "start": 358.08, "end": 388.08}, {"text": "  Wir wollen hier die Mengen, in der sich Knoten p und Knoten q befinden, vereinigen.  In der Liste id ist hierbei fuer jeden Knoten gespeichert, in welcher Menge er sich befindet, also welchen Repraesentanten er hat.", "start": 388.08, "end": 414.08}, {"text": " Der Code funktioniert nun so, dass zuerst ueberprueft wird, ob diese beiden Elemente bereits in einer Menge sind  und wenn nicht, etereere ich ueber alle Elemente und pruefe fuer jedes Element, ob der Repraesentant von diesem Element gleich dem Repraesentanten von dem Element p ist  und falls ja, setze ich den Repraesentanten auf denen von q.", "start": 414.08, "end": 424.08}, {"text": "  Hierbei entsteht allerdings ein kleines Problem, was ich hier unten in dem Beispiel gezeigt habe.  Beginnen wir beispielsweise mit dem Array 0, 1, 2, 3, 4 und jedes Element ist sein eigener Repraesentant.  Wenn ich nun also Junien 1, 2 aufrufe, dann vereinige ich die Mengen in der die 1 steht und die Menge in der die 2 steht.", "start": 424.08, "end": 447.08}, {"text": "  Anschliessend haben also der erste Eintrag des Arrays und der zweite Eintrag des Arrays den gleichen Repraesentanten.  In dem Falle hier Repraesentant 2.  Nun rufe ich noch Junien 1, 4 auf.  Was ich erwarte, ist, dass danach die Elemente 1, 2 und 4 alle den gleichen Repraesentanten haben.  Was allerdings passiert, ist, dass sich zuerst den Repraesentanten von 1 aendern.", "start": 447.08, "end": 476.08}, {"text": "  Anschliessend aber fuer die 2 ueberpruefe, ob der Repraesentant dem der 1 entspricht, entspricht er jetzt nicht mehr, das heisst die 2 wird nicht mehr korrekt angepasst.  Falls das noch nicht ganz verstaendlich war, programmiert diese Funktion doch einmal selbst und ueberprueft die Ausgabe fuer verschiedene Eingaben.", "start": 476.08, "end": 492.08}, {"text": "  Dann werdet ihr herausfinden, dass die Ausgabe nicht mehr funktioniert fuer alle Zahlen, die groesser als unser P sind.  In dem Falle ist die 2 groesser als unsere 1, das heisst fuer die 2 hat die Unionfunktion nicht mehr funktioniert.  Hinzu gedessen koennt ihr auch einmal ueberlegen, wie ihr die Funktion anpassen wuerdet, damit diese funktioniert.", "start": 492.08, "end": 510.08}, {"text": "  Doch warum schauen wir uns die Unionfeind-Datenstruktur ueberhaupt an?  Die Unionfeind-Datenstruktur bietet die Moeglichkeit, einige Probleme sehr effizient zu loesen.  Sie bietet die Moeglichkeit, zusammenhaengende Komponenten in einem Graph zu finden oder zusammenhaengende Komponenten zu bilden.", "start": 510.08, "end": 530.0799999999999}, {"text": "  Ein Beispiel hierfuer ist der Algorithmus von Kruz-Kal, welchen wir uns im naechsten Video anschauen werden.", "start": null, "end": 530.0799999999999}]}]