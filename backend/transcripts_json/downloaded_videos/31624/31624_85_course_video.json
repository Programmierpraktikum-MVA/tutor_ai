[{"lecture": "31624_85_course_video", "Timestamps": [{"text": "  Die Tiefensuche ist uns bereits als grundlegendes Strategie des Backtracking begegnet, um den  Baum der Teilloesungen zu durchlaufen. Nun besprechen wir die Tiefensuche als Verfahren, um einen  Grafen zu durchlaufen. Ausgehend von einem Startknoten sollen alle erreichbaren Knoten  ueber Fade des Grafen besucht werden.", "start": 0.0, "end": 33.6}, {"text": "Im letzten Video wurde bereits gezeigt, dass alle Kanten,  die bei einer solchen Durchsuchung eines Grafen benutzt werden, einen Baum ergeben. Die Struktur  dieses Suchbaums haengt allerdings nicht nur von der Struktur des Grafen ab, sondern auch von der  Reihenfolge, in der die Nachbarknoten eines Knotens durchlaufen werden.", "start": 33.6, "end": 52.44}, {"text": "Die Tiefensuche ist  ein sehr grundlegendes Verfahren der Grafenalgorithmen. Daher schauen wir uns das jetzt detailliert an.  Hier sehen Sie den Pseudokot fuer die Tiefensuche. Da wird eine variable m benutzt fuer die markierten  Knoten. Das sind alle Knoten, die besucht wurden, werden markiert.", "start": 52.44, "end": 81.6}, {"text": "Dann wird die rekursive Funktion  der Tiefensuche, DFS, mit dem Startknoten 0 aufgerufen. Der Aufruf dieser Methode DFS mit  einem Knoten V bedeutet, dass der Knoten V besucht wird. Das heisst, der Knoten kann als  erstes markiert werden und zu zeigen, dass er entdeckt wurde.", "start": 81.6, "end": 104.24}, {"text": "Danach werden alle Nachbarknoten  durchlaufen, also alle Knoten W, zu denen eine Kante von V im Grafen fuehrt und wir wollen nur  solche Knoten besuchen, die nicht schon vorher besucht wurden, also die noch unmarkiert sind.", "start": 104.24, "end": 129.04}, {"text": "Fuer alle,  diese Knoten W wird dann rekursiv die Funktionen DFS aufgerufen und folgt also dieser Kante VW in  dem Grafen. Erst wenn alle diese Nachbarknoten abgearbeitet sind, das heisst, alle von dort  erreichbaren Knoten besucht wurden, dann endet hier diese Vorschleife und damit ist dann auch der  Knoten V bearbeitet. Nun wollen wir uns den schrittweisen Programmablauf angucken.", "start": 129.04, "end": 153.4}, {"text": "Da sehen  Sie hier unten die Zustaende der Variablen der Knoten V und W, die Menge der markierten Knoten,  die Kante VW und den Rekursionsstack. Hier rechts ist der Grafen, der durchsucht wird mit der Tiefensuche  und hier rechts wird der Suchbaum entstehen, der dabei genutzt wird.", "start": 153.4, "end": 178.32}, {"text": "Wir starten also mit der  Funktion DFS, die jetzt fuer den Startknoten Null aufgerufen wird, das heisst, V ist Null und der  Knoten Null wurde gerade entdeckt und also markiert. Nun durchlaufen wir die Nachbarknoten,  die sind 1, 2 und 3 und wir tun dieses hier in dieser Demo immer in aufsteigender Reihenfolge.", "start": 178.32, "end": 204.51999999999998}, {"text": "  Das heisst, zuerst wird der Nachbarknoten wie gleich 1 betrachtet. Das heisst, der Algorithmus folgt  dieser Kante Null 1 und besucht nun den Knoten 1. Daraufhin wird der Knoten 1 markiert und es werden  alle Nachbarknoten untersucht. Von Knoten 1 geht eine Kante zu dem Knoten Null, dies wird hier  aber gar nicht abgebildet, da dieser Knoten schon markiert ist.", "start": 204.51999999999998, "end": 237.32}, {"text": "Das heisst, diese Bedingung W,  nicht Element von M, waere nicht erfuellt. Das heisst, es wird hier nur die Kante von 1 zu 4 betrachtet.  Im naechsten Schritt wird also der Knoten 4 besucht durch diesen rekorasiven Aufruf mit dem  Argument wie gleich 4. Wir besuchen den Knoten 4 und gibt es 2 Nachbarknoten, 3 und 5.", "start": 238.32, "end": 262.68}, {"text": "Wir gehen  wieder der Reihenfolge nach, das heisst, nach der Markierung von Knoten 4, besuchen wir zunaechst  den Knoten 3. Da gehen wir wieder in die Reckusion. Wie bekannt, Knoten 3 wird markiert. Wir  durchlaufen alle Nachbarknoten, 4 und Null sind schon markiert. Wir werden also nicht beachtet in  diesem Fall nur die Knoten 2 und 5. Zunaechst wird der Knoten 2 besucht.", "start": 262.68, "end": 299.0}, {"text": "Er wird markiert und nun  folgt die Schleife ueber alle noch nicht markierten Nachbarknoten von 2. Die gibt es aber nicht,  da beide Nachbarknoten 0 und 3 schon markiert sind. Das heisst, diese Vorschleife wird direkt wieder  verlassen und damit ist der Knoten 2 als erster Knoten fertig bearbeitet.", "start": 299.0, "end": 322.15999999999997}, {"text": "Das heisst, alle von  2 erreichbaren Knoten wurden schon entdeckt. Wie man es hier sieht, Null wurde schon entdeckt,  da startete die Suche und 3 wurde schon entdeckt. Von dort wurde gerade die 2 besucht. Das heisst,  hier ist das erste Mal eine Prozedur fertig, der Ablauf.", "start": 322.15999999999997, "end": 346.76}, {"text": "Das heisst, das erste Mal gehen wir  jetzt im Recursionsstack einen Schritt zurueck. Also, wie bei den Backtracking, hier ein Schritt  zurueck gemacht von der 2, gehen wir wieder zur 3 und bei der 3 stand er noch aus, den Knoten 5  zu besuchen, der bisher noch nicht besucht war.", "start": 346.76, "end": 369.64}, {"text": "Das heisst, der Knoten 5 wird besucht,  er wird markiert und nun geschieht dasselbe wie vorher bei dem Knoten 2. Alle von 5 erreichbaren  Knoten sind bereits markiert, das heisst, die Vorschleife wird fuer keinen Knoten ausgefuehrt.  Knoten 5 ist fertig bearbeitet. Es geht zurueck im Recursionsstack zu Knoten 3.", "start": 369.64, "end": 391.59999999999997}, {"text": "Nun sind auch  von Knoten 3 alle Nachbarknoten besucht. Das heisst, auch Knoten 3 ist nun fertig bearbeitet.  Es geht zurueck zu Knoten 4 und nun sind auch alle Knoten, die von 4 erreichbar sind,  schon besucht. Wo spruenglich als von der 4 aus die 3 besucht wurde, war die 5 noch nicht besucht.", "start": 392.6, "end": 422.59999999999997}, {"text": " Das heisst, da stand das hier noch sozusagen auf der Liste der Kandidaten, aber da der Knoten 5  mittlerweile besucht wurde von Knoten 3, ist er nun schon markiert. Das heisst, er wird nicht von  der 4 noch einmal besucht. Damit ist auch Knoten 4 fertig bearbeitet. Es geht im Recursionsstack zurueck  zu Knoten 1. Der ist auch fertig bearbeitet und damit ist auch die Suche beendet.", "start": 422.59999999999997, "end": 444.0}, {"text": "Auch Knoten 0  ist fertig bearbeitet und hier unten sehen wir wie der Suchbaum entstanden ist. Von der 0  ging es zu 1, zur 4, zur 3 und dann zur 2 und eine andere Verzweigung von der 3 fuehrte zur 5.", "start": 444.0, "end": 477.64}, {"text": " Nun folgt die Ueberlegung, wie dieser Pseudokot implementiert werden kann und in diesem Fall  stellt sich da hauptsaechlich die Frage, durch welche Datenstruktur wird die Menge der markierten  Knoten implementiert. Dies koennte ja zum Beispiel mit einer Liste, einem Stack, einer Queue geschehen oder einem Array.", "start": 477.64, "end": 485.44}, {"text": "  Und um das zu entscheiden, gucken wir, welche Anforderungen an diese Menge sind, welche Operationen  werden ausgefuehrt. Zunaechst wird in Zeile 1 die Menge oder die Datenstruktur zunaechst wird in  Zeile 1 die Menge der zunaechst wird in Zeile 1 die Menge der markierten Knoten leer initialisiert.", "start": 485.44, "end": 523.82}, {"text": "Dann  wird in Zeile 5 ein Element hinzugefuegt zu der Menge und dies wird fuer jeden Knoten einmal  passieren, jeden erreichbaren Knoten, also letztendlich v mal und wir muessen hier pruefen koennen,  ob ein Element zu M gehoert und das im Maximalfall wird das fuer jede Kante des Grafen einmal passieren,  also ehemal.", "start": 523.82, "end": 549.5400000000001}, {"text": "Wir sehen also, das Initialisieren passiert nur einmal und die kritischen Operationen,  die vielfach passieren, sind Elemente hinzufuegen und pruefen, ob ein Element zur Menge gehoert und  dafuer bietet sich besonders ein Array an, also ein bursches Array, wo jeder Eintrag sagt, ob ein Knoten  markiert wurde oder nicht.", "start": 549.54, "end": 572.2199999999999}, {"text": "Damit haben wir die Laufzeit fuer die Initialisierung in o von v und fuer  Element hinzufuegen und pruefen, ob ein Element zur Menge gehoert in konstanter Laufzeit. Dieses  hier war das Wichtige, weil das die Operationen sind, die haeufig ausgefuehrt werden.", "start": 572.2199999999999, "end": 596.94}, {"text": "Insgesamt  ergibt sich also eine Laufzeit in o von dem Maximum der Anzahl der Knoten und der Kanten,  je nachdem was laenger dauert, die Initialisierung, die Initialisierung in o von v oder das eigentliche  Besuchen des Grafen in o von e.", "start": 596.94, "end": 612.3}, {"text": "Dies wird auch oft anders geschrieben, nicht mit dem Maximum,  sondern als o von v plus e, was ja als Groessenordnung auf dasselbe rauskommt. Manchmal werden sie auch  als Laufzeit die Angabe finden o von e. Dies macht man, weil man meistens davon ausgeht,  dass ein Graf mindestens so viel Kanten wie Knoten hat.", "start": 612.3, "end": 647.38}, {"text": "Nun gibt es noch eine tiefe Suchendemonstration  in einem etwas groesseren Zufallskrafen. Dies ist der Startknoten. Von dort werden alle  erreichbaren Knoten besucht, nicht erreichbare Knoten, die hier dieser Einzelknoten werden  nicht erreicht und wir sehen, dass die Suche zuerst in die Tiefe ging und sich dadurch sehr  langer Suchvater gab. Weiter ein Durchlauf.", "start": 647.38, "end": 668.7800000000001}]}]