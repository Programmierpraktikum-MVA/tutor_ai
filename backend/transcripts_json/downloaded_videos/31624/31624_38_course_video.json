[{"lecture": "31624_38_course_video", "Timestamps": [{"text": "  In diesem Video werden wir noch einmal kurz die Themen aus letzter Woche wiederholen.  Dazu werden wir uns die Queues und die Stacks noch einmal anschauen.  Beginn werden wir mit den Queues. Dazu wuerde ich euch bitten, euch einmal kurz die Antwort  auf die folgenden Fragen zu ueberlegen.", "start": 0.0, "end": 25.52}, {"text": "Nach welchem Prinzip funktioniert eine Queue,  mit welcher Methode fuegt man Elemente hinzu und mit welcher Methode holt man Elemente  aus der Queue wieder heraus? Eine Queue funktioniert nach dem sogenannten First-in-first-out-Prinzip  oder kurz Fiefung.", "start": 25.52, "end": 53.2}, {"text": "Das bedeutet, alle Elemente, die ich zuerst in die Queue einfuege, werden  auch als Erstes wieder herausgeholt. Um Elemente in die Queue einzufuegen, benutze ich die Methode  Offer. Um Elemente wieder aus der Queue herauszuholen, benutze ich die Methode Poll.  Nun wuerde ich euch bitten, die gleichen Fragen noch einmal fuer den Stack zu beantworten.", "start": 53.2, "end": 70.80000000000001}, {"text": "Nach  welchem Prinzip funktioniert ein Stack, mit welcher Methode fuegt man Elemente hinzu und mit welcher  Methode holt man Elemente wieder heraus?  Ein Stack funktioniert nach dem sogenannten First-in-Last-out-Prinzip. Das bedeutet,  Elemente, die ich zuerst eingefuegt habe, werden als Letztes wieder aus dem Stack herausgeholt.", "start": 70.80000000000001, "end": 99.32000000000001}, {"text": "  Oder andersrum, die Elemente, die ich zuerst eingefuegt habe, werden auch als Erstes wieder  herausgeholt. Um Elemente hinzuzufuegen, benutze ich die Methode Push. Um Elemente wieder herauszuholen,  die Methode Pop. Um Queues und Stacks noch mal praktisch anzuwenden, wollen wir das Beispiel  aus letzter Woche erweitern.", "start": 99.32000000000001, "end": 125.6}, {"text": "Auch hier wuerde ich euch bitten, das ganze erst einmal wieder selbst  zu probieren und anschliessend zeige ich euch meine Loesung. Schreibt dazu eine neue klasse Kunde.  Jeder Kunde besitzt einen Namen und ein Alter. Zusaetzlich hat jeder Kunde eine Liste an Produkten,  die er gerne aus dem Shop kaufen wuerde.", "start": 125.6, "end": 144.76}, {"text": "Weiterhin hat er eine Tasche, in der er Produkte  transportieren kann. Die Liste an Produkten soll hier als Queue implementiert werden. Die Tasche,  in der die Produkte landen, als Stack. Die Attribute sollen auch hier wieder privat sein,  das heisst, es wird fuer jedes Attribut eine Getter Methode benoetigt.", "start": 144.76, "end": 160.84}, {"text": "Darueber hinaus brauchen wir  eine Methode, um die Tasche mit Produkten zu fuellen. Um das ganze nachher besser testen zu  koennen, ist es hilfreich, Objekte der Klasse sinnvoll auf der Konsole ausgeben zu koennen.  Schreibt dazu noch eine Two-String Methode. Hier haben wir das Beispiel aus letzter Woche,  was wir nun erweitern wollen.", "start": 160.84, "end": 186.2}, {"text": "Zum einen haben wir die Klasse Produkt geschrieben und diese  enthaelt lediglich als Attribut einen Namen, einen einfachen Konstruktor und eine Getter Methode  fuer den Namen. Darueber hinaus haben wir die Klasse Shop geschrieben. Die Klasse Shop hat die  folgenden Attribute, einen Namen, einen Besitzer und ein Regal.", "start": 186.2, "end": 208.83999999999997}, {"text": "Das Regal ist ein Errie, in dem Produkte  gespeichert sind. Im Konstruktor werden dann die entsprechenden Attribute initialisiert. Darueber  hinaus haben wir zwei verschiedene Methoden zur Lieferung geschrieben, um Produkte im Regal zu  speichern. Ausserdem haben wir eine Methode geschrieben, um Produkte aus dem Regal zu kaufen.", "start": 208.83999999999997, "end": 227.88}, {"text": "  Fuer die privaten Attribute, Name und Besitzer haben wir ausserdem Getter Methode geschrieben. Nun  wollen wir allerdings damit beginnen, eine neue Klasse Kunde zu schreiben. Dazu mache ich wieder  einen Rechtsglick auf meinen Source Ordner, Heelenew und Java-Class. Diese Klasse nenne ich Kunde.  Beginnen wir erst einmal wieder mit den Attributen.", "start": 227.88, "end": 257.56}, {"text": "Jeder Kunde soll einen Namen,  einen Alter, eine Einkaufsliste und eine Tasche besitzen. Diese ganzen Attribute sollen als  private definiert sein. Fuer den Namen waehlen wir zum Beispiel den Datentypen String.  Da es sich beim Alter um eine ganze Zahl handelt, werden wir hier den Datentypen Integer.", "start": 257.56, "end": 283.88}, {"text": "Nun brauchen  wir als naechstes die Einkaufsliste. In dieser Einkaufsliste sollen Produkte gespeichert werden,  die der Kunde braucht. Fuer unser Beispiel reicht uns an der Stelle der Name des Produktes,  das heisst eine Liste von Strings. Diese Liste soll als Q implementiert werden. Ich schreibe also  wie vorher wieder private. Nun benoetige ich eine Q, welche Elemente vom Datentypen String speichert.", "start": 283.88, "end": 316.08000000000004}, {"text": "  Die Variable nenne ich dann Liste. Nun sehe ich, dass ich noch einen Fehler angezeigt  bekomme. Das liegt daran, dass die Klasse Q noch nicht innerhalb unserer Klasse Kunde  importiert wurde. Um das nachzuholen, klicke ich auf Q, druecke dann Alt Enter und nun wird  automatisch die Klasse Q importiert. Anschliessend wollen wir noch unseren Rucksack als Stack realisieren.", "start": 316.08, "end": 346.0}, {"text": "  Auch dieser soll wieder als private definiert sein. Nun habe ich keine Q, sondern ein Stack. In diesem  Stack speichere ich nun Produkte und das Ganze nenne ich Rucksack. Auch hier fehlt wieder der  Import, das heisst ich klicke auf Stack, druecke Alt Enter und der Import wird hinzugefuegt.  Es naechstes benoetigen wir einen Konstruktor fuer unsere Klasse.", "start": 346.0, "end": 381.36}, {"text": "Der Konstruktor hat immer  die folgende Signatur. Zuerst schreiben wir Public, anschliessend folgt der Klassname in dem Falle  Kunde und dann eine Liste von Parametern, die ich zum Initialisieren brauche. Da der Rucksack zu Beginn  immer leer sein soll, brauche ich lediglich Parameter fuer den Namen, das Alter und die Liste mit Produkten.", "start": 381.36, "end": 422.96}, {"text": "  Innerhalb unseres Konstruktors initialisiere ich erst einmal die Attribute fuer die ich ein Parameter habe.  Beginn werde ich mit Name, anschliessend das Alter und dann die Liste.  Hierbei muss ich allerdings beachten, dass ich hier in meinem Code lediglich die Referenz kopiere.", "start": 423.76, "end": 466.79999999999995}, {"text": " Verwende ich also mehrmals die gleiche Q zum Initialisieren eines Kundenobjekts,  steht in jedem Kundenobjekt die Referenz auf die gleiche Q. Aender ich die Q also einmal,  aendert sich die Q fuer jeden Kunden, wo ich die gleiche Referenz gespeichert habe.", "start": 467.12, "end": 483.04}, {"text": " Da ich aber in diesem Beispiel mit der Q nichts weiter mache, erst die Elemente daraus zu lesen,  reicht das an dieser Stelle aus. Nun muss ich noch mein Rucksack initialisieren.  Da der Rucksack am Anfang leer ist, initialisiere ich das Attribut mit einem leeren Stack.", "start": 488.08000000000004, "end": 504.72}, {"text": " Um ein Leeren Stack zu erzeugen, benutze ich wieder das Schluesselwort New,  anschliessend Stack als Datentypen. In Spitzen klammern gebe ich den Datentypen an,  der im Stack gespeichert wird, in dem Falle Produkt.  Und dann verwende ich klammern und bin fertig.", "start": 504.72, "end": 522.0}, {"text": " Da unsere Attribute wieder als Private deklariert sind, benoetigen wir auch wieder Getter-Methoden,  um auf diese von aussen zugreifen zu koennen.  Eine Getter-Methode sollte immer public sein, hat als Rueckgabetypen den Datentypen  unseres Attributs und heisst Get und anschliessend Attributname. Parameter werden nicht benoetigt.", "start": 528.9599999999999, "end": 544.88}, {"text": "  Innerhalb der Getter-Methode macht man dann nichts anderes, als das Attribut zurueckzugeben.  Fuer unser Attributenname sieht das Ganze also folgendermassen aus.  Die Methode sollte public sein. Der Datentypen unseres Attributs ist String.  Der Name der Methode ist dann Getname und wir brauchen keine Parameter.", "start": 545.5999999999999, "end": 566.3199999999999}, {"text": "  Innerhalb dieser Methode machen wir dann nichts anderes, als unser Attribut zurueckzugeben,  das heisst ich schreibe Return this.name. Das Gleiche mache ich nun einmal fuer die  anderen Attribute.  Nachdem wir nun die Getter-Methode geschrieben haben, brauchen wir noch eine weitere Methode,  mit der es moeglich ist, ein Produkt dem Rucksack hinzuzufuegen.", "start": 566.3199999999999, "end": 615.04}, {"text": "  Auch auf diese Methode sollte man wieder von aussen zugreifen koennen, deshalb Public.  Sie muss nichts zurueckgeben, deswegen gebe ich als Rueckgabetypen Void an  und wir nennen diese Methode auch einmal kaufen.  Nun brauchen wir noch das Produkt, was wir in unserem Rucksack speichern wollen und das  uebergebe ich hier als Parameter und nenne es an der Stelle einmal P.", "start": 616.72, "end": 643.92}, {"text": "  Innerhalb dieser Methode machen wir dann nichts anderes, als dieses Produkt in unserem Rucksack  speichern. Unser Rucksack ist als Stack realisiert, das heisst um etwas auf diesem Stack zu speichern,  benutzen wir die Methode Push.  Ich greife also auf mein Attribut Rucksack zu und fuehre auf dem Stack die Push-Methode aus.  In Klammern uebergebe ich dann mein Produkt P.", "start": 643.92, "end": 670.16}, {"text": "  Kommen wir zum Abschluss noch zu der sogenannten Two-String-Methode.  Diese sorgt dafuer, dass sich jedes Objekt ohne Probleme auf der Konsole ausgeben laesst.  Standardmaessig gibt die Two-String-Methode fuer Objekte selbstgeschriebener Klassen  allerdings nur die Referenz wieder.", "start": 671.6, "end": 695.76}, {"text": " Um eine sinnvolle Ausgabe auf der Konsole zu ermoeglichen, muss man diese Two-String-Methode  ueberschreiben. Die Two-String-Methode hat die folgende Signatur. Man kann von aussen auf  sie zugreifen, sie ist also Public. Sie gibt eine Repraesentation des Objekts als String zurueck  und sie traegt den Namen Two-String.", "start": 695.76, "end": 716.4}, {"text": "  Ihr seht schon, diese wurde nun gelb markiert und auf der linken Seite seht ihr ein kleines O.  Das bedeutet an dieser Stelle wird eine Methode einer Superklasse ueberschrieben.  Da die Two-String-Methode fuer die Klasse Objekt definiert ist und jede neu erzeugte Klasse  von der Klasse Objekt erbt, ist die Two-String-Methode fuer jedes Objekt definiert.", "start": 717.04, "end": 737.36}, {"text": "  Allerdings gibt sie wie gesagt standardmaessig nur die Referenz zurueck.  Wir wollen hier allerdings ein String zurueckgeben, der uns etwas mehr Information ueber das Objekt  gibt. Beginnen wir dazu erstmal damit, ein Lern-String zu erzeugen.  Dazu schreibe ich String, anschliessend den variablen Namen, z.B. Out und Anfuehrungszeichen,  welche leer bleiben.", "start": 738.24, "end": 764.24}, {"text": "  Nun kann ich Strings in Java auf eine sehr einfache Methode aneinanderhaengen.  Dazu schreibe ich mein variablen Namen, in dem Fall Out, anschliessend plus gleich  und anschliessend folgt der String, den ich anfuegen moechte.  Z.B. moechte ich zuerst den Namen des Kunden angeben.  Dafuer brauche ich hier keine Anfuehrungszeichen, sondern kann einfach mein Attribut verwenden.", "start": 765.12, "end": 794.72}, {"text": "  Anschliessend koennte ich das Alter anfuegen, in dem ich z.B. schreibe plus gleich und nun  folgen z.B. Klammern und in diesen Klammern das Alter.  Nun interessiert mich z.B. abschliessend noch, welche Dinge nun im Rucksack gelandet sind.  Dazu kann ich, wie wir das schon letzte Woche gemacht haben, mit einer ForEach-Schleife  durch den Rucksack gehen und jedes Element meinem String hinzufuegen.", "start": 794.72, "end": 833.6}, {"text": "  Dazu schreibe ich erst vor, anschliessend nun den Datentypen, der in meiner Liste oder  meinem Stack gespeichert ist, in dem Fall Produkt, dann gebe ich einen Namen fuer die  temporaere Variable z.B. P und gebe anschliessend noch hinter dem Doppelpunkt meine Liste bzw.  hier mein Stack an.", "start": 833.6, "end": 859.8399999999999}, {"text": " Bitte beachtet, dass die Produkte nun nicht unbedingt in der Reihenfolge sein muessen,  in der sie vom Stack gepoppt werden wuerden.  Ist die Reihenfolge an der Stelle nicht wichtig, koennen wir allerdings diese ForEach-Schleife  benutzen. Innerhalb dieser Schleife koennen wir nun zu unserem String hinzufuegen,  den Namen des Produktes.", "start": 861.68, "end": 883.04}, {"text": "  Diesen erhalten wir, wenn wir auf unserem Produkt P die GetName-Methode aufrufen.  Anschliessend wollen wir die Produkte noch durch ein Komma trennen, das heisst, wir fuegen  hier noch ein Komma an.  Um das Ganze noch etwas uebersichtlicher zu machen, fuege ich hier noch ein paar Worte an.  Wir haben hier jetzt den Namen in Klammern das Alter und anschliessend z.B. hat folgende  Produkte im Rucksack.", "start": 885.12, "end": 916.4}, {"text": "  Zum Ende der TwoString-Methode muessen wir dann unseren fertigen String noch zurueckgeben.  In diesem String steht nun der Name unseres Kunden.  Anschliessend in Klammern das Alter, dann die Worte hat folgende Produkte im Rucksack  und dann wird der Name aller Produkte mit Komma getrennt dem String hinzugefuegt.  Wie diese Ausgabe dann aussehen kann, seht ihr in den folgenden Videos.", "start": 920.56, "end": 945.6}, {"text": "  In diesen werden wir das Beispiel auch noch erweitern.", "start": null, "end": 945.6}]}]