[{"lecture": "31624_79_course_video", "Timestamps": [{"text": "  In diesem Screencast wird der Dyxtralgorithmus zum finden kuerzester Wege beleuchtet.  Erfolgt dem im ersten Video vorgestellten allgemeinen Ansatz der Relaxierer.", "start": 0.0, "end": 24.44}, {"text": " Andererseits genutzt er zur Festlegung der Reihenfolge, in der der Kraft durchlaufen wird  das Prinzip der Kreuzenden Kanten, das bei der breiten und tiefen Suche eingefuehrt und auch  bei dem Primalgorithmus fuer minimale Spannboerne benutzt wurde.  Der Dyxtralgorithmus besucht die Knoten in der Reihenfolge ihrer Distanz vom Startknoten S.", "start": 24.44, "end": 42.36}, {"text": "  Dabei bezeichnen wir mit Distanz eines Knotens V die Laenge eines kuerzesten Weges, der von S nach V fuehrt.  Dieser Wert, Dist V, wird auf unendlich gesetzt, solange noch kein Weg bekannt ist und waehrend des  Ablaufs kann er mehrmals verkleinert werden, jedes Mal wenn ueber eine Relaxierung ein kuerzerer Weg  zu ihm gefunden wird. Der Ablauf des Algorithmus ist nun folgender.", "start": 42.36, "end": 71.36}, {"text": "Der Baum kuerzester Wege,  auch SPT vor Shortest Paths Tree, wird ausgehend vom Startknoten S aufgebaut. Dabei wird immer  ein neuer Knoten besucht, der Ziel einer kreuzenen Kante mit minimalem Dist Wert ist. Diese Kanten werden  auch minimal kreuzen Kanten genannt.", "start": 71.36, "end": 94.72}, {"text": "Von diesem ausgewaehlten Knoten werden dann alle ausgehenden  Kanten relaxiert und das Ganze wird wiederholt bis alle Knoten besucht werden. Um die Reihenfolge  gemaess dieser Dist Werte algorithmisch zu realisieren, bietet es sich an, alle Knoten,  die entdeckt werden, in einer Priority Queue zu speichern mit ihrem Dist Wert als Prioritaet.", "start": 94.72, "end": 112.48}, {"text": "So  wird automatisch der Knoten mit geringster Distanz aus der PQ geholt. Als Zoldercode sieht das folgendermassen  aus.", "start": 112.48, "end": 136.68}, {"text": "Zunaechst haben wir die Initialisierung des Dist Arrays und der Priority Queue und dann wird  iteriert und jeweils der Knoten mit der kleinsten Distanz aus der Priority Queue herausgenommen und alle  ausgehenden Kanten werden relaxiert.", "start": 136.68, "end": 152.20000000000002}, {"text": "Fuer den Dike Strahl algorithmus haben wir eine spezielle  Relaxierungsmethode, da hier ausser den bekannten Code noch etwas dazukommt, naemlich dass der neue  Zielknoten W in die Priority Queue eingespeist wird mit dem neu geschaetzten Distanzwert.", "start": 152.20000000000002, "end": 164.88}, {"text": "Fuer die  Implementierung ist dabei zu beachten, dass an dieser Stelle nicht unbedingt der Knoten W frisch  in die Priority Queue eingefuegt wird, sondern es kann sein, dass der Knoten W schon mit anderen,  eben schlechteren Distanzwert vorher an der Priority Queue war, um zu vermeiden, dass die Priority Queue", "start": 164.88, "end": 180.08}, {"text": " unnoetig anwaechst durch mehrfach Einspeisen von Knoten und darunter die Effizienz leidet, soll nur der  Distanzwert, also die Prioritaet, aktualisiert werden. Dies ist aber in einer normalen Priority Queue  nicht effizient moeglich.", "start": 180.08, "end": 198.84}, {"text": "Im Skript ist genauer beschrieben, wie hier mit einer Index Priority Queue  Effizienz erreicht werden kann. Fuer die Handsimulation, die nun hier demonstriert werden soll, ist dieser  Aspekt allerdings nicht wichtig. Wir schreiben hier in die Tabelle auf der rechten Seite alle  Informationen, die fuer den Ablauf des Dykstra Algorithmus wichtig sind.", "start": 198.84, "end": 216.56}, {"text": "Auf der linken Seite  werden die Knoten aufgeschrieben, wenn sie in den Baum der kuerzesten Fader eingefuegt werden,  mit dem Distanzwert und dem Vorgaengerknoten.", "start": 216.56, "end": 237.32}, {"text": "Und auf der rechten Seite schreiben wir die  entdeckten Knoten auf, die also in dem Algorithmus in die Priority Queue eingefuegt werden, auch mit  Distanzwert und dem Vorgaengerknoten. Hier sind die Distanzwerte allerdings vorlaeufig und koennen  noch verbessert werden.", "start": 237.32, "end": 251.52}, {"text": "Und erst, wenn sie aus der Priority rausgeholt werden und in den Baum der  kuerzesten Fader eingefuegt werden, ist der Distanzwert endgueltig. Wir starten mit dem Knoten S,  der die Distanz von sich selbst null hat und keinen Vorgaengerknoten. Von dort werden die Knoten A,  B und D entdeckt. Also schreiben wir hier rechts A, B und D mit Vorgaengerknoten S auf.", "start": 251.56, "end": 276.2}, {"text": "Und die  Distanzen sind die entsprechenden Kantengewichte, also 11, 7 und 3. Damit ist der Knoten S fertig  abgearbeitet. Und nun waehlen wir einen neuen Knotensauerarbeitung aus der Priority Queue aus,  und zwar denjenigen, der den kleinsten Distwert hat, also in diesem Fall D.", "start": 276.2, "end": 305.4}, {"text": "Die Kante SD wird also  den Baum der kuerzesten Fader zugefuegt und wir tragen den Knoten D in die Tabelle mit dem  entsprechenden Werten aus der Priority Queue ein. Von dem Knoten D koennen wir nun die Kanten nach  B, C und E relaxieren.", "start": 305.4, "end": 319.84}, {"text": "Zu B finden wir also den neuen Weg ueber D mit der Laenge 3 plus 4, was auch 7  ist. Das heisst hier brauchen wir nichts zu tun, weil es kein neuer kuerzerer Weg ist. Aber es werden  ganz neue Wege gefunden zu den Knoten C und E. Also von D aus zu Knoten C haben wir 3 plus 8,  die Weglaenge 11 und zu E haben wir 3 plus 2, der 5. Damit ist Knoten D abgearbeitet.", "start": 319.84, "end": 348.67999999999995}, {"text": "Und wir holen  Knoten E aus der Priority Queue, weil 5 der kleinste Distwert in dieser Tabelle ist. Die Kante DE ist  also Teil des Baum der kuerzesten Fader und wir tragen die Informationen aus der Priority Queue  entsprechend ein. E Distanz 5 kommt von D.", "start": 348.68, "end": 373.84000000000003}, {"text": "Von E gibt es nur eine ausgehende Kante und zwar zu  Knoten C. Hier erhalten wir die Weglaenge 5 plus 3 gleich 8. Also kommt von E und haben damit eine  bessere Schaetzung als die bisherige mit der Laenge 11 und koennen diese ersetzen. Damit ist Knoten E  fertig bearbeitet.", "start": 373.84, "end": 397.32}, {"text": "Als naechstes wird der Knoten B aus der Priority geholt, weil der Distanz wird 7  nun der kleinste ist. Wir uebertragen diese Informationen in den Baum der kuerzesten Fader. B 7S und markieren  die Kante in Grafen. Von B wird ein neuer Weg zu A gefunden. Er hat die Laenge 7 plus 3, also 10 und  ersetzt damit den vorher bekannten Weg der Laenge 11. Die andere Kante von B fuehrt zu dem Knoten C.", "start": 397.32, "end": 423.24}, {"text": "  Hier haben wir einen Weg der Laenge 7 plus 2 gleich 9. Dies ist aber laenger als der schon bekannte Weg  ueber den Knoten E. Hier muessen wir also nichts tun. Damit haben wir den Knoten B fertig bearbeitet.  Knoten C aus der Priority geholt. Die Informationen in den Baum uebertragen.", "start": 423.24, "end": 447.32}, {"text": "C wird von E erreicht mit  einer Weglaenge von 8. Kante markieren und nun werden die ausgehenden Kanten von C untersucht.  Also von C nach A. Das Kantengewicht ist 1. Zusaetzlich zu der Distanz von C 8 halten wir also einen neuen Weg der Laenge 9.  Der kleiner ist als der bekannte Weg zu A. Also wird hier auch wieder etwas ersetzt.", "start": 447.32, "end": 475.44}, {"text": "  So Knoten A haben wir nun einen Weg der Laenge 9 gefunden. Kommen von Knoten C. Damit ist C fertig bearbeitet.  Es bleibt nur noch A uebrig. A wird von C erreicht und es bleibt bei der Weglaenge 9.  In dieser Handdimulation wurde auch folgendes deutlich. Durch die Reihenfolge, in der die  Knoten bei dem Dyxtralgrythmos besucht werden, muss jeder Knoten nur einmal besucht werden.", "start": 475.44, "end": 507.92}, {"text": "  Und als Folge wird jede Kante hoechstens einmal relaxiert, wenn der Bedarf besteht. Der Dyxtralgrythmos ist also ein Greedy-Verfahren.  Dies ist allerdings nur garantiert, wenn der Graf keine negativen Gewichte hat.  Dieser Aspekt wird in dem Skript genauer besprochen. Mit der Beschraenkung auf nicht negative Gewichte ist der Dyxtralgrythmos auch im Burst-Case ziemlich effizient.", "start": 507.92, "end": 527.16}, {"text": "  Schauen wir es uns an.  Wenn also jeder Knoten nur einmal aus der Priority-Cube geholt wird, wird hier jede Kante nur einmal relaxiert.  Das heisst, dieses hier passiert hoch von ehemal als Groessenorten.  In der Dyxtralversion der Relaxierung haben wir hier einen Extra-Befilm.  Daher hat sie nicht wie sonst konstante Laufzeit, sondern wir muessen uns diese Zeile genau anschauen.", "start": 528.16, "end": 560.16}, {"text": "  Es wird ein Knoten mit Distanzwert in die Priority-Cube eingefuegt.  Unter Umstaenden ist dieser Knoten schon vorhanden und es muss nur der Distanzwert aktualisiert werden.  Dies wurde schon besprochen. Effizient ist das nur mit einer initiierten Priority-Cube.  Und da ist naemlich die Laufzeit lock von Groesse der Priority-Cube.  Da die Inhalte der Priority-Knoten sind, ist die maximale Laenge v.", "start": 560.16, "end": 588.16}, {"text": "  Also haben wir die Laufzeit in der Groessenordnung lock von v.  Insgesamt hat also Dyxtral eine Laufzeit in der Groessenordnung ehemal lock v.  Beide Einschraenkungen auf nicht negative Gewichte.  Detailst du der Laufzeit und auch einen Hinweis auf eine etwas schneller Variante finden Sie in dem Skript.  Zur guter Letzt gibt es noch eine Java-Simulation des Dyxtral-Algorithmus.", "start": 588.16, "end": 616.16}, {"text": "  Der Baum kuerzester Wege waechst in blau und in weiss sind die Kanten dargestellt, die in der Priority-Cube sind.  Falls durch eine Relaxierung ein kuerzerer Weg zu einem schon entdeckten Knoten gefunden wird,  kann auch mal eine weisse Kante verworfen und durch eine andere Kante ersetzt werden,  ihren kuerzeren Weg zu dem Zielknoten ermoeglicht.", "start": 616.16, "end": 668.16}, {"text": "  Nun folgt noch eine Simulation mit einem sehr speziellen Sterngrafen,  der hauptsaechlich zum Vergleich mit dem Bellmann-Vorteilgorithmus gedacht ist.", "start": 668.16, "end": 697.16}, {"text": " Hier gehen alle Wege sternfoermig von den Startknoten in der Mitte aus  und die Kanten in der oberen Haelfte sind sehr kurz, dort liegen viele Knoten auf dem Weg  und in Richtung der unteren Haelfte sind die Abstaende zwischen den Knoten  und auch die entsprechenden Gewichte deutlich groesser.", "start": 697.16, "end": 711.16}, {"text": " Was Sie hier in der Simulation sehen, ist, dass bei dem Dyxtral-Algorithmus  die Knoten gleichmaessig im Abstand von dem Mittelpunkt explodiert werden  und da werden Sie bei dem Bellmann-Vorteilgorithmus einen deutlichen Unterschied feststellen.", "start": 711.16, "end": 716.16}]}]