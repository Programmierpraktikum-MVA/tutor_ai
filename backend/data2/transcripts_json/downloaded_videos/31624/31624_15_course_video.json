[{"lecture": "31624_15_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns den Algorithmus von Dykstra anschauen.  Bevor wir das machen, schauen wir uns allerdings erst einmal gerichtete Grafen an.  In der letzten Woche haben wir bereits ungerichtete Grafen kennengelernt.  Diese bestanden aus Knoten und Kanten zwischen den Knoten, die man in beide Richtungen gehen kann.", "start": 0.0, "end": 26.0}, {"text": "  Der Unterschied bei gerichteten Grafen ist nun, dass die Kanten nur in eine Richtung begehbar sind.  In diesem Grafen haben wir zum Beispiel den Startknoten A und von diesem koennen wir zu B und C gehen, allerdings nicht von B oder C zu A.  Ansonsten aendert sich im Vergleich zu ungerichteten Grafen nichts.  Weiterhin haben wir nun an den Kanten Kantengewichte.", "start": 26.0, "end": 51.0}, {"text": "  Diese Kantengewichte kann man interpretieren als Kosten, um von einem Knoten zum anderen zu kommen.  Je nach Anwendung koennen diese Kantengewichte ganz unterschiedliche Aussagen haben.  Haben wir zum Beispiel ein Grafen von unserem Strassennetz erstellt, dann koennte das Kantengewicht zum Beispiel die Entfernung zwischen zwei Knoten sein.", "start": 51.0, "end": 74.0}, {"text": "  Haben wir ein Grafen von unserem S-Bahn-Netz erstellt, dann koennte das Kantengewicht beispielsweise die Zeit sein, die die S-Bahn von einer Station zu anderen braucht.", "start": 75.0, "end": 90.0}, {"text": " Natuerlich kann man so ein gerichteten Grafen mit Kantengewichten auch in einen ungerichteten Grafen umwandeln, indem man fuer jedes Knotenpaar zwei Kanten hinzufuegt,  eine Kante, die von Knoten 1 zu Knoten 2 geht und eine Kante, die von Knoten 2 zurueck zu Knoten 1 geht.  Diese koennen dann sogar unterschiedliche Kantengewichte haben.  Nun schauen wir uns genauer den Algorithmus von Dykstra an.", "start": 91.0, "end": 103.0}, {"text": "  Dies ist ein Algorithmus fuer gerichtete Grafen mit Kantengewichten.  Dykstra findet auf diesen Grafen den kuerzesten Weg von einem Startknoten zu allen anderen Knoten im Grafen.  In jedem Schritt wird dabei der Knoten mit der kuerzesten Strecke zum aktuellen Knoten als Naechstes ueberprueft.  Wie gehen wir hierbei vor?  Eine Implementierungsmoeglichkeit von Dykstra ist mithilfe einer Priority Queue.", "start": 104.0, "end": 130.0}, {"text": "  Die Priority Queue haben wir auch schon in einem frueheren Video kennengelernt.  Noch einmal zu Wiederholung.  Eine Priority Queue funktioniert genauso wie eine normale Queue,  nur dass man mit der Pollfunktion nicht das Element erhaelt, was man als erstes hinzugefuegt hat,  sondern das Element, was die hoechste Prioritaet hat.  Im Fall von Dykstra ist unsere Prioritaet der Abstand zum Startknoten.", "start": 131.0, "end": 157.0}, {"text": "  Wir beginnen hier wieder aehnlich wie bei der Breiten Suche damit, den Startknoten mit Abstand 0 in die Priority Queue einzufuegen.  Dann gehen wir in eine Schleife, die so lange laeuft, bis die Priority Queue leer ist.", "start": 158.0, "end": 176.0}, {"text": " Jenerhalb dieser Schleife nehmen wir dann immer das erste Element aus der Priority Queue, markieren dieses als Besucht,  updaten dann die Distanz zu allen Nachbarn, wenn wir einen kuerzeren Weg zu diesen Knoten gefunden haben,  und die Nachbarn, die noch nicht in der Priority Queue sind oder besucht wurden, die fuegen wir dann der Priority Queue hinzu.", "start": 177.0, "end": 188.0}, {"text": "  Hierbei ist es wichtig, dass wir unsere Knoten richtig initialisieren.  Fuer den Startknoten haben wir einen Abstand von 0, da der Abstand immer den Abstand zum Startknoten beschreibt  und der Startknoten ist von sich selbst natuerlich null Schritte entfernt.", "start": 189.0, "end": 208.0}, {"text": "  Ausserdem hat der Startknoten keinen Vorgaenger, da der Vorgaenger auch wie bei der Breiten Suche und Tiefen Suche immer den Knoten beschreibt, von dem man gekommen ist.  Alle anderen Knoten werden mit Abstand unendlich initialisiert und haben auch noch keinen Vorgaenger.  Gerade eben im Algorithmus habe ich davon gesprochen, die Distanz zu updaten, wenn ein kuerzerer Weg gefunden wurde.", "start": 209.0, "end": 224.0}, {"text": "  Doch wie ueberpruefen wir das?  Ein Distanz-Update machen wir genau dann, wenn der bisher gespeicherte Abstand vom Nachbarknoten groesser ist, als der Abstand vom aktuellen Knoten plus den Weg zwischen dem aktuellen Knoten und dem Nachbarknoten.", "start": 225.0, "end": 251.0}, {"text": "  Was wir in dem Fall machen, ist den Vorgaenger vom Nachbarn auf den aktuellen Knoten setzen und den gespeicherten Abstand auf den Abstand vom Knoten plus den Weg zwischen dem Knoten und dem Nachbarknoten aendern.  Das Ganze wollen wir uns einmal an diesem Beispiel angucken.  Probiert gerne erst einmal wieder selbst das Ganze zu loesen und anschliessend zeige ich euch die Loesung.", "start": 253.0, "end": 269.0}, {"text": "  Der Startknoten ist hier Knoten A und wir wollen mit dem Dykstra Algorithmus den kuerzesten Weg zu allen anderen Knoten finden.  Wie die Breitensuche beginnt der Dykstra Algorithmus damit, den Startknoten in die Priority-Q einzufuegen.  An dieser Stelle habe ich noch keinen Knoten besucht und ich fuege meinen Startknoten in dem Falle A in die Priority-Q ein.", "start": 283.0, "end": 310.0}, {"text": "  In Klammern notiere ich mir hier noch den Abstand zum Startknoten, welcher fuer den Startknoten 0 ist und den Vorgaenger, und da der Startknoten keinen Vorgaenger hat, setze ich hier einfach so einen Strich.  Nun gehe ich in die Schleife. Hier hole ich immer zuerst das Element aus der Priority-Q, welches die hoechste Prioritaet, also den niedrigsten Abstand hat.", "start": 311.0, "end": 329.0}, {"text": "  In dem Falle hier ist das A, das heisst ich haue meine A aus der Priority-Q, und nun fuege ich alle Nachbarn hinzu.  Die Nachbarn sind hier B, und B erreiche ich ueber die Kante mit Kantengewicht 1, das heisst ich rechne 0 plus mein Kantengewicht 1, das ergibt 1, und ich komme von Knoten A.", "start": 329.0, "end": 350.0}, {"text": "  Ausserdem erreiche ich Knoten C mit einer Distanz von 3, da die Kante Kantengewicht 3 hat, und komme auch von Knoten A.  Nun hole ich den Knoten mit der hoechsten Prioritaet aus der Q, das ist hier B.  C bleibt in der Q-Bestehen, und ich fuege nun die Knoten hinzu, die ich von B aus erreichen kann, das sind einmal D.", "start": 351.0, "end": 384.0}, {"text": "  D erreiche ich ueber die Kante mit dem Kantengewicht 1, zu B habe ich eine Distanz von 1 gebraucht, das heisst ich habe insgesamt eine Distanz von 2, und komme von Knoten B.  Und das gleiche mache ich mit E, E erreiche ich ueber die Kante mit Kantengewicht 6, zu B baue ich eine Distanz von 1, macht insgesamt 7, und auch hier komme ich von Knoten B.", "start": 385.0, "end": 407.0}, {"text": "  Nun hole ich wieder den naechsten Knoten aus der Q, der den kleinsten Abstand zum Startknoten hat, das ist in dem Falle D, weil 2 kleiner ist als 3 und 7.  C und E bleiben in der Q.", "start": 408.0, "end": 441.0}, {"text": "  Nun ueberpruefe ich noch die Nachbarn von D, ich erreiche von D nur Knoten F, Knoten F erreiche ich mit einer Distanz von 2 zu D, plus die Kante mit nochmal 2 Kantengewicht, macht also eine Distanz von 4, und ich komme von Knoten D.  Nun hole ich den naechsten Knoten aus der Q mit dem kleinsten Abstand, das ist hier C, mit Abstand 3 und Vorgaenger A, E und F bleiben in der Q stehen.", "start": 441.0, "end": 473.0}, {"text": "  Nun ueberpruefe ich von C aus alle Nachbarn, das ist einmal E, E steht schon in der Q, ich muss allerdings auch ueberpruefen, ob ich nun einen kuerzeren Weg zu E gefunden habe.  Der Weg, den ich bisher gefunden habe, ist 7 lang und geht ueber B, ich habe nun allerdings einen Weg gefunden, der 3 plus 1 lang ist, also 4 und von C kommt.", "start": 473.0, "end": 492.0}, {"text": "  Das heisst, ich passe Vorgaenger und Distanz von E an und habe somit einen Abstand von 4, wenn ich von C komme.  Ausserdem habe ich noch die Nachbarn G von C aus, diesen erreiche ich mit 3 plus 4, also 7, wenn ich von C komme.  Nun habe ich 2 Knoten mit der gleichen Distanz, hier gehe ich wieder alphabetisch vor, das heisst ich nehme als naechstes den Knoten E aus der Q.", "start": 493.0, "end": 519.0}, {"text": "  Knoten F und Knoten G bleiben wieder in der Q.  Nun schaue ich mir wieder alle Nachbarn von E an, das ist in dem Falle nur G, das heisst ich muss ueberpruefen, habe ich einen kuerzeren Weg zu G gefunden,  bisher habe ich einen Weg gefunden, der 7 lang ist und von C kommt.", "start": 525.0, "end": 553.0}, {"text": "  Von A zu E hat der kuerzeste Weg Distanz 4, von E zu G die Kante hat Kante gewicht 2, also habe ich nun einen Weg von E gefunden, der lediglich Kante Gewicht 6 hat, das heisst ich updatee den Knoten G.  Nun hole ich wieder den Knoten mit der kleinsten Distanz aus der Q, das ist in dem Falle F.  Knoten G bleibt in der Q.", "start": 556.0, "end": 579.0}, {"text": "  Und jetzt ueberpruefe ich wieder alle Nachbarn von F, das ist hier nur H, H hat bisher kein Vorgaenger und eine Distanz von Unendlich, das heisst jeder Weg den ich zu H finde ist erst mal kuerzer.  Ich fuege also mein Nachbar H der Q hinzu und habe hier einen Weg gefunden mit 4 zu F plus die Kante 8 sind also 12, wenn ich von Knoten F komme.", "start": 580.0, "end": 622.0}, {"text": "  Nun nehme ich Knoten G aus der Q, Knoten H bleibt weiterhin in der Q stehen und nun ueberpruefe ich noch alle Nachbarn von G, das ist nur Knoten H, bisher habe ich einen Weg gefunden, der 12 lang ist zu Knoten H und nun habe ich einen Weg gefunden, der 6 lang zu G plus das Kante Gewicht 2 von Knoten G zu Knoten H ist, also insgesamt auf 8 kommt.", "start": 623.0, "end": 626.0}, {"text": "  8 ist kleiner als 12, das heisst ich updatee mein Knoten H.  Nun hole ich den naechsten Knoten aus der Q, das ist hier Knoten H und schaue mir alle Nachbarn an, von Knoten H aus erreiche ich allerdings kein weiteren Knoten, das heisst ich kann meiner Q auch nicht zin zufuegen und die Q ist danach leer.  Da die Q leer ist, terminiert unser Algorithmus an dieser Stelle.", "start": 631.0, "end": 656.0}, {"text": "  Wir haben somit zu jedem Knoten den kuerzesten Weg gefunden.  Wann immer wir bei diesem Ansatz ein Knoten aus der Q nehmen, haben wir an dieser Stelle den kuerzesten Weg zu diesem Knoten gefunden.  Somit steht nun in der Knotenspalte fuer jeden Knoten die kuerzeste Distanz vom Starknoten zu diesem Knoten und der Vorgaenger auf diesem Pfad.", "start": 657.0, "end": 684.0}, {"text": "  Moechte ich also nun wissen was der kuerzeste Weg von A nach H ist, gehe ich wie bei der Tiefensuche den Pfad wieder rueckwaerts vom Endknoten zum Startknoten.  Der kuerzeste Weg von A nach H hat also Laenge 8, das wissen wir bereits.  Nun gehe ich den Pfad rueckwaerts, das heisst ich fange mit H an.", "start": 685.0, "end": 713.0}, {"text": "  Zu H komme ich von G, das ist naemlich der Vorgaenger von H, anschliessend schaue ich mir den Vorgaenger von G an, das ist E, dann schaue ich mir den Vorgaenger von E an, das ist C und dann schaue ich mir den Vorgaenger von C an und das ist A.  Der schnellste Weg den Knoten H zu erreichen ist also A, C, E, G, H.  Nun wollen wir uns noch ein Beispiel in einer etwas anderen Notation angucken.", "start": 714.0, "end": 737.0}, {"text": "  Hier haben wir einen anderen Grafen und innerhalb dieser Felder neben den Knoten wollen wir nun die kuerzeste Distanz zu diesem Knoten eintragen, sowie den Vorgaenger.  Wenn sich diese waehrend des Algorithmus aendert, dann passen wir diese auch an.  Probier das auch hier gerne erstmal wieder selbst und anschliessend zeige ich euch die Loesung.  Schauen wir uns nun die etwas anderen Notationen an.", "start": 738.0, "end": 768.0}, {"text": "  Auch hier ist der Knoten A wieder der Startknoten.  Zuerst schaue ich mir an welche Knoten ich von diesen Startknoten aus erreiche.  Das sind Knoten B mit einer Distanz von 3, wenn ich von Knoten A komme, Knoten C mit einer Distanz von 6, wenn ich von Knoten A komme und Knoten D mit einer Distanz von 4, wenn ich von Knoten A komme.", "start": 769.0, "end": 796.0}, {"text": "  Knoten B hat die kuerzeste Distanz, das heisst ich schaue mir als naechstes Knoten B an und habe damit den kuerzesten Weg zu B gefunden.  Von B aus erreiche ich E mit einer Distanz von 4, also 3 plus 4 ergibt 7 und Knoten C mit einer Distanz von 3 plus 2, also 5.  5 ist kleiner als 6, das heisst ich update meine Distanz.  Nun schaue ich wieder, welcher Knoten die naechstkleinste Distanz hat.", "start": 797.0, "end": 823.0}, {"text": "  Das ist aktuell Knoten D mit einer Distanz von 4.  Ich habe also auch hier die kuerzeste Distanz nun gefunden und untersuche die Nachbarn von D.  Von D erreiche ich C mit einer Distanz von 4 plus 4, also 8.  8 ist groesser als meine bisherige Distanz 5, das heisst ich update diese nicht.  Allerdings erreiche ich auch Knoten F mit einer Distanz von 4 plus 5, also 9, wenn ich von Knoten D komme.", "start": 823.0, "end": 854.0}, {"text": "  Somit habe ich alle Nachbarn von D abgearbeitet und schaue mir als naechstes den Knoten mit der naechstkleinsten Distanz an.  Das ist in dem Falle Knoten C mit einer Distanz von 5.  Das heisst hier habe ich nun auch die kuerzeste Distanz gefunden und schaue mir alle Nachbarn an.  Das sind in dem Falle E und F.", "start": 855.0, "end": 874.0}, {"text": "  Zu E habe ich nun ein Weg von 5 plus 1 gefunden, also ein Weg der Laenge 6, wenn ich ueber Knoten C gehe.  6 ist kleiner als 7, das heisst ich update meine Distanz und mein Vorgaenger.  Zu Knoten F habe ich nun ein Weg der Laenge 5 plus 3 gefunden, also ein Weg der Laenge 8.  8 ist kleiner als 9, das heisst ich update die Distanz und mein Vorgaenger.", "start": 874.0, "end": 897.0}, {"text": "  Somit habe ich alle Nachbarn von C fertig abgearbeitet und schaue mir den Knoten mit der naechstkleinsten Distanz an.  Das ist in dem Falle Knoten E mit einer Distanz von 6.  Ich habe also auch hier den kuerzesten Weg zu E gefunden und schaue mir nun alle Nachbarn von E an.  E hat nur noch die Nachbarn F, das heisst ich ueberpruefe noch diesen Knoten.", "start": 898.0, "end": 918.0}, {"text": "  Zu Knoten E brauche ich eine Distanz von 6, die Kante von E zu F hat Kantengewicht 1,  das heisst ich brauche insgesamt ueber E eine Distanz von 7 zu Knoten F.  7 ist kleiner als die bisherige Distanz 8, das heisst ich update die Distanz und den Vorgaenger Knoten.  Somit habe ich alle Nachbarn von E abgearbeitet und schaue mir die naechsten Knoten an.", "start": 919.0, "end": 942.0}, {"text": "  Es bleibt hier noch Knoten F uebrig, das heisst ich habe auch den kuerzesten Weg zu Knoten F gefunden  und F hat keine Nachbarn mehr, das heisst ich bin fertig mit meinem Algorithmus.  Wir haben die Knoten also in der folgenden Reihenfolge besucht.  Zuerst haben wir Knoten A besucht, anschliessend Knoten B, dann Knoten D, dann Knoten C, anschliessend Knoten E und abschliessend Knoten F.", "start": 943.0, "end": 973.0}, {"text": "  Die kuerzeste Distanz zu diesen Knoten koennen wir nun auch ablesen, das ist bei Knoten A logischerweise 0,  bei Knoten B 3, bei Knoten C 5, bei Knoten D 4, bei Knoten E 6 und bei Knoten F 7.  Auch die Vorgaenger koennen wir nun ablesen, das ist bei A kein Vorgaenger, da dies der Startknoten ist.", "start": 973.0, "end": 1001.0}, {"text": "  Bei Knoten B ist der Vorgaenger A, bei Knoten C ist der Vorgaenger B, bei Knoten D ist der Vorgaenger auch A,  bei Knoten E ist der Vorgaenger C und bei Knoten F ist der Vorgaenger E.  Abschliessend wollen wir uns nun folgendes Problem anschauen.  Nehmen wir an, wir wollen nun, dass der kuerzeste Weg zum Knoten F 10 betraegt.", "start": 1002.0, "end": 1029.0}, {"text": "  Nun stellt sich die Frage, welche und wie viele Kanten wir anpassen muessen, damit der kuerzeste Weg den der Algorithmus findet, die Distanz von 10 hat.  Dazu muessen wir erst einmal schauen, welche Pfade wir gefunden haben.  Wir haben fuer F den kuerzesten Pfad gefunden mit der Laenge 7.  Dieser endet logischerweise in F.", "start": 1030.0, "end": 1056.0}, {"text": "  Und nun koennen wir immer den Vorgaenger des Knoten verwenden, in dem Falle E, der Vorgaenger von E ist C, der Vorgaenger von C ist B und der Vorgaenger von B ist A.  Ein weiterer Pfad mit der Laenge 8, den wir gefunden haben, ist zu F hin mit dem Vorgaenger C.  C hat den Vorgaenger B, B hat den Vorgaenger A.", "start": 1057.0, "end": 1081.0}, {"text": "  Und ein letzter Pfad, den wir gefunden haben mit der Laenge 9, endet auch wieder in F, kommt von D und beginnt beim Knoten A.  Wir muessen also dafuer sorgen, dass die Laenge aller dieser Pfade mindestens Laenge 10 hat.  Die einfachste Moeglichkeit das zu loesen, ist die letzten Kanten dieser Pfade jeweils zu erhoehen.  Ich muesste also die Kante EF um 3 erhoehen, die Kante CF um 2 und die Kante DF um 1.", "start": 1081.0, "end": 1114.0}, {"text": "  Somit aendert sich die Gesamtlaenge dieser Pfade jeweils auf 10.  Passig ein dieser Pfade nicht entsprechend an, dann wird der Dijkstra-Algorithmus immer diesen als den kuerzesten Weg bevorzugen.  Worauf ihr auch achten muesst, ist das folgende. Passig die Kante AB entsprechend an, gibt es natuerlich auch die Moeglichkeit, dass der Algorithmus die Kante AC priorisiert.", "start": 1115.0, "end": 1137.0}, {"text": "  Darauf muesst ihr beim Loesen solcher Aufgaben immer achten.  In diesem Beispiel muessen also mindestens 3 Kanten entsprechend angepasst werden, damit der Algorithmus kein kuerzeren Weg als die Distanz 10 zum Knoten F findet.", "start": 1138.0, "end": 1147.0}]}]