[{"lecture": "31624_3_course_video", "Timestamps": [{"text": "  Abschliessend wollen wir uns noch die zweite Hausaufgabe des Aufgabenblattes anschauen.  Dazu werfen wir erst einmal einen kurzen Blick auf das Aufgabenblatt.  In dieser Aufgabe geht es darum, die Klassen verschiedener geometrischer Form zu implementieren.  Diese Klassen stehen in einer Hierarchie, in Zusammenhang.", "start": 0.0, "end": 32.0}, {"text": "  Die Aufgabe besteht nun darin, die Klassen dieser zweidimensionalen Formen zu implementieren und entsprechend der Hierarchie anzupassen.  Werfen wir dazu erst einmal einen Blick auf die Hierarchie.  Ganz oben in der Hierarchie steht das Interface Shape.  Das Interface hat die beiden Methoden Perimeter und Area.  Dieses Interface wird implementiert von der abstrakten Klasse Polygon.", "start": 32.0, "end": 55.0}, {"text": "  Dieses hat das Attribut Vertices, ein Array aus 2D-Vektoren.  Vector2D ist ein bereits implementierte Klasse.  Von dieser abstrakten Klasse Polygon erbt das Convex-Polygon.  Dieses ueberschreibt die beiden Methoden des Interfaces.  Von diesem Convex-Polygon erben dann die Klassen Tetragon, Regular-Polygon und Triangle.  Das Regular-Polygon hat zusaetzlich das Attribut Radius und die Methode Resize.", "start": 55.0, "end": 87.0}, {"text": "  Das Triangle ueberschreibt abermals die Methode Area.  Um die Hierarchie besser verstehen zu koennen, wiederholen wir noch einmal Interfaces und abstrakte Klassen.  Ein Interface kann man sich vorstellen wie die Bauanleitung einer Klasse.  Es enthaelt ausschliesslich Methodenkoepfe.  Wird ein Interface nun von einer Klasse implementiert, muss diese auch die Methoden des Interfaces implementieren.", "start": 87.0, "end": 115.0}, {"text": "  Eine Klasse kann dabei mehrere Interfaces implementieren.  Somit ist es moeglich in Anfuehrungsstrichen von mehreren Klassen zu erben.  Allerdings spricht man hier genau genommen nicht von Vererbung, sondern von der Implementierung eines Interfaces.  Hier noch einmal zur Wiederholung das Beispiel von vorhin.", "start": 115.0, "end": 139.0}, {"text": "  Wir haben die beiden Interfaces Add und MULT und diese enthalten jeweils einen Methodenkopf.  Wenn ich jetzt eine Klasse Rechner implementiere und die beiden Interfaces Add und MULT implementiere,  dann muss ich innerhalb meiner Klasse auch Addiere und Multipliziere ueberschreiben.", "start": 139.0, "end": 160.0}, {"text": "  Wuerde ich nur das Interface MULT implementieren, so muesste ich auch nur Multipliziere innerhalb meiner Klasse implementieren.  Der Methodenkopf ist hierbei identisch, ich definiere nur, was die Methode macht.  Neben den Interfaces gibt es noch die Abstraktenklassen.  Im Gegensatz zu den Interfaces ist hier echte Vererbung moeglich, also von Attributen und Methoden beispielsweise.", "start": 160.0, "end": 185.0}, {"text": "  Allerdings kann ich Funktionen bzw. Methoden, die noch nicht innerhalb der Abstraktenklasse implementiert werden,  mit dem Stichwort abstract kennzeichnen.  Dann reicht, wie bei Interfaces, nur der Methodenkopf und wenn nun eine Klasse von einer Abstraktenklasse erbt,  muss diese auch die abstrakten Funktionen der Superklasse implementieren.  Das sieht dann in einem Beispiel wie folgt aus.", "start": 185.0, "end": 207.0}, {"text": "  Wir haben die abstrakte Klasse Rechner und die hat ein Attribut namens Ergebnis,  einen Konstruktor und eine abstrakte Methode.  Wenn ich nun von dieser Klasse Rechner erbe, dann erbe ich automatisch das Attribut und den Konstruktor,  muss allerdings auch die abstrakte Methode implementieren, in dem Fall addieren.  Werfen wir also nochmal ein Blick auf diese Hierarchie.", "start": 207.0, "end": 237.0}, {"text": "  Shape ist in diesem Fall ein Interface, das heisst es enthaelt ausschliesslich die Methodenkoepfe fuer die beiden Methoden.  Wenn nun die Klasse Polygon dieses Interface implementiert, muss es diese beiden Methoden implementieren.  Da die Klasse allerdings eine abstrakte Klasse ist, kann ich auch die beiden zu implementierenden Methoden als Abstrakte definieren.", "start": 238.0, "end": 259.0}, {"text": "  Das bedeutet, dass dann alle Klassen, die von Polygon erben, diese beiden Methoden implementieren muessen.  Und genau das ist auch der Fall.  Convex Polygon erbt von Polygon und muss deshalb die beiden Methoden, die schon im Interface Shape definiert wurden  und in der Klasse Polygon als Abstrakte gesetzt wurden, implementieren.", "start": 259.0, "end": 282.0}, {"text": "  Das heisst allerdings nicht, dass Klassen, die von Convex Polygon erben, diese Methoden 1 zu 1 uebernehmen muessen.  In der Klasse Triangle wird die Methode Area beispielsweise noch einmal ueberschrieben.  Werden die Methoden allerdings nicht ueberschrieben wie in Tetragon, werden die Methoden von der Superklasse uebernommen.  In der ersten Aufgabe sollte die Klasse Convex Polygon implementieren.", "start": 282.0, "end": 307.0}, {"text": "  Dazu muessen die von dem Interface Shape geforderten Methoden implementiert werden.  In der Methode Perimeter soll der Umfang des Polygons zurueckgegeben werden.  Bachtet hierbei, dass es bereits eine implementierte Moeglichkeit gibt, fuer jeden Vektor 2D die Laenge zu bestimmen.", "start": 307.0, "end": 330.0}, {"text": "  Wenn wir also drei Positionen gegeben haben, in unserem Beispiel A, B und C, moechten wir die Vektoren zwischen den jeweiligen Punkten erhalten,  also von A nach B, B nach C und C nach A.  Haben wir diese drei Vektoren, koennen wir die bereits implementierten Funktion von Vektor 2D verwenden, um die Laenge dieser Vektoren zu bestimmen.  Der Umfang ist dann die Summe der Laenge dieser Vektoren.", "start": 330.0, "end": 353.0}, {"text": "  Ausserdem soll die Methode Area implementiert werden.  Wie genau diese berechnet werden kann, zeige ich nun.  Wir schauen uns hier das ganze am Beispiel dieses 6x an.  Voraussetzung ist, dass sich die Flaeche von drei Ecken bestimmen kann.", "start": 353.0, "end": 376.0}, {"text": "  Wenn ich die Flaeche von drei Ecken bestimmen kann, dann brauche ich mein Polygon nur noch in drei Ecke aufteilen, die sich nicht ueberlappen und die ganze Flaeche des Polygons abdecken.  Hierzu bestimme ich erst einmal eine Ecke des Polygons als Ankerpunkt, in dem Fall unsere vertex Nr. 5.  Welche Ehe waehlt ist egal, es bietet sich allerdings an entweder die erste oder die letzte zu waehlen.", "start": 376.0, "end": 401.0}, {"text": "  Verwende ich meine letzte Ecke als Ankerpunkt, kann ich nun die vertices der Reihe nach durchgehen und immer aus zwei vertices und dem Ankerpunkt ein Dreieck bilden.  Das erste Dreik ist also 0, 1 und 5, das naechste 1, 2 und 5, das naechste 2, 3 und 5 und das letzte 3, 4 und 5.", "start": 401.0, "end": 418.0}, {"text": "  Sind meine vertices also genau in der Reihenfolge, wie sie hier stehen, kann ich mit einer Schleife ueber meine vertices iterieren  und dann jeweils aus meiner aktuellen Vertex, der naechsten Vertex und dem Ankerpunkt ein Dreieck bilden.  Fuer jedes dieser gebildeten Dreiecke kann ich die Flaeche berechnen, diese aufsummieren und komme so auf die Gesamtflaeche des Polygons.", "start": 418.0, "end": 441.0}, {"text": "  In der zweiten Aufgabe soll die Klasse Triangle implementiert werden.  Hierzu solltet ihr die beiden Konstruktoren implementieren.  Der eine Konstruktor bekommt drei Parameter vom Typ Vector2D, der andere Konstruktor ein Parameter vom Typ Triangle.  In beiden Faellen soll ein neues Triangle erzeugt werden, was eben genau diese drei Vector2Ds als Eckpunkte hat.", "start": 441.0, "end": 469.0}, {"text": "  Schaut euch dazu am besten noch einmal an, wie genau man den Konstruktor der Superklasse verwenden kann.  Ausserdem soll die Area-Methode ueberschrieben werden. Diese soll den Flaecheninhalt des Dreiecks zurueckgeben.  Hierzu koennt ihr die Formel von Heron verwenden.  Wie diese genau funktioniert, zeige ich euch nun.  Fuer die Formel von Heron benoetigen wir zuerst den Umfang des Dreiecks.", "start": 470.0, "end": 492.0}, {"text": "  Dazu summieren wir einfach die Laenge der drei Seiten auf.  Der Flaecheninhalt des Dreiecks berechnet sich nun wie folgt.  Wir nehmen den halben Umfang des Dreiecks und multiplizieren den jeweils mit dem halben Umfang minus eine der Seitenlaenge.  Daraus ziehen wir abschliessend die Wurzel.  Die Seitenlaenge kann man wie bereits vorhin erwaehnt berechnen.", "start": 492.0, "end": 520.0}, {"text": "  Ich habe Punkt 0 und Punkt 1 gegeben, ich kann also den Vector zwischen Punkt 0 und Punkt 1 bestimmen  und anschliessend bereits implementierte Methoden verwenden, um die Laenge dieses Vektors zu bestimmen.  In Aufgabe 3 sollte dann den Konstruktor von Tetragon implementieren.  Dieser erhaelt nicht 3, sondern 4 Parameter und ansonsten erbt er alle weiteren Methoden.", "start": 520.0, "end": 546.0}, {"text": "  Auch in Aufgabe 4 soll wieder ein Konstruktor geschrieben werden, diesmal fuer das Regular Polygon.  Hier soll nicht nur die Eckpunkte gespeichert werden, sondern darueber hinaus auch der Radius.  Im Gegensatz zu den Konstruktoren der vorherigen Form werden hier allerdings nicht die Eckpunkte mit uebergeben,  sondern nur die Anzeigeckpunkte und der Radius.", "start": 546.0, "end": 567.0}, {"text": "  Die Eckpunkte muessen also innerhalb des Konstruktors erzeugt werden.  Wie genau diese Eckpunkte gesetzt werden sollen, kann ich euch einmal am Beispiel eines Dreiecks zeigen.  In diesem Beispiel moechten wir ein regulaeres Dreieck erzeugen.  Deshalb haben wir N gleich drei Eckpunkte.  Ausserdem geben wir den Radius 1 an.", "start": 567.0, "end": 591.0}, {"text": "  Wir wissen ausserdem, dass fuer ein regulaeres Polygon die Eckpunkte alle gleichweit auseinander liegen muessen.  Ausserdem muessen unsere Eckpunkte auf diesem Kreis mit Radius 1 liegen.  Gegeben ist also der Radius 1 bzw. in dem Fall auch die Laenge dieser Orangenen Striche.", "start": 591.0, "end": 618.0}, {"text": " Gegeben ist ausserdem der Winkel, an dem sich die Eckpunkte innerhalb dieses Kreises befinden muessen,  da diese gleichweit auseinander sein muessen, in dem Fall also zum Beispiel bei 0\u00b0, bei 120\u00b0 und bei 240\u00b0.  Mit Hilfe von Sinus, Cosinus, unserem Winkel und dem Radius koennen wir also nun die 2D-Koordinaten von jedem Eckpunkt bestimmen.", "start": 618.0, "end": 634.0}, {"text": "  Genau das ist die Aufgabe, die es im Konstruktor zu loesen gilt.  Ausserdem soll die Methode resize implementiert werden.  Hierbei wird der neue Radius uebergeben, welcher gespeichert werden soll.  Ausserdem muessen entsprechend die Vertices angepasst werden.  Probiert hierzu am besten einmal aus, wie sich die Vertices veraendern, wenn sich der Radius des Kreises veraendert.", "start": 634.0, "end": 657.0}, {"text": "  Diese werden naemlich lediglich ausgehend vom Mittelpunkt des Kreises nach innen oder aussen verschoben,  je nachdem, ob der neue Radius groesser oder kleiner ist.", "start": 657.0, "end": 661.0}]}]