[{"lecture": "31624_18_course_video", "Timestamps": [{"text": "  Hallo, ich gruesse Dich. Heute moechte ich ueber Zufall sprechen. Das klingt vielleicht erst mal  ein bisschen komisch, aber tatsaechlich ist Zufall im Kontext von Algorithmen ein Werkzeug,  das sehr maechtig sein kann.", "start": 0.0, "end": 43.8}, {"text": "Zufall klingt jetzt erst mal nach irgendwie Unfall oder nach irgendwas  ist schief gelaufen, aber tatsaechlich ist Zufall ein wichtiges Werkzeug im Werkzeuggurt fuer Informatikerinnen  und Informatiker. Das ist jetzt kein konkrete Algorithmus, den wir heute besprechen, sondern eher  das Konzept von probabilistischen Algorithmen.", "start": 43.8, "end": 59.84}, {"text": "Also Algorithmen, deren Ablauf auf Zufaelligkeit  beruht.", "start": 59.84, "end": 81.16}, {"text": "Ihr habt sogar schon mal sowas gesehen, zum Beispiel bei Quicksort, falls ihr euch erinnert,  gab es eine Variante, in der das Pivot-Element, nachdem das benutzt wird, um die Liste, die man  sortieren moechte, in drei Unterlisten aufzuteilen, naemlich diejenigen Elemente, die kleiner sind als  das Pivot, diejenigen Elemente, die groesser sind als das Pivot und diejenigen Elemente,", "start": 81.16, "end": 89.64}, {"text": " die dem Pivot gleich sind. Der Grund, warum wir bei Quicksort versucht haben, oder nicht versucht  haben, sondern warum wir bei Quicksort das Pivot-Element zufaellig ausgewaehlt haben, war, um uns zu  schuetzen vor seltsam oder sehr strukturiert angeordneten Eingaben.", "start": 89.64, "end": 121.67999999999999}, {"text": "Wenn wir zum Beispiel also immer  das erste Element dieser Liste als Pivot-Element nehmen und uns eine sortierter Liste serviert wird,  dann unterteilen wir die Gesamtliste immer in zwei Unterlisten. Die eine besteht nur aus einem  Element und die andere besteht aus dem Rest.", "start": 121.67999999999999, "end": 132.72}, {"text": "Das heisst, wir bekommen nicht diese Beschleunigung,  die wir uns aus der Unterteilung in zwei ungefaehr gleichgrosse Haelften versprechen, sondern wir  bekommen diese maximale Laufzeit von Quicksort oder N\u00b2. Also wir haben das Pivot-Element zufaellig  ausgewaehlt, damit irgendeine Struktur, die in der Eingabe ist, uns nicht schaden kann.", "start": 132.72, "end": 156.0}, {"text": "  Na gut, das ist also ein Beispiel, das ich schon gesehen habe, wo Zufall in einem Algorithmus  verwendet wird, um den Algorithmus einer bessere erwartete Laufzeit, naemlich ordernlogn, zu verschaffen.  Trotzdem kann man sich erst mal fragen, wie kommt denn der Zufall ueberhaupt in den Computer? Denn  im Computer ist ja erst mal ganz mit Absicht alles sehr deterministisch.", "start": 156.0, "end": 187.56}, {"text": "Und das passiert,  indem man einen sogenannten Pseudo-Random-Number-Generator benutzt. Ich glaube auf Deutsch heisst das  Pseudo-Zufaelliger zu... weiss gar nicht, wie das auf Deutsch heisst. Und davon gibt es eine ganze Reihe.  Das fing an mit dem denniharischen Konkurrenzgenerator. Er ist ein sehr einfacher Zufallsgenerator.", "start": 187.56, "end": 211.95999999999998}, {"text": "Wenn  ich interessiert, wie der funktioniert, koennt ihr googlen. Der hat aber das Problem, dass eben die daraus  resultierenden Zahlen nicht wirklich so richtig Pseudo-Zufalls mehr...", "start": 211.95999999999998, "end": 233.2}, {"text": "also vielleicht ganz kurz,  was heisst es ueberhaupt, Pseudo-Zufaellig zu sein, anstatt wirklich zufaellig zu sein? Eine Pseudo-Zufallige  Zahlenfolge ist tatsaechlich gar nicht zufaellig, sondern die sieht nur, wenn man sie lokal betrachtet,  aus wie zufaellig.", "start": 233.2, "end": 247.2}, {"text": "Also das heisst, wenn man einen Pseudo-Random-Number-Generator benutzt und  unendlich viele Zufallszahlen nacheinander sich generieren laesst, wiederholen die sich immer wieder.", "start": 247.2, "end": 267.92}, {"text": " Aber wenn man irgendein lokalen Ausschnitt daraus nimmt, und man hofft natuerlich, dass die Laufzeit des  Programms immer nur ein lokaler Ausschnitt aus dieser risikenden Zahlfolge ist, der aehnelt dann  einer zufaelligen Reihenfolge sehr stark. Also das ist ein Pseudo-Random-Number-Generator.", "start": 267.92, "end": 273.84000000000003}, {"text": "Die  Eigenschaften von so einem linearen Konkurrenzgenerator sind nicht so gut wie zum Beispiel, um einfach mal  das zu nennen, die Eigenschaften von dem Mercent Twister-Zufallsgenerator. Das ist uebrigens der,  der benutzt wird, wenn ihr irgendwas Kryptografisches macht, wenn ihr SSH benutzt oder so laeuft in  euren Browser oder in eurer Software, der Mercent Twister mit ziemlich grosser Sicherheit.", "start": 273.84000000000003, "end": 298.72}, {"text": "  Interessanterweise ist der Mercent Twister ein Algorithmus von 1997. Also das ist noch gar nicht  so lange her und der Blum-Blum-Schub-Generator, der ist von 1986 benannt nach drei Personen,  Blum-Blum-Unschub. Also ihr seht, dass auf dem Gebiet der Pseudo-Random-Number-Generation immer noch  sich immer wieder in Entwicklung abstimmen.", "start": 298.72, "end": 332.32}, {"text": "Okay, also gehen wir mal davon aus, dass ihr in eurer  Programmiersprache einen halbwegs guten Zufallsgenerator integriert habt. Koennt ihr da zum Beispiel mal  rauskriegen in eurer Java-Distribution, welcher Zufallsgenerator wird denn benutzt, wenn ihr Random  in Java benutzt. Koennt ihr da mal versuchen rauszukriegen.", "start": 332.32, "end": 352.64}, {"text": "Auf jeden Fall wollte ich euch noch erzaehlen,  dass wenn ihr denn in eurem Programm irgendwas mit Zufaelligkeit benutzt, dass ihr dann sehr gut  ueber Debugging nachdenken solltet. Diese Zufallsgeneratoren, die haben etwas, das nennt sich Seed,  also so wie die Reggae und Hip-Hop-Band nur mit 2e anstatt 3.", "start": 352.64, "end": 379.91999999999996}, {"text": "Das ist der Ausgangspunkt, den dieser  Generator benutzt, um die zufaellige Zahlenfolge zu generieren. Ihr koennt diesen Seed bei eurem  Programmstart absichtlich zu einer bestimmten Zahl setzen und das garantiert, dass euer Programm  jedes Mal dieselbe Abfolge von Zufallszahlen bekommt.", "start": 379.91999999999996, "end": 400.52}, {"text": "Das hat den Vorteil, dass es sich irgendwie  debaggen laesst, weil ihr fuer den selben Code immer auch die gleichen Zufallszahlen in der gleichen  neuen Folge bekommt. Aber denkt dran, sobald irgendeine Veraenderung im Code eine weitere  Zufallszahl zwischendurchgeneriert ist, ist alles nicht mehr synchron.", "start": 400.52, "end": 417.76}, {"text": "Also das heisst,  das zu debaggen wird dann ziemlich schwierig. Auch ist es so, dass wenn ihr immer den gleichen  Seed benutzt, ihr natuerlich euer Programm nur fuer diese eine Zufallsfolge testet.", "start": 417.76, "end": 441.23999999999995}, {"text": "Das heisst,  nachdem ihr also mit dem selben Seed sichergestellt habt, dass euer Programm richtig funktioniert,  solltet ihr den Seed wechseln, damit ihr auch sehen koennt, ob das Programm auch fuer andere  Seeds funktioniert.", "start": 441.24, "end": 449.24}, {"text": "Im normalen Betrieb von einem bereits debagten Programm wurde man dann zum  Beispiel die Zeitfunktion einer Programmiersprache benutzen, um den Seed anhand der Millisekundenzahl,  die man als Uhrzeit bekommen kann zu, was wollte ich jetzt sagen, also man kann die Millisekundenzeit,  die man aus dem System erhaelt, benutzen als Seed.", "start": 449.24, "end": 472.96000000000004}, {"text": "Dann hat man sichergestellt, dass sich tatsaechlich  immer wieder eine neue Zahl als Seed verwendet wird und dass die sich auch zwischen zwei verschiedenen  Aufrufen des Programms eheblich unterscheiden.", "start": 472.96000000000004, "end": 496.28}, {"text": "Also, sobald man Zufaelligkeit benutzt, muss man  einige Dinge bedenken, ist meine Zufallsreihenfolge wirklich zufallsaehnlich oder ist sie nur so halb  okay. Und der zweite Punkt ist, dass die Buggen in dem Kontext von Zufallszahlen natuerlich ziemlich  schwierig und unvorhersehbar wird, deswegen das Wort Zufall.", "start": 496.28, "end": 511.96}, {"text": "Okay, aber nehmen wir mal an,  wir haben einen guten Zufallsgenerator in unserer Programmiersprache und wollen jetzt diesen Zufall  ausnutzen, um clevere Algorithmen uns auszudenken.", "start": 511.96, "end": 537.16}, {"text": "Vor den Algorithmen, die Zufall benutzen, gibt es  im Grunde genommen zwei Kategorien, die benannt sind nach den grossen Gambling-Paradisen auf der  Welt. Das ist natuerlich einmal das Vegas und das andere, falls ihr ihn erkannt habt, ist Monte Carlo.  Das ist das Spiel Casino von Monte Carlo.", "start": 538.0, "end": 552.52}, {"text": "Das sind zwei unterschiedliche Familien von Algorithmen,  wo Familie ist wahrscheinlich schon zu eng gesagt, das sind zwei Arten von probabilistischen Algorithmen,  es gibt die Las Vegas Algorithmen und es gibt die Monte Carlo Algorithmen.", "start": 552.52, "end": 571.72}, {"text": "Die Monte Carlo Algorithmen  haben die Eigenschaft, dass die Antwort falsch oder ungenau sein kann, dass wir aber die Laufzeit  kennen. Das klingt ja nicht so cool, also wenn die Antwort falsch sein kann oder ungenau,  das ist erst mal nicht so attraktiv.", "start": 571.72, "end": 587.88}, {"text": "Im Gegensatz dazu ist bei den Las Vegas Algorithmen die Antwort  immer korrekt, nur wissen wir die Laufzeit nicht so richtig. Ich muss zugeben, wenn man jetzt diese  beiden Dinge auf der obersten Ebene miteinander vergleicht, dann klingt es so, als ob die Las Vegas  Algorithmen irgendwie die besseren waeren.", "start": 587.88, "end": 602.4}, {"text": "Tatsaechlich ist es natuerlich nicht so, dass man  jedes Problem mit einem Las Vegas Algorithmus und mit einem Monte Carlo Algorithmus loesen kann.  Das heisst, je nachdem, waechst Problem anhanden, muss man sich fuer das ein oder andere vielleicht  entscheiden.", "start": 602.4, "end": 621.84}, {"text": "Aber ich wollte euch noch zu bedenken geben, dass wir als Informatikerinnen und Informatiker  auch gerne Probleme loesen wollen, die eigentlich zu schwer sind, um sie korrekt zu loesen.  Ihr erinnert euch zum Beispiel an das Traveling Salesman Problem, wo wir uns letztendlich auf  eine Apoximation verlassen muessen.", "start": 622.8000000000001, "end": 640.36}, {"text": "Das heisst, wenn wir ein wirklich schwieriges Problem haben,  dann koennte es sein, dass diese Monte Carlo Algorithmen eigentlich doch eine ziemlich gute Idee sind,  auch wenn das Ergebnis falsch, falsch ist natuerlich nicht so gut, aber ungenau ist manchmal in Ordnung.  Und wir werden viele Ideen sehen, zwei, wo Monte Carlo echt eine gute Idee ist.", "start": 640.36, "end": 658.24}, {"text": "  Wollen wir das ganz einmal ganz kurz mit ein bisschen Intuition zu fuellen, schauen wir uns mal die  Minimalversion von zum Beispiel einem Las Vegas Algorithmus an. Stellt euch vor, ihr haettet ein  Ray A, das ist N-Elemente lang und enthaelt 50 Prozent A's und 50 Prozent B's in einer zufaelligen  Reihenfolge und euer Ziel ist es, ein A zu finden.", "start": 658.24, "end": 695.84}, {"text": "Dieser Algorithmus wiederholt diese Schleife so lange  bis ein A gefunden wird und waehlt in dieser Schleife ein zufaelliges Element aus diesem Array aus,  solange bis ein Element A gefunden wird.", "start": 695.84, "end": 714.48}, {"text": "Das heisst, wir wissen, dieser Algorithmusthermonie  terminiert nur dann, wenn ein A gefunden wurde, also er terminiert mit dem korrekten und gewuenschten  Ergebnis, aber wir wissen nicht, wie oft diese Schleife durchlaufen werden muss, damit das auch  passiert.", "start": 714.48, "end": 732.96}, {"text": "Kann man aber zum Glueck relativ einfach berechnen, die erwartete Zeit, die dieser Algorithmus  braucht, ist der Limes von N gegen unendlich von der Summe von i bis n, von 1 bis n von i durch 2  Wie kann ich das verstehen? Also wir gehen also hier durch alle N-Moeglichkeiten durch,  das ist die Schleife, die wird N mal durchlaufen, beim N mal durchlaufen habe ich ja N-Schritte gemacht,", "start": 733.2800000000001, "end": 765.2800000000001}, {"text": " also die Kosten waeren N, aber die Wahrscheinlichkeit, dass ich N mal ein B waehle, wo ja die Haelfte  der Elemente in dem Array B sind, ist 1 durch 2 hoch diese Zahl i.", "start": 765.2800000000001, "end": 800.0}, {"text": "Also nochmal, wenn ich im ersten Schritt  ein A finde, dann ist 1 durch 2 hoch 1, eigentlich muesste ich minus 1 stehen, aber das ist egal,  also ich fahre nochmal von vorne an. Die Idee ist, dass wir hier alle moeglichen Kosten, die entstehen,  aufzaehlen mit der Wahrscheinlichkeit gewichtet, mit der sie auftreten, das ist der Erwartungswert.", "start": 800.72, "end": 814.4}, {"text": "  Hier oben stehen die Kosten, die summe ich auf, wenn i gleich 12 ist, muss ich also 12 mal geraten haben,  die Wahrscheinlichkeit, dass das passiert, ist aber 1 durch 2 hoch 12.", "start": 814.4, "end": 833.8399999999999}, {"text": "Das heisst, wir haben hier multipliziert  die Kosten einer bestimmten Situation mit der Wahrscheinlichkeit einer bestimmten Situation  und koennen so den Erwartungswert berichten. Wir sumieren jetzt ueber alle moeglichen Ergebnisse  auf bis hin zu unendlich und diese Summe, die kann man tatsaechlich ausrechnen und die Summe ergibt 2.", "start": 833.84, "end": 848.72}, {"text": "  Das heisst, der Erwartungswert von diesem Algorithmus ist, dass ich 2 mal fragen muss und dann finde  ich ein A. Es kann aber passieren, dass ich viel viel oefter fragen muss, die Wahrscheinlichkeit dafuer  ist nur sehr gering. Wenn ich also diesen Alkoholpuss benutze, kann es durchaus passieren, dass  da mal 20 oder mal 100 rauskommt, es ist nur eben sehr unwahrscheinlich.", "start": 848.72, "end": 874.1600000000001}, {"text": "Der Erwartungswert ist 2,  also sehr nah an der optimalen Loesung, wo ich gleich das richtige rate.  Das ist natuerlich Order 1, also konstante Zeit. Das ist erstmal ganz attraktiv.  Okay, das ist in das Wegers Algorithmus. Wir wissen nicht genau wann er terminiert,  aber wir wissen, wenn er terminiert, dann gibt er mir das richtige Ergebnis.", "start": 877.52, "end": 903.4399999999999}, {"text": "  Im Vergleich dazu ein Monte Carlo Algorithmus angewandt auf genau das gleiche Problem.  Nur gibt jetzt einen zusaetzlichen Parameter K und K legt fest, wie oft ich irgendwas versuche.  Also das heisst, ich zaehle hiermit, i ist gleich 0, i wird in der Schleife erhoeht.", "start": 903.4399999999999, "end": 929.76}, {"text": "Wenn die Anzahl  meiner Versuche gleich K ist, ich also das, was ich als Parameter uebergeben habe, ausgeschoepft habe,  oder ich einen A gefunden habe, erst dann terminiert die Schleife. Ich habe also jetzt 2 Bedingungen.  Die eine ist, dass ich K versuchen zu nehmen habe und die zweite ist, dass ich das A gefunden habe.", "start": 929.76, "end": 942.9599999999999}, {"text": "  Ihr seht also, dass dieser Algorithmus terminieren kann, ohne einen A gefunden zu haben.  Das heisst, hier wuerde der Algorithmus im Grunde genommen falsch terminieren, aber dass die Laufzeit  ganz klar durch K abgegrenzt ist, eingegrenzt ist.", "start": 943.6800000000001, "end": 968.32}, {"text": " So, jetzt muessen wir natuerlich noch wissen, wie hoch ist denn die Wahrscheinlichkeit,  dass ich ein A finde, wenn ich K versuche starten. Also wir wollen rauskriegen, was ist die Wahrscheinlichkeit,  dass wir ein A finden. Und das kann man auch einfach berechnen, das ist 1 minus 1 halb hoch K.  Wenn wir also, ich haette noch dazu schreiben muessen,  mit K versuchen.", "start": 968.4000000000001, "end": 1000.32}, {"text": " Also,  die Wahrscheinlichkeit ist 1, wenn wir immer ein A finden. Es gibt aber Moeglichkeiten, dass wir K mal  kein A finden. Damit das passiert, muessen wir K mal hintereinander ein B finden.  Und die Wahrscheinlichkeit, dass wir ein B finden, ist ein halb, weil ja in dem Array die Haelfte A's, die Haelfte B's sind.", "start": 1001.6, "end": 1027.28}, {"text": " Das heisst, wir muessen  einen halb  zur Kartenpotenz ist die Wahrscheinlichkeit, dass das eintritt. Dass wir also B, B, B, B, K mal finden.  Wenn irgendwas anderes eintritt, wenn wir also in irgendeinem dieser K Schritte kein B finden, dann finden wir ein A und sind fertig.", "start": 1028.08, "end": 1044.08}, {"text": "  Also die Wahrscheinlichkeit, dass wir ein A finden mit K versuchen, ist gleich 1 minus die Wahrscheinlichkeit, dass wir K mal hintereinander ein B raten.  Und das ist eben ein halb pro K.  Also hier wissen wir genau die Laufzeit und koennen uns berechnen,  wie gross die Wahrscheinlichkeit ist, dass wir die korrekte Loesung finden.", "start": 1045.04, "end": 1070.0}, {"text": "Und natuerlich haben wir jetzt durch die Wahl von K,  diese Wahrscheinlichkeit so nah wie moeglich an 1 oder so nah wie wir moechten, an 1 zu kriegen.  Und wir werden sehen, dass das eine Sache ist, die in vielen schwierigen Problemen  sehr, sehr interessant ist. Wie zum Beispiel beim Testen von Zahlen fuer Primzahlen.", "start": 1070.32, "end": 1090.08}, {"text": "  Wie das der Millerabintest fuer Primzahlen macht. Primzahlen, wisst ihr, sind extrem wichtig fuer,  wir waren schon ein paar Mal bei, bei kryptografischen Problemen.  SSH Verschluesselung, Public Private Key und so weiter und so fort basiert alles auf Primzahlen.  Also es ist ganz wichtig, dass es einen Test gibt, der uns sagt, ob eine bestimmte Zahl eine Primzahl ist.", "start": 1090.72, "end": 1111.92}, {"text": "  Es gibt seit kurzem, also seit 10 Jahren oder so,  also es gibt, nicht allzu langer Zeit, ein Algorithmus, der das in pundemierender Zeit macht,  eine Primzahl testen, der ist aber sehr kompliziert und in den Konstanten sehr hoch braucht also sehr lange.  Das heisst, wir benutzen hier einen Monte-Cado Algorithmus.", "start": 1113.1200000000001, "end": 1139.04}, {"text": "Denn was wir gegeben haben,  ist ein Test, der in Bezug auf eine Basis A mit einer Wahrscheinlichkeit von 1 V herausfindet,  ob eine Zahl prim ist. Ich will jetzt nicht erklaeren, wie das genau funktioniert.  Das erfordert eine kleine Dito in die Zahlentheorie. Das fuehrt glaube ich jetzt so weit.", "start": 1139.04, "end": 1158.32}, {"text": "  Aber es gibt also einen Test, der relativ einfach zu berechnen ist, der vor eine bestimmte Basis A mir sagt,  wenn dieser Test bestanden ist, dann habe ich die Wahrscheinlichkeit 1 V,  dass diese Zahl, die ich teste, eine Primzahl ist.  Gut, 1 V reicht natuerlich nicht aus, aber natuerlich kann ich diesen Test immer wiederholen.", "start": 1159.2, "end": 1195.76}, {"text": " Entschuldigung, also das, ich glaube,  ich glaube,  hier muesste dazustehen nicht.  Ob eine Zahl nicht prim ist.  Muss ich mal kurz anhalten.  Ja, ich glaube, so ist es richtig.  Das heisst, wir koennen durch wiederholendes Tests, erst mal mit verschiedenen Basis Basis A,  rauskriegen, dass eine Primzahl mit immer kleiner waehrend der Wahrscheinlichkeit keine Primzahl ist.", "start": 1195.92, "end": 1234.08}, {"text": "  Das heisst, wenn ich diesen Test wiederhole, zum Beispiel viermal,  dann ist die Wahrscheinlichkeit, dass ich dabei falsch liege, 0,4%.  Wenn ich den Saemen mal wiederhole, dann ist die Wahrscheinlichkeit, dass der bei falsch liege, schon 10-6%.", "start": 1234.08, "end": 1258.24}, {"text": " Das heisst, wir sehen hier, wir haben einen Algorithmus, der natuerlich sich ueren kann,  weil wir nie mit 100%iger Sicherheit feststellen koennen, ob eine riesige Zahl wirklich eine Primzahl ist.  Aber wir koennen dadurch, dass wir diese Berechnung wiederholen, die Wahrscheinlichkeit, dass wir falsch liegen,  sehr, sehr klein machen.  Und das ist genau das, was ein Monte Carlo Algorithmus macht.", "start": 1260.24, "end": 1282.0}, {"text": "  Wir waehlen also zufaellig eine geeignete Basis aus und wiederholen diesen Test mit verschiedenen Basen  und kriegen dadurch ziemlich, mit ziemlich hoher Wahrscheinlichkeit heraus, ob eine Zahl eine Primzahl ist.  Dieser Miller Rabin-Test ist ziemlich genau das, was auch bei euch im Browser ablaeuft.", "start": 1282.0, "end": 1306.0}, {"text": " Also wie ihr seht, wir haben hier eine kleine Detour in die probabilistische Algorithmen gemacht  und gleichzeitig in die Praktische Kryptografie.  Also der Miller Rabin-Test ist ein Monte Carlo Algorithmus.  Ich moechte euch noch ein Beispiel fuer Monte Carlo Algorithmen zeigen.  Und diesmal mit einer Anwendung.", "start": 1306.0, "end": 1328.0}, {"text": "  Ich habe ja in den ersten Vorlesungen immer wieder betont, dass unser Berufsbild im Grunde genommen darin besteht,  dass wir Probleme aus der echten Welt irgendwie abbilden und dann versuchen sie effizient zu loesen.  Ich moechte euch jetzt ein Problem aus der echten Welt zeigen,  weil wir haben auch ueber die strukturelle Molekularbiologie schon mal gesprochen.", "start": 1328.0, "end": 1352.0}, {"text": "  Ich moechte das nochmal erzaehlen, weil hier tatsaechlich die Monte Carlo Algorithmen jahrzehntelang eine riesige Rolle gespielt haben.  Also ihr wisst, dass Proteine im Grunde genommen die elementaren Bausteine von Leben sind.  Wir bestehen zu einem sehr grossen Teil aus Proteinen,  das was nicht Wasser ist und was nicht Knochen ist, ist im Grunde genommen Protein.", "start": 1352.0, "end": 1376.0}, {"text": "  Und ja, diese Proteine haben eine bestimmte Struktur und eine dreidimensionale Struktur.  Das kann man sich vorstellen, wirklich wie so eine Form.  Und diese dreidimensionale Struktur ist genau das, was bestimmt welche Funktion das Protein im Koerper erfuellt.", "start": 1376.0, "end": 1401.0}, {"text": " Chemisch gesehen, und es tut mir leid, dass ihr jetzt eine kleine Reise zurueckmachen muesst in eure Zeit mit Chemieunterricht,  das hier ist die Struktur von einer Aminosaeure.  Aminosaeuren sind die Bausteine, aus denen wiederum die Proteine zusammengebaut sind.  Ihr seht also hier ein Wasserstoff, ein Stickstoff, ein Kohlenstoff und ein Sauerstoff.  Und das R hier steht fuer Rest.", "start": 1401.0, "end": 1422.0}, {"text": "  Also das hier ist die wiederkehrende Gruppe von den Aminosaeuren.  Ihr erinnert euch vielleicht, ihr habt schon mal gehoert, dass es in der Biologie 20 Aminosaeuren gibt.  Die sind alle identisch, was das hier angeht.  Und die entscheiden sich darin, was hier in dieser lila Kugel passiert.", "start": 1422.0, "end": 1450.0}, {"text": " Und diese Aminosaeuren bilden Ketten, naemlich indem hier dieses OH von einer Aminosaeure abgespalten wird,  und das H hier von der naechsten, und dann bilden die eine Polymerkette.  Die sieht ungefaehr so aus.  Also wir haben hier unser C Alpha, und ihr seht, dass das hier ist.  Wir haben hier ein C Prime, und das entspricht dem hier.  Und hier ein Stickstoff, und das seht ihr hier.", "start": 1450.0, "end": 1482.0}, {"text": "  Also das hier ist im Grunde genommen eine Aminosaeure, nachdem sie polymerisiert ist.  Und ihr seht, dass das hier die naechste Aminosaeure ist, und das hier wieder die naechste, und so weiter.  So.  Jetzt haben wir hier ein Modell, das so versucht, das Ganze ein bisschen mechanisch darzustellen.  Und genau in dieser mechanischen Darstellung bleiben wir auch.", "start": 1482.0, "end": 1506.0}, {"text": "  Wir ignorieren, was in diesen lila Kugeln passiert.  Das ist tatsaechlich auch biologisch teilweise gerechtfertigt.  Und wir sehen, dass es hier diese Winkel gibt, um die sich diese Aminosaeuren kette, also das Protein, drehen kann.  Wenn ich jetzt fuer jede dieser Drehungen ein Wert festlege, ich nenne mal A1, A2,  fuer die beiden Pfeile hier, A3, A4, A5, A6.", "start": 1506.0, "end": 1543.0}, {"text": "  Also jeweils ein Wert, der festlegt, wie viel ist dieser Winkel hier gedreht, und daraus ein Vektor mache.  Dann habe ich eine eindeutige Zustandsbeschreibung, oder ich wollte vielleicht, ja, ich nehme mal S fuer Struktur.  Dann habe ich eine eindeutige Beschreibung der Struktur von diesem Protein.  Was ich daraus ergibt, sind tatsaechlich solche dreidimensionalen Strukturen.", "start": 1543.0, "end": 1568.0}, {"text": "  Oben ist ein Protein, das heisst Aktin, das ist in euren Muskeln, und das macht immer so eine Bewegung, um den Muskel zu kontrahieren.  Und unten ist Haemoglobin, das ist in euren roten Blutkoerperchen, um Sauerstoff zu transportieren.  So, was hat das jetzt alles mit Montecada, all Geritmen zu tun?  Das sage ich euch sofort.  Merkt euch, dass wir diesen Vektor haben, der den Zustand beschreibt.", "start": 1568.0, "end": 1602.0}, {"text": "  Die Struktur von dieser Kette, wie die gedreht und arrangiert ist, und damit auch, wie diese Lila-Kugeln zueinander in Bezug stehen.  Wie nah sie aneinander sind, oder wie weit sie voneinander entfernt sind.  So, das heisst, wir versuchen jetzt herauszukriegen, wenn ich die Abfolge der Aminosaeuren kenne, also genau weiss, welche der 20 Aminosaeuren sich in einem Protein in eine Kette gebildet haben.", "start": 1602.0, "end": 1628.0}, {"text": "  Kann ich dann vorher sagen, wie ein Protein wirklich in der dreidimensionalen Welt aussieht, wenn ich das koennte.  Und das koennen wir fast vollstaendig, seit ungefaehr einem Jahr, das war eine riesige Wissenschaft, durchbruchende Wissenschaft.  Wenn wir das koennten, dann koennen wir auch wirklich in der Biologie erhebliche Fortschritte machen, weil wir verstehen, wie die Proteine funktionieren.", "start": 1628.0, "end": 1649.0}, {"text": "  Okay, aber jetzt zurueck zu Monte Carlo.  Wir koennen das Problem der Vorhersage von der Struktur dieser Proteine wie folgt formulisieren.  Wir hatten diesen Vektor S, das war ein Vektor mit ganz vielen Elementen.  Und diese Elemente entsprachen den Winkeln und diese Winkel haben die Struktur bestimmt.  Ich bilde das jetzt hier im zweidimensionalen Raum ab.", "start": 1649.0, "end": 1676.0}, {"text": "  Natuerlich ist das nicht ganz zulaessig, das ist eine Karton, das ist eine Vereinfachung.  Also wir haben jetzt hier irgendwie S1 und hier haben wir S2.  Wir haben ja gesehen, dass es viel mehr Elemente in diesem Vektor S gibt,  aber dadurch, dass ich nur dreidimensional was zeichnen kann, bin ich jetzt hier auf diese Zweidimensionen beschraenkt.", "start": 1676.0, "end": 1701.0}, {"text": "  Also in der Ebene bilden wir die ganzen Zustaende ab, die ganzen Strukturen, die dieses Protein einnehmen kann.  Und aus der Ebene heraus haben wir eine Energie, die sich daraus ergibt, welche der lila Kugeln naheinander sind und welche fern.", "start": 1702.0, "end": 1724.0}, {"text": " Ihr kennt das aus der Physik, wenn zwei lila Kugeln, die zum Beispiel positiv geladen sind, naheinander sind,  das ergibt eine hohe Energie, wenn eine positiv geladenen Kugel naheinander eine negativ geladenen Kugel ist,  das ergibt eine niedrige und somit physikalisch guenstige Energie.", "start": 1724.0, "end": 1742.0}, {"text": "  Die Theorie ist jetzt, dass die Struktur des Proteins in der Natur einem niedrigen Energiezustand entspricht in dieser Energielandschaft.  Wir haben also eine Energielandschaft ueber den gesamten Zustandsraum des Proteins, hier zweidimensional, und in der dritten Dimension haben wir die Energie.", "start": 1742.0, "end": 1764.0}, {"text": "  Also zum Beispiel hier haben wir eine Struktur des Proteins, wo sagen wir mal, alle positiv geladenen lila Kugeln ganz naheinander sind,  also sehr hohe Energie, und hier haben wir eine sehr guenstige Energie, wo wir vermuten koennten, dass das dem natuerlichen Zustand des Proteins entspricht.", "start": 1764.0, "end": 1787.0}, {"text": "  Die Aufgabe fuers Monte Carlo Sampling, fuer unseren Monte Carlo Algorithmus, ist jetzt in dieser Energielandschaft, einen niedrig Energiezustand zu finden.  Wir wissen, dass der Zustandsraum S sehr hochdimensional sein kann, der kann bis zu 1000 Dimensionen haben,  dass also dieser 1000 Dimensionenraum niemals vollstaendig durchsucht werden kann.", "start": 1789.0, "end": 1810.0}, {"text": "  Also einfach ein Gitter ueber diesen Raum zu legen und alles zu besuchen, ist wissenschaftlich unmoeglich, geht nicht.  So, jetzt brauchen wir einen cleveren Algorithmus.  Wir koennen sofort die Idee aufgeben, dass wir tatsaechlich das globale Minimum dieser Energielandschaft jemals finden koennen.  Wir werden nur lokale Minimum finden, ob die dem globalen Minimum entsprechen.", "start": 1811.0, "end": 1831.0}, {"text": "  Das koennen wir nicht testen, weil wir eben nicht den gesamten Raum durchsuchen koennen.  Und das ist genau die Situation, die wir wollen von Monte Carlo.  Wir wissen, dass die perfekte Loesung fuer uns nicht erreichbar ist.", "start": 1832.0, "end": 1853.0}, {"text": " Aber wir hoffen, dass wenn wir eine gute Loesung finden, also ein gutes lokales Minimum,  ein Zustand des Proteins, der sehr niedrig energetisch ist, dass wir dann auch nah an unserer echten Loesung dran sind.  So, und jetzt kommt der Einsatz von Monte Carlo.  Monte Carlo, jetzt passieren zufaellige Dinge.  Und zwar geht das wie folgt.", "start": 1854.0, "end": 1872.0}, {"text": "  Wir fangen an mit einer zufaellig gewaehlten Initialen, das heisst Konformation in der strukturellen Manikulabiologie.  Wir koennen das aber hier Zustand nennen.  Wir fangen also mit einem zufaellig gewaehlten Zustand, ein Vektor, der zufaellig gewaehlt ist,  der also allen diesen Winkeln einen zufaelligen Wert zuweist und machen dann einen zufaelligen Schritt in unserem Suchraum.", "start": 1873.0, "end": 1897.0}, {"text": "  Also wir waehlen uns zum Beispiel ein Element aus dem Vektor S aus und zaehlen da ein kleines Delta drauf.  Das entspricht dem gelben Punkt hier.  Jetzt kommt, also das war schon mal ein zufaelliger Schritt, aber jetzt kommt was wichtiges, naemlich einen Kriterium, ob wir diesen Schritt annehmen oder ob wir ihn verwerfen.", "start": 1898.0, "end": 1923.0}, {"text": "  Und das Kriterium ist, dass wenn der Schritt nach unten geht, nehmen wir ihn an, wenn der Schritt nach oben geht, nehmen wir ihn an mit einer gewissen Wahrscheinlichkeit.  Das heisst also dieser Schritt zum Beispiel wird jetzt abgelehnt, weil er nach oben gegangen ist und wie gesagt haben, der Zufall sagt, ich lehne diesen Schritt ab.", "start": 1924.0, "end": 1944.0}, {"text": "  Das heisst wir waehlen jetzt den naechsten Schritt und den naechsten Schritt und den naechsten Schritt und ihr seht jetzt hier die Folge von Schritten, die sich daraus ergibt, dass immer wieder neue zufaellige Schritte gewaehlt werden.  Und dann angenommen, wenn sie runterlaufen und wenn sie hochlaufen, ist es eine Frage von Zufall, ob sie angenommen werden oder nicht.", "start": 1945.0, "end": 1971.0}, {"text": "  Ihr habt gesehen, dass jetzt dieser Suche eine Weile in diesem Tal verweilte, eine Weile war sich hier stecken geblieben, weil eben eine Reihe von unwahrscheinlichen aufeinander folgenden den Berg wieder hoch laufenden Schritten notwendig ist,  um diese Bergkante hier zu ueberwinden.  Wenn wir aber das ueberwunden haben, dann kann der Algorithmus schoen wieder das Tal durchschreiten.", "start": 1971.0, "end": 1996.0}, {"text": "  Das heisst, wir haben ein Algorithmus, der es uns erlaubt, eine Energielandschaft mit vielen lokalen Minimum, wie zum Beispiel dieses hier, zu durchlaufen, zu durchsuchen,  in der Hoffnung, dass wir insgesamt ein gutes lokales Minimum finden.  Und der Trick, den wir anwenden, ist, dass wir mit einer gewissen Wahrscheinlichkeit auch aus den lokalen Minimum wieder rauskommen.", "start": 1996.0, "end": 2019.0}, {"text": "  Das ist jetzt ein Algorithmus, das ist ein Monte Carlo Algorithmus, das heisst, wir wissen am Ende nicht, ob das, was wir rauskriegen, das Richtige ist.  Aber wir koennen natuerlich bestimmen, wie viele Schritte wir machen und deswegen wissen wir, wann dieser Algorithmus terminiert.  Ich habe das jetzt sehr vereinfacht erklaert.", "start": 2019.0, "end": 2042.0}, {"text": "  Es gibt hier einen Millionen kleinen Tricks und Kniffe, mit denen man diesen Algorithmus beschleunigen oder verbessern kann.  Zum Beispiel, wenn ich das interessiert, koennt ihr ja immer googlen Simulated Anealing Monte Carlo Sampling.", "start": 2042.0, "end": 2065.0}, {"text": "  Aber die Idee hier ist, dass wir eben den Zufall verwenden, um aus einem sehr schwierigen Suchproblem, naemlich finde, dass ein gutes Minimum in einer sehr komplizierten Energielandschaft,  einen sehr einfachen Algorithmus zu machen, der grosse Chancen hat, uns ein gutes Minimum zu liefern.", "start": 2065.0, "end": 2079.0}, {"text": "  Dieses Monte Carlo Sampling wird seit, ich wuerde sagen, seit den 60er Jahren, also das sind mittlerweile 60 Jahre,  in vielen, vielen physikalischen und chemischen Simulationen und auch in biologischen Simulationen verwendet.  Also Monte Carlo Sampling ist in den Wissenschaften eine der, wuerde ich sagen, am weitesten, verbreitesten Algorithmen, um derartig komplizierte Suchprobleme zu loesen.", "start": 2080.0, "end": 2105.0}, {"text": "  Und das ist ein Monte Carlo Algorithmus.  Jetzt haben wir zwei Beispiele gesehen fuer Monte Carlo, naemlich die Primzahlberechnung und hier dieses Monte Carlo Sampling.  Wir haben auch schon ein Beispiel gesehen fuer Las Vegas.  Das war naemlich unser Quick Sort.  Das ist ein Las Vegas Algorithmus, wenn wir das Pivo-Element zufaellig aussuchen.  Das Ergebnis ist richtig, was rauskommt.", "start": 2107.0, "end": 2137.0}, {"text": "  Es ist immer eine Sortitaliste.  Aber wir koennen nicht ganz genau vorhersagen, was die Laufzeit ist.  Die kann sich abspielen zwischen Order N log N oder Order N\u00b2.  Okay, das sind die beiden grossen Familien, Las Vegas und Monte Carlo Algorithmen.  Zum Schluss moechte ich euch noch eine Sache sagen, naemlich, dass die Verwendung von Zufall tatsaechlich manche Sachen besser machen kann.", "start": 2138.0, "end": 2173.0}, {"text": "  Also das ist jetzt hier ein Zitat aus Wikipedia, ich lese das einfach mal vor.  Die Laufzeit von einem Konvex-Badie kann durch einen randomisierten Algorithmen eine orbitaere Praezision in einer polonomenen Zeit gestalten.  Die zwei Leute haben gezeigt, dass ein nicht deterministisches Algorithm das Gleiche tun kann.", "start": 2174.0, "end": 2195.0}, {"text": "  Das ist unkonditioniert, ohne die Komplexitaet der theoretischen Assumpten zu verlangen.  Okay, lassen wir uns das ganz kurz mal auseinandernehmen.", "start": 2196.0, "end": 2221.0}, {"text": " Also zum ersten Mal, was ist denn ueberhaupt ein konvexer Koerper?  Was ist denn Konvexitaet?  Ein Koerper ist dann Konvex, wenn alle zwei Punkte in seinem Inneren mit einer Linie verbunden werden koennen,  so dass die Linie vollstaendig innerhalb des Koerpers verlaeuft.  Das hier ist also nicht Konvex.", "start": 2222.0, "end": 2247.0}, {"text": " Im Gegensatz dazu ist zum Beispiel diese Form, Konvex,  weil ich alle beliebigen Punkte hier mir suchen kann und eine Linie zwischen den beiden ist innerhalb des Objekts enthalten.  Okay, wir koennen also einen randomisierten Algorithmus entwickeln,  oder der wurde entwickelt, der mit einer beliebigen Genauigkeit in polonomener Zeit das Volumen dieses Koerpers berechnen kann.", "start": 2248.0, "end": 2274.0}, {"text": "  Also egal, wie kompliziert die Oberflaeche ist, so lange die Konvex ist, kann ich in polonamer Zeit mit diesem Algorithmus,  das Volumen dieses Koerpers mit einer beliebigen Genauigkeit berechnen.  Und diese beiden Leute haben bewiesen, dass es kein deterministischen Algorithmen geben kann, der genau das Gleiche tut,  der also das in polonemaler Zeit macht.", "start": 2274.0, "end": 2303.0}, {"text": "  Das heisst, diese Komplexitaetsklasse BPP, das steht fuer Bounded Error Probabilistic Polonomial Time,  diese Komplexitaetsklasse scheint ein Problem zu enthalten, das nicht in P enthalten ist.  Also wenn das so ist, wuerden wir sagen, das gilt nicht,  sondern tatsaechlich, es gibt ein Element in dieser Bounded Error Probabilistic Polonomial Time Klasse, das nicht in P enthalten ist.", "start": 2304.0, "end": 2336.0}, {"text": "  Dieser Zusatz, this is truly unconditionally, this is true unconditionally, that is without relying on any complexity theoretic assumptions,  ist ein Satz, der auf eine beliebte Art von solchen Beweisen abzielt, die eine Annahme machen, wie zum Beispiel,  wir haben darueber schon gesprochen, ob NP gleich P ist, und man kann dann bestimmte Dinge beweisen,", "start": 2336.0, "end": 2364.0}, {"text": " indem man sagt, wir nehmen an, was jeder vernuenftige Mensch, glaube ich, momentan annimmt, dass P ungleich NP ist,  und unter dieser Annahme kann man irgendwas beweisen.  Also dieser Beweis ist tatsaechlich nicht abhaengig von diesen Dingen,  das heisst, selbst wenn jemand beweisen sollte, dass NP gleich P ist, wuerde dieser Beweis nicht verschwinden.", "start": 2364.0, "end": 2386.0}, {"text": "  Es ist also ein sehr solider Beweis, dessen Gueltigkeit nicht von zukuenftigen Entwicklungen mehr abhaengt.  All das nur, um zu sagen, dass es faszinierenderweise unter der Benutzung von Zufall moeglich ist,  Algorithmen zu machen, die schneller sind als Algorithmen, die nicht probabilistisch sind.", "start": 2386.0, "end": 2415.0}, {"text": "  Das heisst, der Zufall, durch die Verwendung des Zufalls, gewinnen wir etwas, was wir deterministisch nicht erreichen koennen.  Das Einbinden von Zufall in unser Algorithmen ermoeglicht uns also an bestimmten Problemen,  wirklich strikt, bessere Loesungen zu finden.  Und das ist, erst mal finde ich zumindest immer noch, obwohl ich das schon seit einer gewissen Zeit weiss, wirklich ueberraschend.", "start": 2415.0, "end": 2437.0}, {"text": "  Okay, fassen wir zusammen.  Zufall ist ein Werkzeug fuer uns Informatikerinnen und Informatiker.  Er kann uns helfen, unguenstige Faelle zu umgehen, wie zum Beispiel bei QuickSort.  Er kann uns helfen, Algorithmen elegant und einfacher zu implementieren.  Das haben wir jetzt nicht direkt gemacht, indem wir ein deterministischen und ein probabilistischen Algorithmus einander verglichen haben.", "start": 2437.0, "end": 2474.0}, {"text": "  Aber das koennt ihr mal versuchen zu recherchieren, ob ihr da irgendwas findet, wofuer es beides gibt.  Und meistens sind die probabilistischen Algorithmen wesentlich eleganter und einfacher zu implementieren.  Und es liefert sogar Loesungen, die wir sonst nicht haetten finden koennen.  Es gibt grob gesagt die Klasse der Las Vegas Algorithmen und die der Monte Carlo Algorithmen.", "start": 2474.0, "end": 2497.0}, {"text": "  Wir haben Beispiele dafuer besprochen.  Und ich denke, damit habe ich euch erzaehlt, was ich euch heute erzaehlen wollte.  Ich wuensche euch noch einen schoenen Tag. Tschuess!", "start": 2497.0, "end": 2508.0}]}]