[{"lecture": "31624_31_course_video", "Timestamps": [{"text": "  In diesem Video wollen wir uns die Aufgabe 3 des Aufgabenblattes anschauen, also die Hausaufgabe.  Dazu wechsle ich einmal zum Aufgabenblatt.  In der Hausaufgabe diese Woche soll das Spiel Tic-Tac-Toe implementiert werden.", "start": 0.0, "end": 27.96}, {"text": " Hierbei beschraenken wir uns allerdings nicht nur auf 3x3 Felder, auf den Tic-Tac-Toe sonst gespielt wird,  sondern auf Felder, die N mal N-Gruss sind, wobei N kleiner gleich 10 ist.  Allerdings hat man auch auf den groesseren Feldern gewonnen, wenn N gleiche Steine eine Reihe bilden.  Im ersten Teil der Aufgabe soll die Klasse Bord programmiert werden.", "start": 28.96, "end": 48.24}, {"text": "  Diese Klasse hat zum einen ein Konstruktor, welcher den Parameter N uebergeben bekommt und ein Spielbett der Groesse N mal N erzeugen soll.  Wie ihr das Spielbrett implementiert, ist hier euch ueberlassen.  Dabei bietet es sich an, das Spielbrett in einem Attribut zu speichern.  Liegt der Parameter N nicht zwischen 1 und 10, dann soll eine Input Miss-Match-Exception geworfen werden.", "start": 49.519999999999996, "end": 70.64}, {"text": "  Dazu schauen wir uns noch einmal kurz an, wie Exceptions in Java funktionieren.  Exceptions sind in Java eine Moeglichkeit Fehler anzuzeigen.  Diese kann man beispielsweise verwenden, wenn man Fehler nicht mittels eines Return-Werts anzeigen kann, beispielsweise im Konstruktor.  An der Stelle, wo der Fehler auftritt, kann man dann eine Exception von einem bestimmten Typ werfen.", "start": 72.64, "end": 95.64}, {"text": "  Dieser hat den gleichen Effekt wie ein Return, das heisst man verlaesst die Funktion.  Wird die Exception allerdings nicht aufgefangen, endet das Programm.  Um eine Exception zu werfen, gibt es das Schluesselwort Throw.  Anschliessend erstellt man eine neue Exception mit dem Schluesselwort New, gibt anschliessend den Typ der Exception an und in Klammern optional eine Nachricht.", "start": 96.64, "end": 120.64}, {"text": "  Hier haben wir mal ein Beispiel.  Probiert ein Spieler zum Beispiel einen Zug zu ziehen, der nicht erlaubt ist, kann nicht darauf mittels einer Runtime-Exception hinweisen.  Um diese Runtime-Exception zu werfen, schreibe ich Throw, New, dann den Typ Runtime-Exception und in Klammern die Nachricht in dem Fall Zug ist nicht erlaubt.", "start": 120.64, "end": 148.64}, {"text": "  Da wir nicht wollen, dass eine Exception unser Programm immer zum Absturz bringt, gibt es die sogenannten Try and Catch Bloecke.  Hier koennen wir in dem Try Block Code ausfuehren und sollte innerhalb des Try Blocks eine Exception auftreten, dann koennen wir diese mit des Catch Befehlens auffangen.", "start": 149.64, "end": 175.64}, {"text": "  Das funktioniert so, dass wir erst den Try Block schreiben, anschliessend Catch in Klammer den Exception Typen, der einen Namen geben und diese Exception dann innerhalb dieser geschweiften Klammern verarbeiten.  Ich habe hier mal ein Beispiel. Wir probieren erst ein Spielzug zu machen, deswegen steht dieser im Try Block.  Hier versuchen wir diesen Spielzug auszufuehren.", "start": 176.64, "end": 192.64}, {"text": "  Wenn mir diese Methode jetzt eine Runtime-Exception wirft, dann lande ich im Catch Block.  Hier fange ich eine Runtime-Exception auf, dienen ich E und innerhalb dieses Blockes gebe ich eine Fehlermeldung aus, welche in der Exception gespeichert ist.  Lasse ich diesen Try and Catch Block weg und rufe nur die Methode Spielzug auf, dann wird mein Programm an der Stelle abstuerzen.", "start": 193.64, "end": 221.64}, {"text": "  Wird allerdings von der Methode Spielzug keine Runtime-Exception geworfen, dann wird auch der Catch Block uebersprungen.", "start": 221.64, "end": 240.64}, {"text": "  Bisher haben wir im Konstruktor also ueberprueft, ob N zwischen 1 und 10 liegt, wenn nicht haben wir eine Input-Mismatch-Exception geworfen und ansonsten haben wir ein neues Spielfeld erstellt von einem bestimmten Datentypen, welcher uns ueberlassen ist und dieses Spielfeld initialisiert.  Zu Beginn des Spieles ist das Spielfeld leer.", "start": 241.64, "end": 252.64}, {"text": "  Sollten wir im Laufe der naechsten Aufgaben allerdings noch weitere Attribute einfuehren, so muessen diese natuerlich auch im Konstruktor initialisiert werden.  Die naechste Methode, die wir schreiben sollen, heisst N Free Fields.  Hier soll die Anzahl der freien Felder auf dem Feld zurueckgegeben werden.", "start": 253.64, "end": 270.64}, {"text": "  Damit nicht bei jedem Aufruf dieser Methode das gesamte Spielfeld durchsucht werden muss, soll auch das in einem Attribut gespeichert werden.  Die Methode gibt dann nur den Wert des Attributes zurueck.  Mit der Methode Setfield soll auf eine bestimmte Position ein Token gesetzt werden.", "start": 271.64, "end": 291.64}, {"text": "  Schaut euch dazu einmal an, wie die Klasse Position definiert ist und wie ihr diese Informationen verwenden koennt, um den Spielstein in eure Datenstruktur zu setzen.  Der Integer Token gibt dabei an, welcher Spielstein auf das Feld gesetzt werden soll.  Eine 0 steht hierbei fuer ein freies Feld, die minus 1 fuer ein Kreis und die 1 fuer ein X.", "start": 293.64, "end": 310.64}, {"text": "  Die Methode GetField soll nun genau diesen Wert einer bestimmten Position zurueckgeben.  Uebergebe ich also die Position eines leeren Feldes, bekomme ich 0 zurueck, ist auf der Position zum Beispiel ein X, bekomme ich eine 1 zurueck.  Die Methode Setfield und GetField sollen beide auch eine Input Missmatch exception werfen, wenn die Parameter ungueltig sind.", "start": 311.64, "end": 334.64}, {"text": "  Das heisst, wenn die Position zum Beispiel ausserhalb des Feldes liegt oder der Wert des Tokens ungueltig ist.  Die naechste Methode ist die DoMove Methode.  Hierbei wird eine Position uebergeben und ein Spieler.  Spieler hat hier wie die Tokens den Wert 1 oder minus 1, wobei 1 auch wieder fuer den Spieler steht der X ersetzt und minus 1 fuer den Spieler der Kreise setzt.", "start": 335.64, "end": 358.64}, {"text": "  Ein Spielzug auszufuehren heisst diese entsprechende Position auf dem Feld zu markieren.  Mit der Methode AndoMove macht man dann einen Zug auf diesen Feld rueckgaengig.  Rueckgaengig machen heisst hier nur, den Spielstein von diesem Feld zu entfernen.  Man muss sich hier nicht merken, welche Zuege bereits gemacht wurden.", "start": 359.64, "end": 381.64}, {"text": "  Schaut bei den Methoden DoMove und AndoMove doch einmal, welche Methode, die ihr bereits geschrieben habt, euch helfen koennten, diese Methode umzusetzen.  Die Methode ValidMove bekommt keine Parameter und gibt ein Iterable ueber verschiedene Positionen zurueck.  Hier koennt ihr euch eine Datenstruktur aussuchen, welche Iterable implementiert.", "start": 383.64, "end": 398.64}, {"text": "  Das trifft zum Beispiel auf die verschiedenen Arten von Listen zu.  Hier sollen nun also in zum Beispiel einer Liste alle Felder zurueckgegeben werden, auf die man ziehen kann.  Das bedeutet alle Felder, die noch leer sind.  Abschliessend gibt es noch die Methode IsGameOne.  Diese soll ein Bullion zurueckgeben, ob das Spiel durch den letzten Zug, der PerDoMove gemacht wurde, gewonnen wurde.", "start": 399.64, "end": 425.64}, {"text": "  Ueberlegt euch auch hier einmal, wie man das Ganze effizient implementieren kann.  Bedenkt auch, dass ihr fuer diese Aufgabe beliebig viele Attribute der Klasse hinzufuegen koennt.  In der zweiten Aufgabe soll die Methode AlphaWetter in der Klasse TicTacTow implementiert werden.  Diese soll eine AlphaWetter-Suche zur Bewertung der Spielsituationen ausfuehren.", "start": 426.64, "end": 451.64}, {"text": "  Dabei uebergeben wir der Methode des aktuelle Bord und einen Spieler, aus dessen sich das Ganze bewertet werden soll.  Die Methode soll dann die folgenden Werte zurueckgeben.  Eine 0 bei einem unentschieden, p plus 1, wenn Spieler 1 gewonnen hat, mit p-freien Feldern  und minus p minus 1, wenn Spieler minus 1 gewonnen hat, mit p-freien Feldern.", "start": 452.64, "end": 475.64}, {"text": "  Dabei ist es auch moeglich, euch weitere Methoden zu schreiben, die von der AlphaWetter-Methode aufgerufen werden.  Wie eine AlphaWetter-Suche allerdings genau funktioniert, schauen wir uns im Video zur Aufgabe 1.  Im dritten Teil der Aufgabe 1 soll noch die Methode Evaluate PossibleMoves implementiert werden.", "start": 477.64, "end": 495.64}, {"text": "  Auch hier wird wieder ein Bord uebergeben und der Spieler, aus dessen sich das Ganze bewertet werden soll.  Nun soll das Ganze so bewertet werden, wie in diesem Beispiel.  Fuer jedes Feld, auf dem bereits ein Spielschein steht, soll der entsprechende Spielstein ausgegeben werden, also o oder x,  und fuer jedes andere Feld soll die entsprechende Bewertung zurueckgegeben werden.", "start": 496.64, "end": 518.64}, {"text": "  Eine Methode, die euch eine Spielbrett-Situation evaluiert, habt ihr bereits geschrieben.  Wir muessen nun also nur ueberlegen, wie ihr diese Methode nutzen koennt, um alle Positionen auf dem Spielbrett zu evaluieren.  Was dann auf der Konsole ausgegeben werden soll, seht ihr dort oben.", "start": 519.64, "end": 543.64}, {"text": " Hier haben wir einmal ausgegeben, fuer welchen Spieler das Ganze evaluiert wurde,  und dann das aktuelle Spielbrett, auf dem die gesetzten Spielsteine vermerkt sind, und die Bewertung fuer jede Position auf dem Spielfeld.  Wuerde Spieler x also oben links ein Spielstein hinsetzen, wuerde das Ganze unentschieden ausgehen.", "start": 544.64, "end": 556.64}, {"text": "  Wuerde Spieler x allerdings unten links ein Spielstein hinsetzen, so wuerde er das Ganze gewinnen, sofern keiner Fehler macht.  Setzt Spieler x allerdings auf das Feld mit der Minus 2, so wird Spieler o gewinnen.  Das waren alle Aufgaben, die der Hausaufgabe dieser Woche zu loesen sind.", "start": 557.64, "end": 576.64}, {"text": "  In den anderen Videos zu diesem Aufgabenblatt schauen wir uns dann das Prinzip der Alphabettersuche an und das Prinzip von Branch Entbound.", "start": null, "end": 576.64}]}]