[{"lecture": "25797_14_course_video", "Timestamps": [{"text": "  Willkommen zur naechsten Videoreihe unserer Uebungen im wissenschaftlichen Rechten.  Ich bin St. Derg, einer eurer Tutorin dieses Semester.  Und heute beschaeftigen wir uns mit Gleitkommar zu Alpen.", "start": 0.0, "end": 41.0}, {"text": " In diesem Kapitel im Allgemeinen werden wir Begriffe kennenlernen wie Maschinengenauigkeit, Ausloeschung,  das Konzept von absolutem und relativem Waehler und moegliche Darstellungsmethoden fuer Zahlen auf unserem Rechner.", "start": 41.0, "end": 65.0}, {"text": " Zunaechst, warum machen wir das alles?  In wissenschaftlichen Rechten geht es darum, reale Phaenomene, also aus der Welt, sagen wir,  unserem Rechten zu modellieren und Probleme, die bei diesen Phaenomen entstehen, zu loesen mit algorithmischen Ansaetzen.  Und dies beschreiben wir mit Zahlen.", "start": 65.0, "end": 79.0}, {"text": "  Und deswegen suchen wir eine geschickte Darstellung von Zahlen und einem informierten Umgang mit diesen Darstellungsmethoden zu erreichen.  Zunaechst geht es um die Darstellung von Zahlen im Allgemeinen.  Also das Schluesselwort hier ist das Stellenwertsystem, das kennen wir aus dem Alltag.", "start": 80.0, "end": 108.0}, {"text": "  Wenn wir eine Reihe Ziffern hinschreiben, dann bedeuten dieser Ziffer mehr als einfach eins und dann zwei und acht.  Es gibt dieses Stellenwertsystem, impliziert dahinter.  Genauer schauen wir uns mit ein paar Ballspielen an, dass die Ziffer eins die Wertigkeit von eins mal runter hat,  dass die Ziffer zwei die Wertigkeit von zwei mal zehn hat und acht acht mal eins.", "start": 108.0, "end": 144.0}, {"text": "  Das wird explizit durch Potenzen bezueglich einer Basis dann hier angegeben.  Aber das ist im Grunde die Idee, die wir alle kennen.  Die Koefficienten sind dann unsere Ziffer zu multiplizieren mit Potenzen einer Basis und dann sie alle zu summieren.  Eine Summe von Potenzen, eine Basis.  Das koennen wir auch bezueglich der Basis von zwei machen.", "start": 144.0, "end": 181.0}, {"text": "  Das ist einfach, wenn wir feststellen, dass 128 nichts anderes ist als die siebte Potenz von zwei.  Das heisst, wir wuerden im Binaeren einmal an dieser Stelle ein Eins hinschreiben und dann sonst eine Reihe Nulle.  Mit 11,57 koennen wir das auch machen bezueglich des Zehnassystems.  Eins steht fuer zehn, unsere erste Ziffer eins, die zweite Ziffer fuer eins, die dritte fuer 0,5 und die sieben fuer 0,07.", "start": 181.0, "end": 227.0}, {"text": "  Insumieren Sie alle mit der reichen, die gewuenschte Zahl.  Uebrigens, falls Ihr Euch fragt, diese Zehn im Subscript heisst, wir beziehen uns bei dieser Darstellung diese hier auf das Zehnassystem.  Das Smart System.  Gut, zur Basis zwei koennen wir langsam versuchen, Stueck fuer Stueck Zahlen zu addieren, bis wir nah an diese gewuenschte Zahl kommen.  Das mache ich zu einem gewissen Punkt.", "start": 228.0, "end": 274.0}, {"text": "  Bei diesem Beispiel, dem ich sage, 8 plus 2, das ist 10 plus 1, das ist 11 plus 0,5, das ist 11,5.  Diese Zahlen sprechen dann dieser Potenzen.  Allerdings mache ich nicht weiter, denn im binaeren System, sich an dieser Zahl anzunaehern, ist das einzige, was wir erreichen koennen,  aber diese Zahl exakt darzustellen scheint nicht moeglich zu sein.", "start": 274.0, "end": 311.0}, {"text": "  Also wir koennen weiter sumieren mit Potenzen von zwei und hoffen, dass wir sehr nah daran kommen,  aber es ist nicht moeglich, diese 11,57 exakt darzustellen.  Okay, so viel zu allgemeinen Zahlendarstellungen.  Wir werden spaeter sehen, dass das unsere Gleitkommazalfomat auf dieser Idee aufbaut, mit Multiplikationen mit Potenzen.  Erstmal Zahlen, Zahlen und Formate in Python und NumPy.", "start": 311.0, "end": 360.0}, {"text": "  Da stehen wir uns drei built-in Typen zur Verfuegung, naemlich ints, floats und complexes.  Und numpy endlich, dazu auch uns ein ints.  Und darueber hinaus koennen wir in numpy angeben, wie viele bits wir fuer unsere Zahlen oder Datentypen benutzen wollen.", "start": 360.0, "end": 395.0}, {"text": " Zum Beispiel koennte man sagen, wenn von vornherein gewusst ist, dass der Wertbereich in der Naehe von nicht hoeher als 100 wird,  koennte man ints der Groesse 8 waehlen.  Das ist moeglich.  Wichtig fuer unsere Anwendungen wird es mit float 32 und 64 sein.  Da sind zwei Formate bei numpy.  Okay, hier habe ich ein bisschen Code geschrieben, um zu zeigen, was diese typischen Formate sind.", "start": 395.0, "end": 440.0}, {"text": "  Also in der ersten Reihe dieser Liste, oder die ersten drei Eintraege, sind diese Zahlen zu finden und dann die zugehoerigen Typen.  In diesem Fall.  Diese Typen sind Klassen von Objekten.  Und der Python interpreter sieht diese Zahl 14 und versteht es als ein integer, obwohl ich das gar nicht explizit gesagt habe.", "start": 440.0, "end": 476.0}, {"text": "  Und diese Zahl 2,37 etc. wird auch explizit, also im float verstanden, da ein Punkt hier auf vorkommt.  Und bei den komplexen Zahlen, dieses j, indem ich dieses Zonderzeichen hinzufuege,  mache ich klar, dass ich es mit komplexen Zahlen zu tun haben moechte.  Genauer dieser sieben ist der imaginaere Teil und der drei der realer Teil unserer komplexen Zahl.", "start": 477.0, "end": 513.0}, {"text": "  Also dieses Beispiel sollte auch zeigen, veranschaulich in das Dogtyping System von Python,  denn unser Objekt, in diesem Fall Zahlen, sich wie ints Verhalten oder wie ints Aussehen,  dann werden sie wie ints auch behandelt.  Oder, ich wuerde es gut finden.  Bei diesen NumPy-Formate habe ich explizit gesagt, dass ich ein gewisses Format moechte.", "start": 513.0, "end": 562.0}, {"text": "  Dieses Casting und dabei entstehen auch die Formate, also die Typen, in denen man castet.  Gut, wir kommen jetzt zu ein paar Beispielen, wo komische Sachen passieren koennen,  wenn wir nicht aufpassen, also ein paar Ueberraschungen.  Und das haengt damit zusammen, dass wir hier Berechnungen mit irrationalen Zahlen machen.", "start": 562.0, "end": 605.0}, {"text": " Und irrationale Zahlen lassen sich grundsaetzlich nicht,  wenn wir es auf einem Rechner darstellen.  Es geht immer um eine Approximation von einer irrationalen Zahl darzustellen.  Gut, die erste Aufgabe, Wurzel 2 mal Wurzel 2, ist das gleich 2.  Also per Hand oder in unserem Kopf ist das ganz klar, das ist 2, das ist vielleicht per Definition so.", "start": 605.0, "end": 641.0}, {"text": "  Aber auf dem Rechner sieht das ein bisschen anders aus.  Ich weise der variablen X hier den Wurzel von 2.  Und dann multipliziere X mit sich selber und pruefe auf Gleichheit mit 2.  Wow, fals.  Gut, das liegt daran, dass der Rechner zuerst den Wurzel, den Python zuerst den Wurzel von 2 berechnet.  Und das ist erstmal nur eine Approximation, also es koennte eine laengere Ziffernfolge hier geben.", "start": 642.0, "end": 686.0}, {"text": "  Und wir haben irgendwo aufgehoert und dadurch entstehen schon mal Rundungsfehler.  Und diese Zahl, die schon fehlerhaft ist, wird mit sich selber hier unten multipliziert und dann stehen wieder noch ein paar Fehler.  Und daher gibt sich diese 2 Punkte viele Nullen und dann ein kleines, finziges 4.  Aber das sorgt dafuer, dass dieses Ergebnis nicht perfekt gleich ist als ein 2.", "start": 686.0, "end": 727.0}, {"text": "  Uebrigens, die Berechnung von Wurzel ist, soweit ich das verstehe, ein iteratives Verfahren,  endlich zu dem Newton-Verfahren, was wir spaeter in diesem Kurs begegnen werden.  Und es geht darum, nah und sozusagen zu raten und nah naeher und naeher und naeher an die gesuchte Zahl zu kommen,  also durch ein Konvergaenzkritaeren, aber letztendlich ist es nur eine Probsimation.", "start": 727.0, "end": 768.0}, {"text": "  Und aehnliches passiert hier mit der Berechnung von Sinus von Pi.  Wir wissen, dass das nun gleich 0 ist, der Winkel 0 oder Pi ist, dann ist der Sinus wert 0.  Ist einfach so.  Und wenn wir auf Gleichheit hier auf 0 pruefen, wow wow you are.  Schoenfalls.", "start": 768.0, "end": 817.0}, {"text": " Gleiches Konzept, wir haben es mit irrationalen Zahlen hier zu tun, Pi ist eine irrationale Zahl  und darin gibt es schon Rundungsfehler, weil wir Pi in ihrer Vollkommenheit nicht umfassen oder auffassen koennen,  nicht so einfach wie einfach ein Pi hinzuschreiben.  Also das heisst Pi wird zunaechst aufgerundet, wir koennen schauen, was eigentlich der Wert fuer Pi ist.", "start": 817.0, "end": 842.0}, {"text": "  Jetzt waere das hier, letztendlich das nur eine Proximation.  Und dann Sinus von Pi ergibt diesen Wert, was eigentlich eine ganz ganz ganz kleine Zahl ist,  also das ist hoch 10 minus 16, aber es ist nicht genau 0, deswegen kommt Forst dabei raus.  Also zunaechst wird diese Proximation benutzt in einer Funktion, die nicht auch nicht so leicht zu implementieren ist auf einem Rechner.", "start": 842.0, "end": 881.0}, {"text": "  Also Sinus um Sinus zu berechnen, muss auch eine Proximation benutzt werden.  Dabei gibt es noch mehr Platz fuer Fehler.  All das zu zeigen, dass man mit gewissen Zahlen aufpassen sollte, vor allem wenn es um Approximationen geht.  Da koennen wir nicht naiv auf Gleichheit mit diesen Gleichheitsoperater pruefen.  Hier empfiehlt sich die Methode is closed zu verwenden.", "start": 881.0, "end": 924.0}, {"text": "  Das sagt uns, ob innerhalb eines gewissen Toleranzintervalls die Aehnlichkeit nah genug ist,  das heisst sind sie closed zueinander.  Und hier liefert is closed zwischen diesem Wert und 0 true.  Und fuer Rays die Vektoren oder Matrizien enthalten sollen, koennt ihr auch, kann man auch close benutzen.  So viel zu Darstimmen von Zahlen und moeglichen Fehler, die dabei auftreten koennen, wenn wir...", "start": 924.0, "end": 970.0}, {"text": "  Ja, komische Sachen wie irrationale Zahlen, wenn wir mit solchen Zahlen arbeiten.  Es geht weiter mit Gleitkommunzer.", "start": 970.0, "end": 975.0}]}]